/* HEADER ************************************************************
# G2D LIBRARY for HOLLYWOOD-MAL

{{Author  : Fabio Falcucci (Allanon)
Contact : info@a-mc.biz
License : Freeware
Support : PayPal (hijoe@tin.it), Patreon (https://www.patreon.com/Allanon71)
Website : a-mc.biz
Github  : Github.com/Allanon71
Links   : https://linksta.cc/@Allanon
Dependancies : Helpers, Easing, Tables, Gfx}}

If you like my work and you want to buy me a coffee you can support me on Patreon https://www.patreon.com/Allanon71  or with PayPal to hijoe@tin.it
*/

/* DESCRIPTION ******************************************************
# G2D Library introduction

I developed this library mainly because I needed a skin system for my bigger project HGui.
I started coding the Area Object, a simple object used to define a square area into the screen but the power of this simple object are in its methods.
I included many methods you can use to skin, fill and manipulate area objects.
The skin system is very powerful, it supports single skin types but also multi-layered skins allowing you to create very complex textures.
I'm' really satistied about the skin system, HGui can mimic almost any system with the right skin and you can use this library for your very own purposes.

But it's not all about the skin system because this library also includes very handy objects to handle 2d points and polygons. 

Polygon objects have some nice collision detection methods I used in my GLFX Engine.
*/

/* INDEX ************************************************************
# INDEX
## POINT 2D OBJECT
- G2D.Point:New(x, y)
- G2D.Point:Distance(point2D)
- G2D.Point:DotProduct(point2D)
- G2D.Point:MidPoint(point2D, newObject)
- G2D.Point:Normal2D(point2D, s)
- G2D.Point:Normalize()
- G2D.Point:Rotate(point, angle)
- G2D.Point:Scale(point, scaleW, scaleH)
 
## POLYGON OBJECT
- G2D.Poly:New(params)
- G2D.Poly:Collide(poly2)
- G2D.Poly:CollideDot(dot)
- G2D.Poly:Draw()
- G2D.Poly:Project(axis)
- G2D.Poly:SetAnchor(anchorX, anchorY)
- G2D.Poly:SetAngle(angle)
- G2D.Poly:SetScale(scaleWidth, scaleHeight)
- G2D.Poly:Translate(x, y)
- G2D.TEST_Poly()
 
## AREA OBJECT
- G2D.Area:New(x, y, w, h)
- G2D.Area:Box(color, offset)
- G2D.Area:FillColor(color)
- G2D.Area:FillPattern(brushID)
- G2D.Area:Move(x, y, absolute)
- G2D.Area:Scale(WFactor, HFactor)
- G2D.Area:SkinBevel(colors, aspect)
- G2D.Area:SkinColor(color, alpha)
- G2D.Area:SkinFitMax(brush, offset, alpha, align)
- G2D.Area:SkinFitMin(brush, offset, alpha, align, border)
- G2D.Area:SkinGradient(col1, col2, alpha, angle)
- G2D.Area:SkinHPattern(brush, offset, alpha)
- G2D.Area:SkinHPattern3S(brush, sectors, alpha, vadapt)
- G2D.Area:SkinMulti(levels, offset)
- G2D.Area:SkinPattern(brush, offset, alpha, size)
- G2D.Area:SkinPattern9S(brush, sectors, alpha, vadapt)
- G2D.Area:SkinQuick(skinBrush, Mode)
- G2D.Area:SkinShades(colList, angle)
- G2D.Area:SkinStretch(brush, offset, alpha, stretch_fix)
- G2D.Area:SkinVPattern(brush, offset, alpha)
- G2D.Area:SkinVPattern3S(brush, sectors, alpha, vadapt)
- G2D.Area:Snapshot(BGPic)
 
# MISC
- G2D.BGPic.CreateSkinned(width, height, skin_struct)
*/

/* HISTORY **********************************************************
# HISTORY
{{
11/07/2023 : Docs refreshed as G2D.md
--/07/2023 : Optimizations & Documentation
12/08/2020 : Fixed a bug in G2D.Area:SkinFitMin() method
}}
*/

@INCLUDE "+Includes.hws"
@INCLUDE #INC_TABLES
@INCLUDE #INC_GFX

Global G2D = {}
       G2D.Version = "1.9"
       G2D.Build   = "11/08/2020"

G2D.BGPic = {}

/* CLASS G2D.Point */
G2D.Point = {}
G2D.Point.x = 0
G2D.Point.y = 0
/* END CLASS */

Function G2D.Point:New(x, y)
/*--------------------------
pointObj = G2D.Point:New(x, y)

Creates an object to represent a 2d point.
'x' and 'y' are the optional initial coordinates, default values are (0, 0)

INPUT
  x : [NUM] Optional horizontal coordinate, default = 0
  y : [NUM] Optional vertical coordinate, default = 0

OUTPUT
  pointObj : [TBL] New point object
----------------------------*/
  Local obj = CopyTable(self)
  
  If Not(IsNil(x)) Then Obj.x = x
  If Not(IsNil(y)) Then Obj.y = y

  Return(obj)
  
EndFunction

Function G2D.Point:Rotate(point, angle)
/*-------------------------------------
G2D.Point:Rotate(point, angle)

Rotates a point around the given anchor point

INPUT
  point : [TBL] The rotation anchor pointObj
  angle : [NUM] Rotation angle in degrees
----------------------------*/

 Local angleRad = Rad(angle)
 Local cosAngle = Cos(angleRad)
 Local sinAngle = Sin(angleRad)
 Local dx = self.x - point.x
 Local dy = self.y - point.y
 
 self.x = point.x + (dx * cosAngle - dy * sinAngle)
 self.y = point.y + (dx * sinAngle + dy * cosAngle)
 
EndFunction

Function G2D.Point:Scale(point, scaleW, scaleH)
/*---------------------------------------------
G2D.Point:Scale(point, scaleW, scaleH)

Scales the distance between the source object and the given point.

INPUT
  point : [TBL] Point object used as a reference for the distance calculation
  scaleW : [NUM] Horizontal scaling factor
  scaleH : [NUM] Vertical scaling factor
----------------------------*/

  Local dx = self.x - point.x
  Local dy = self.y - point.y
  
  self.x = point.x + dx * scaleW
  self.y = point.y + dy * scaleH
  
EndFunction

Function G2D.Point:Distance(point2D)
/*----------------------------------
value = G2D.Point:Distance(point)

Returns the distance in pixels between the object and the given
'point' object.

INPUT
  point : [TBL] The point object used for the distance calculation
  
OUTPUT
  value : [NUM] The distance between the two points in pixels
----------------------------*/

  Return(Sqrt((point2D.x-self.x)^2 + (point2D.y-self.y)^2))

EndFunction

Function G2D.Point:Normalize()
/*----------------------------
G2D.Point:Normalize()

Normalize the point object's coordinates
----------------------------*/

  Local leng = Sqrt(self.x * self.x + self.y * self.y )

  If leng = 0 Then Return()
  self.x = self.x / leng
  self.y = self.y / leng 
  
EndFunction

Function G2D.Point:Normal2D(Point2D, s)
/*-------------------------------------
normalized = G2D.Point:Normal2D(pointObj)

Returns a new object with normalized coordinates.

INPUT
  point2D : [TBL] Reference point object
  s       : [BLN] True : Invert horizontal, False : Invert vertical
  
OUTPUT
  normalized : [TBL] Normalized point object
----------------------------*/

  Local normal = G2D.Point:New()
  
  If s
    normal.x = -(point2D.y-self.y)
    normal.y =  (point2D.x-self.x)
    
  Else
    normal.x =  (point2D.y-self.y)
    normal.y = -(point2D.x-self.x)
    
  EndIf
  
  normal:Normalize()
  
  Return(normal)
  
EndFunction

Function G2D.Point:DotProduct(point2D)
/*------------------------------------
value = G2D.Point:DotProduct(point2D)

Returns the sum of the two point's coordinates products

INPUT
  point2D : [TBL] Reference point object
  
OUTPUT
  value : [NUM] Calculated product
----------------------------*/

  Return (self.x*point2D.x + self.y*point2D.y)
  
EndFunction

Function G2D.Point:MidPoint(point2D, NewObject)
/*---------------------------------------------
result = G2D.Point:MidPoint(pointObj, NewObject)

Returns a table with the mid point coordinates or a new initialized object
representing the middle point between the source point and the given 'point2D'.

INPUT
  point2D   : [TBL] Reference point object
  NewObject : [BLN] True : returns a new initialized point object
              False : returns a table with the 'x' and 'y' members. 
              Default = False.
OUTPUT
  result : [TBL] Depending on 'NewObject' you can have a table with 'x' and 'y'
           members or a new initialized point object.
----------------------------*/

  If IsNil(NewObject) Then NewObject = False

  If NewObject
    Return(G2D.Point:New((point2D.x+self.x)/2, (point2D.y+self.y)/2))
    
  Else
    Return({ x = (point2D.x+self.x)/2, y = (point2D.y+self.y)/2 })
    
  EndIf
  
EndFunction 


/* CLASS G2D.Poly */
G2D.Poly = {}
G2D.Poly.Vertices = {}
G2D.Poly.Normals  = {}
G2D.Poly.VCount   = 0
G2D.Poly.Color    = { 1.0, 1.0, 1.0, 0.5 } ; RGBA
G2D.Poly.Fillmode = #FILLCOLOR
G2D.Poly.x        = 0
G2D.Poly.y        = 0
G2D.Poly.ScaleW   = 1
G2D.Poly.ScaleH   = 1
G2D.Poly.AnchorX  = 0
G2D.Poly.AnchorY  = 0
G2D.Poly.Angle    = 0
/* END CLASS */

Function G2D.Poly:New(params)
/*---------------------------
polyObj = G2D.Poly:New(params)

Returns a new polygon object.

INPUT
  params : [TBL] A table filled with one or more of the following parameters:
    vertices : [TBL] A table of vertices, in { x, y } format
    color    : [NUM] A table with 4 items in RGBA sequence, default { 1.0, 1.0, 1.0, 0.5 }
    fillMode : [CNS] Rendering fillmode, default #FILLCOLOR
    x        : [NUM] Horizontal coordinate, default 0
    y        : [NUM] Vertical coordinate, default 0
    scaleW   : [NUM] Horizontal scaling factor, default 1
    scaleH   : [NUM] Vertical scaling factor, default 1
    anchorX  : [NUM] Horizontal anchor point, default 0
    anchorY  : [NUM] Vertical anchor point, default 0
    angle    : [NUM]Rotation angle, default 0
    
OUTPUT
  polyObject : [TBL] An initialized polygon object
  
NOTES
  You need to provide a valide sequence of vertices.
----------------------------*/
  Local obj = CopyTable(self)
  TB.Set(obj, params, False)
  
  obj.vertices = CopyTable(params.vertices)
  obj.vcount = ListItems(obj.vertices)/2
  
  If obj.vcount = 1 ; DOT
    Local p1 = G2D.Point:New(obj.vertices[0], obj.vertices[1])
    obj.normals[0] = p1:Normal2D(p1, 0)
    Return(obj)
    
  EndIf
  
  For Local i = 0 To obj.vcount*2-4 Step 2
    Local p1 = G2D.Point:New(obj.vertices[i], obj.vertices[i+1])
    Local p2 = G2D.Point:New(obj.vertices[i+2], obj.vertices[i+3])
    obj.normals[i/2] = p1:Normal2D(p2, 0)
    
  Next
  
  ; Last, closing segment
  Local i = obj.vcount*2-2
  Local p1 = G2D.Point:New(obj.vertices[i], obj.vertices[i+1])
  Local p2 = G2D.Point:New(obj.vertices[0], obj.vertices[1])
  obj.normals[i/2+1] = p1:Normal2D(p2, 0)

  Return(obj)
  
EndFunction

Function G2D.Poly:SetAngle(angle)
/*-------------------------------
G2D.Poly:SetAngle(angle)

Change the rotation angle of the polygon updating all the vertices positions.

INPUT
  angle : [NUM] The rotation angle in degrees
----------------------------*/
  If self.angle <> angle
    Local delta = angle - self.angle
    self.angle = angle

    Local vertices = ListItems(self.vertices)-1
    Local anchor   = G2D.Point:New(self.AnchorX, self.AnchorY)
    
    For Local i = 0 To vertices Step 2
      Local p = G2D.Point:New(self.vertices[i], self.vertices[i+1])
      p:Rotate(anchor, delta)
      self.vertices[i], self.vertices[i+1] = p.x, p.y
    Next

  EndIf
  
EndFunction

Function G2D.Poly:SetAnchor(anchorX, anchorY)
/*-------------------------------------------
G2D.Poly:SetAnchor(anchorX, anchorY)

Changes the current anchor point.

INPUT
  anchorX : [NUM] Optional horizontal anchor point
  anchorY : [NUM] Optional vertical anchor point
----------------------------*/
  If Not(IsNil(anchorX)) Then self.anchorX = anchorX
  If Not(IsNil(anchorY)) Then self.anchorY = anchorY

EndFunction

Function G2D.Poly:SetScale(scaleWidth, scaleHeight)
/*-------------------------------------------------
G2D.Poly:SetScale(scaleWidth, scaleHeight)

Changes the current scaling factors.

INPUT
  scaleWidth  : [NUM] New horizontal scale value
  scaleHeight : [NUM] Optional new vertical scale value
NOTES
  If you don't pass a 'scaleHeight' value this function will use the
  'scaleWidth' to hold the aspect ratio.
----------------------------*/
  ; Change Polygon Scale
  If IsNil(scaleHeight) Then scaleHeight = scaleWidth
  
  Local sw, sh = 1, 1
  If self.scaleW <> scaleWidth
    sw = scaleWidth - self.scaleW
    self.scaleW = scaleWidth
  EndIf
  If self.scaleH <> scaleHeight
    sh = scaleHeight - self.scaleH
    self.scaleH = scaleHeight
  EndIf
  
  If sw <> 1 Or sh <> 1
    Local vertices = ListItems(self.vertices)-1
    Local anchor = G2D.Point:New(self.AnchorX, self.AnchorY)
    
    For Local i = 0 To vertices Step 2
      Local p = G2D.Point:New(self.vertices[i], self.vertices[i+1])
      p:Scale(anchor, 1+sw, 1+sh)
      self.vertices[i], self.vertices[i+1] = p.x, p.y
    Next
  EndIf

EndFunction

Function G2D.Poly:Draw()
/*----------------------
G2D.Poly:Draw()

Renders the polygon.
----------------------------*/
  If ListItems(self.vertices) = 2
    Plot(self.vertices[0]+self.x, self.vertices[1]+self.y, ARGB(255-self.color[3]*255, RGB(self.color[0]*255, self.color[1]*255, self.color[2]*255)))
    Return()
  EndIf
  
  SetFillStyle(self.fillmode)
  Polygon(self.x, self.y, self.vertices, self.vcount, ARGB(255-self.color[3]*255, RGB(self.color[0]*255, self.color[1]*255, self.color[2]*255)))

EndFunction  

Function G2D.Poly:Project(Axis)
/*-----------------------------
result = G2D.Poly:Project(Axis)

Project the source point on the given 'Axis', a point object.
Returns the 'min' and 'max' values projected on the 'Axis'.

INPUT
  Axis : A point object representing the projection axis.

OUTPUT
  result : [TBL] A table with the following fields:
    min : [NUM] The minimum value on the axis
    max : [NUM] The maximum value on the axis
----------------------------*/
  ; Axis is a Point object
  ;Local dot  = { x = self.vertices[0], y = self.vertices[1] } ;G2D.Point:New(self.vertices[0], self.vertices[1])
 	Local p    = self.vertices[0]*axis.x+self.vertices[1]*axis.y ;dot:DotProduct(Axis)
 	Local mmin  = p
 	Local mmax  = p

 	For Local i = 2 To self.vcount*2-2 Step 2
    ;dot = { x = self.vertices[i], y = self.vertices[i+1] } ;G2D.Point:New(self.vertices[i], self.vertices[i+1])
		p = self.vertices[i]*axis.x+self.vertices[i+1]*axis.y ; dot:DotProduct(Axis)
 		If p < mmin Then mmin = p
 		If p > mmax Then mmax = p
	Next
 	
	Return({ min = mmin, max = mmax })
  
EndFunction

Function G2D.Poly:CollideDot(dot)
/*-------------------------------
Unfinished method
--------------------------------*/
 ;https://stackoverflow.com/questions/217578/how-can-i-determine-whether-a-2d-point-is-within-a-polygon
EndFunction

Function G2D.Poly:Collide(Poly2)
/*------------------------------
result = G2D.Poly:Collide(Poly2)

Check if the source polygon object collides with the 'Poly2' polygon object.

INPUT
  Poly2 : [TBL] Polygon object to check for collisions
  
OUTPUT
  result : [BLN] True if the source polygon and 'Poly2' polygon are colliding
  
NOTES
  Note that only convex polygon can be checked using this technic.
----------------------------*/

  For Local i = 0 To ListItems(self.normals)-1
		Local axis = self.normals[i]
		Local	proj1 = self:Project(axis)
		Local	proj2 = poly2:Project(axis)
		Local	d1 = (proj1.min - proj2.max)
		Local	d2 = (proj2.min - proj1.max)
		If ((d1 > 0) Or (d2 > 0))
      Return(False)
    EndIf
  Next
  ;Return(True)
	For Local i = 0 To ListItems(Poly2.normals)-1
		Local	axis = Poly2.normals[i]
		Local	proj1 = self:Project(axis)
		Local	proj2 = Poly2:Project(axis)
		Local	d1 = (proj1.min - proj2.max)
		Local	d2 = (proj2.min - proj1.max)
		If ((d1 > 0) Or (d2 > 0))
      Return(False)
    EndIf
  Next
		
  Return(True)
  
EndFunction

Function G2D.Poly:Translate(x, y)
/*-------------------------------
G2D.Poly:Translate(x, y)

Translate the polygon object.

INPUT
  x : [NUM] Horizontal translate value
  y : [NUM] Vertical translate value
----------------------------*/

  For Local p = 0 To self.vcount*2-2 Step 2
    self.vertices[p] = self.vertices[p] + x
    self.vertices[p+1] = self.vertices[p+1] + y
  Next
  self.AnchorX = self.AnchorX + x
  self.AnchorY = self.AnchorY + y
  
EndFunction

Function G2D.TEST_Poly()
/*----------------------
G2D.TEST_Poly()

Show how to use the Poly object and test some methods.
----------------------------*/
  ; Defines the First polygon
  Local p1 = G2D.Poly:New(
    { vertices = { 50, 50, 100, 30, 100, 100, 50, 100, 20, 90 },
      x = 0, 
      y = 0,
      anchorX = 50, anchorY = 50 })

  ; Defines the Second polygon
  Local p2 = G2D.Poly:New(
    { vertices = { 60, 60, 110, 60, 110, 110, 60, 150 },
      x = 0, 
      y = 0 })

  ; Defines the Third polygon (a single dot)
  Local p3 = G2D.Poly:New(
    { vertices = { 140, 100 },
      x = 0, 
      y = 0 })
      
  ; Initialize some variable and start a simple rendering loop
  Loop, refresh, angle, scale = True, True, 0, 1
  
  While Loop
    If refresh
      BeginRefresh()
      Cls
      p1:Draw()
      p2:Draw()
      p3:Draw()
    
      Locate(0, 0)
      StartTimer(1)
      Local c, c2
      For Local i = 1 To 200
        c  = p1:Collide(p2)
        c2 = p1:Collide(p3)
      Next
      NPrint(":: POLYGON OBJECT TEST ::")
      NPrint("Elapsed is the time in ms needed for collisions check.\n")
      NPrint("Collision : " .. c .. ", " .. c2 .. ", Elapsed : ", GetTimer(1)/200 .. "ms")
      NPrint("Move : arrows, Rotate : a, s, Zoom : z, x, Quit: q")
      EndRefresh()
      refresh = False
    EndIf
    
    If IsKeyDown("LEFT")
      p1:Translate(-0.5, 0)
      refresh = True
    ElseIf IsKeyDown("RIGHT")
      p1:Translate(0.5, 0)
      refresh = True
    ElseIf IsKeyDown("UP")
      p1:Translate(0, -0.5)
      refresh = True
    ElseIf IsKeyDown("DOWN")
      p1:Translate(0, 0.5)
      refresh = True
    ElseIf IsKeyDown("a")
      angle = angle + 0.1
      p1:SetAngle(angle)
      refresh = True
    ElseIf IsKeyDown("s")
      angle = angle - 0.1
      p1:SetAngle(angle)
      refresh = True
    ElseIf IsKeyDown("z")
      scale = scale + 0.001
      p1:SetScale(scale)  
      refresh = True
    ElseIf IsKeyDown("x")
      scale = scale - 0.001
      p1:SetScale(scale)
      refresh = True
    ElseIf IsKeyDown("q")
      End
    EndIf
  
  Wend

EndFunction



/* CLASS G2D.Area */
G2D.Area =  {}
G2D.Area.x = 0
G2D.Area.y = 0
G2D.Area.w = 50
G2D.Area.h = 50
/* END CLASS */

Function G2D.Area:New(x, y, w, h)
/*-------------------------------
areaObj = G2D.Area:New(x, y, w, h)

Creates and returns a new Area object.

INPUT
  x : [NUM] Optional horizontal coordinate, default = 0
  y : [NUM] Optional vertical coordinate, default = 0
  w : [NUM] Optional width in pixels, default = 50
  h : [NUM] Optional height in pixels, default = 50
  
OUTPUT
  areaObj : [NUM] New, initialized Area object
----------------------------*/
  Local obj = CopyTable(self)
  TB.Set(obj, { x = x, y = y, w = w, h = h })
  
  Return(obj)
  
EndFunction

Function G2D.Area:Scale(WFactor, HFactor)
/*---------------------------------------
G2D.Area:Scale(wFactor, hFactor)

Scales the area using the given horizontal and vertical factors.

INPUT
  wFactor : [NUM] Horizontal scaling factor, default 1
  hFactor : [NUM] Vertical scaling factor, default 1
----------------------------*/
  If IsNil(WFactor) Then WFactor = 1
  If IsNil(HFactor) Then HFactor = 1

  self.w = self.w * WFactor
  self.h = self.h * HFactor

EndFunction

Function G2D.Area:Move(x, y, absolute)
/*------------------------------------
G2D.Area:Move(x, y, absolute)

Move the area object to another position or by a given amount, depending on the
'absolute' switch state.

INPUT
  x : [NUM] Optional horizontal position or relative horizontal movement.
  y : [NUM] Optional vertical position or relative vertical movement.
  absolute : [BLN] Optional True to use the horizontal and vertical values as a new 
             absolute position, or False to use these values as relative position.
             Default = False.

NOTE
  If absolute = True than x and y default values are current area values
  If absolute = False that x and y default values are 0
----------------------------*/
  If IsNil(absolute) Then absolute = False

  If absolute = True
    If IsNil(x) Then x = self.x
    If IsNil(y) Then y = self.y

    self.x = x
    self.y = y
    
  Else
    If IsNil(x) Then x = 0
    If IsNil(y) Then y = 0

    self.x = self.x + x
    self.y = self.y + y
    
  EndIf

EndFunction

Function G2D.Area:FillPattern(BrushID)
/*------------------------------------
G2D.Area:FillPattern(brushID)

Fill the area object using the given brush as a pattern.

INPUT
  BrushID : [ID] A valid Hollywood brush id
----------------------------*/
  Local holdpos = {}

  Local clipid = GFX.SafeClipRegion(Nil, #BOX, self.x, self.y, self.w, self.h)
  SetClipRegion(clipid)

  Local BrushSize = {}
  BrushSize.x = GetAttribute(#BRUSH, BrushID, #ATTRWIDTH)
  BrushSize.y = GetAttribute(#BRUSH, BrushID, #ATTRHEIGHT)

  
  Local HSteps = Int(self.w / BrushSize.x) + 1
  Local VSteps = Int(self.h / BrushSize.y) + 1

  For Local r = 1 To VSteps
    For Local c = 1 To HSteps
      DisplayBrush(BrushID, self.x + (c-1)*BrushSize.x, self.y + (r-1)*BrushSize.y)
    Next
  Next
  
  /*---------------------------------
  The code above is a bit slower but I used this method for better handling the
  transparency by the skin methods that uses this fill mode.
  
  SetFillStyle(#FILLTEXTURE, BrushID)
  Box(self.x, self.y, self.w, self.h)
  -----------------------------------*/
  
  SetClipRegion(#NONE)
  FreeClipRegion(clipid)
  
EndFunction

Function G2D.Area:SkinQuick(SkinBrush, Mode)
/*------------------------------------------
G2D.Area:SkinQuick(SkinBrush, Mode)

Method used to fill the area object with a skin without the need to specify
too much parameters.

INPUT
  SkinBrush : [ID] A valid Hollywood brush id to use as a fill base.
  Mode      : [NUM] Ones skinning mode from the following:
    GFX.SkinMode_Pattern : The brush will be used as a tile
    GFX.SkinMode_Image   : The brush will be stretched to cover the area
    GFX.SkinMode_Skin9S  : The brush will be splitted into nine sectors (3x3),
                           each one will be used to skin the area this way:
                           +---+---+---+   A: Top-left edge
                           | A | B | C |   B: Top-middle (horizontal pattern)
                           +---+---+---+   C: Top-right edge
                           | D | E | F |   D: Left-middle (vertical pattern)
                           +---+---+---+   E: middle (area pattern)
                           | G | H | I |   F: Right-middle (vertical pattern)
                           +---+---+---+   and so on...
NOTE
  To have perfect pixel skins with the 'GFX.SkinMode_Skin9S' mode your brush size
  should be a multiple of 3
----------------------------*/
  If IsNil(SkinBrush) Then Return()

  Switch Mode
    Case 1 
      ;| GFX.SkinMode_Pattern |
      ;+----------------------+
      self:fillPattern(SkinBrush)

    Case 2 
      ;| GFX.SkinMode_Image |
      ;+--------------------+
      Local tBrush = CopyBrush(SkinBrush, Nil)
      ScaleBrush(tBrush, Ceil(self.w), Ceil(self.h), True)
      DisplayBrush(tBrush, self.x, self.y)
      FreeBrush(tBrush)

    Case 3
      ;| GFX.SkinMode_Skin9S |
      ;+---------------------+
      Local Source = SkinBrush
      Local Width  = GetAttribute(#BRUSH, Source, #ATTRWIDTH)
      Local Height = GetAttribute(#BRUSH, Source, #ATTRHEIGHT)
      Local xPiece = Width  / 3
      Local yPiece = Height / 3

      ; Top/Left corner
      DisplayBrushPart(Source, 0, 0, self.x, self.y, xPiece, yPiece)

      ; Bottom/Left corner
      DisplayBrushPart(Source, 0, yPiece * 2, self.x, self.y + self.h - yPiece, xPiece, yPiece)

      ; Top/Right corner
      DisplayBrushPart(Source, xPiece * 2, 0, self.x + self.w - xPiece, self.y, xPiece, yPiece)

      ; Bottom/Right corner
      DisplayBrushPart(Source, xPiece * 2, yPiece * 2, self.x + self.w - xPiece, self.y + self.h - yPiece, xPiece, yPiece)

      ; Top-middle area
      Local cr = GFX.SafeClipRegion(Nil, #BOX, self.x + xPiece, self.y, self.w - xPiece * 2, yPiece)
      SetClipRegion(cr)

      Local H_IT = (self.w / xPiece) - 1
      For Local i = 1 To H_IT
        DisplayBrushPart(Source, xPiece, 0, self.x + i * xPiece, self.y, xPiece, yPiece)
      Next
      FreeClipRegion(cr)

      ; Bottom-middle area
      Local cr = GFX.SafeClipRegion(Nil, #BOX, self.x + xPiece, self.y + self.h - yPiece, self.w - xPiece * 2, yPiece)
      SetClipRegion(cr)

      Local H_IT = (self.w / xPiece) - 1
      For Local i = 1 To H_IT
        DisplayBrushPart(Source, xPiece, yPiece * 2, self.x + i * xPiece, self.y + self.h - yPiece, xPiece, yPiece)
      Next
      FreeClipRegion(cr)

      ; Middle Area
      Local cr = GFX.SafeClipRegion(Nil, #BOX, self.x + xPiece, self.y + yPiece, self.w - xPiece * 2, self.h - yPiece * 2)
      SetClipRegion(cr)

      Local H_IT = (self.w / xPiece) - 1
      Local V_IT = (self.h / yPiece) - 1
      For Local k = 1 To V_IT
        For Local i = 1 To H_IT
          DisplayBrushPart(Source, xPiece, yPiece, self.x + i * xPiece, self.y + k * yPiece, xPiece, yPiece)
        Next
      Next
      FreeClipRegion(cr)

      ; Left-middle Area
      Local cr = GFX.SafeClipRegion(Nil, #BOX, self.x, self.y + yPiece, xPiece, self.h - yPiece * 2)
      SetClipRegion(cr)

      Local V_IT = (self.h / yPiece) - 1
      For Local i = 1 To V_IT
        DisplayBrushPart(Source, 0, yPiece, self.x, self.y + i * yPiece, xPiece, yPiece)
      Next
      FreeClipRegion(cr)

      ; Right-middle Area
      Local cr = GFX.SafeClipRegion(Nil, #BOX, self.x + self.w - xPiece, self.y + yPiece, xPiece, self.h - yPiece * 2)
      SetClipRegion(cr)

      Local V_IT = (self.h / yPiece) - 1
      For Local i = 1 To V_IT
        DisplayBrushPart(Source, xPiece * 2, yPiece, self.x + self.w - xPiece, self.y + i * yPiece, xPiece, yPiece)
      Next
      
      SetClipRegion(#NONE)
      FreeClipRegion(cr)

  EndSwitch

EndFunction

Function G2D.Area:SkinStretch(brush, offset, alpha, stretch_fix)
/*--------------------------------------------------------------
result = G2D.Area:SkinStretch(Brush, Offset, Alpha, Stretch_Fix)

Skins the area object stretching the image 'brush' (a filename or a brush id).
The 'brush' can be shifted using the table 'offset', you can also adjust
the transparency with the 'alpha' parameter.

INPUT
  brush  : [ID|STR] A valid Hollywood brush id or an image filename. In the last case
           the brush will be loaded, used and removed from memory just after
           the rendering.
  offset : [TBL] This table is used to shift horizontally, vertically or in both 
           directions the brush image. It must have the following fields:
    x : [NUM] Horizontal shift
    y : [NUM] Vertical shift 
  alpha  : [NUM] With this parameter you can override the brush's alpha channel (if
           defined) with a custom one. Set this parameter with #NONE to leave
           untouched the brush's alpha channel. Defaults to #NONE.
  stretch_fix : [NUM] I've introduced this fix because when I stretch a brush using
                smoothness I get an image that is bigger then the same image stretched 
                without smooth, the difference seems to be a single pixel.
                This argument can handle 1, 2 or 3 as value to fix the width, the height
                or both.
                
OUTPUT
  result : [BLN] Returns 'True' if there was no errors.
----------------------------*/
  ; Parameters check
  If IsNil(brush ) Then Return(False)
  If IsNil(offset) Then offset = { x = 0, y = 0 }
  If IsNil(alpha ) Then alpha = #NONE

  ; Round the area coordinates and sizes
  Local x, y, w, h = Round(self.x), Round(self.y), Round(self.w), Round(self.h)
  Local ox, oy = Round(Offset.x), Round(Offset.y)
  Local brush_id = -1
  Local BrushHasBeenLoaded = False
  Local TempBrushCreated   = False

  ; Check the brush parameter
  If GetType(brush) = #STRING
    If Exists(brush)
      Local r, s = IsPicture(brush)
        If r
          brush_id = LoadBrush(Nil, brush, { LoadAlpha = s.alpha })
          BrushHasBeenLoaded = True
          
        Else
          ; Error analysing the brush
          Return(False)
          
        EndIf
        
    Else
      ; The file do not exists
      Return(False)
      
    EndIf
    
  Else
    brush_id = brush
    
  EndIf

  Local tmpBrush = -1
  If GetType(brush) <> #STRING
    tmpBrush = CopyBrush(brush_id, Nil)
    TempBrushCreated = True
    
  Else
    tmpBrush = brush_id
    
  EndIf

  ; Check the alpha parameter
  If alpha <> #NONE
    GFX.OutputDevice.Select(#ALPHACHANNEL, tmpBrush)
      SetAlphaIntensity(alpha)
      Cls()
    GFX.OutputDevice.EndSelect()

  EndIf

  ; Check the offset parameter
  GFX.Brush.HShift(tmpBrush, Offset.x)
  GFX.Brush.VShift(tmpBrush, Offset.y)

  ; Stretch & render the brush
  Local t = CopyTable(self)
  If stretch_fix = 1
    t.w = t.w - 1
    
  ElseIf stretch_fix = 2
    t.h = t.h - 1
    
  ElseIf stretch_fix = 3
    t.w = t.w - 1
    t.h = t.h - 1
    
  EndIf

  ScaleBrush(tmpBrush, t.w, t.h, GFX.SmoothZoom)
  DisplayBrush(tmpBrush, x, y)

  ; Free the resources
  If TempBrushCreated Then FreeBrush(tmpBrush)
  If BrushHasBeenLoaded Then FreeBrush(Brush_id)
  Return(True)

EndFunction

Function G2D.Area:Box(color, offset)
/*----------------------------------
G2D.Area:Box(color, offset)

Draw a border around the area, offset will be used to make an inner box
or an outer box depending if the offset value is negative or positive.

INPUT
  color  : [NUM] Border color
  offset : [NUM] Offset value to make the box smaller or bigger than the actual area
           size.
----------------------------*/
  SetFillStyle(#FILLNONE)
  Box(self.x - offset, self.y - offset, self.w + offset*2, self.h + offset*2, color)

EndFunction

Function G2D.Area:FillColor(color)
/*--------------------------------
G2D.Area:FillColor(Color)

Fill the area object with the specified 'Color'.

INPUT
  Color : [NUM] The fill color
----------------------------*/
  SetFillStyle(#FILLCOLOR)
  Box(self.x, self.y, self.w, self.h, color)

EndFunction

Function G2D.Area:SkinPattern(brush, offset, alpha, size)
/*-------------------------------------------------------
result = G2D.Area:FkinPattern(Brush, Offset, Alpha, Size)

Skin the area object with the 'Brush' pattern. 
The brush can be shifted using the 'Offset' table, you can control 
transparency with 'Alpha' argument.

INPUT
  Brush  : [ID|STR] The brush to use to skin the area. It can be a brush id
           or a filename, in the last case the brush will be loaded, used and
           and removed from memory just after the rendering.
  Offset : [TBL] This table is used to shift horizontally, vertically or in both
            directions the brush. It must have the following fields:
    x : [NUM] Horizontal shift in pixels
    y : [NUM] Vertical shift in pixels
  Alpha  : [NUM] With this parameter you can override the brush's alpha channel 
           (if defined) with a custom transparency value. Set this parameter to
           #NONE to leave untouched the brush's alpha channel.
  Size   : [TBL] Optional brush tile size, it must have the fields:
    w : [NUM] Tile width in pixels
    h : [NUM] Tile height in pixels

OUTPUT
  result : [BLN] True if all gone fine.
----------------------------*/
  ; Parameters check
  If IsNil(brush ) Then Return(False)
  If IsNil(offset) Then offset = { x = 0, y = 0 }
  If IsNil(alpha ) Then alpha = #NONE

  ; Round the area coordinates and dimentions
  Local x, y, w, h = Round(self.x), Round(self.y), Round(self.w), Round(self.h)
  Local ox, oy = Round(Offset.x), Round(Offset.y)
  Local brush_id = -1
  Local BrushHasBeenLoaded = False
  Local TempBrushCreated   = False

  ; Check the brush parameter
  If GetType(brush) = #STRING
    If Exists(brush)
      Local r, s = IsPicture(brush)
      If r
        brush_id = LoadBrush(Nil, brush, { LoadAlpha = s.alpha })
        BrushHasBeenLoaded = True
        
      Else
        Return(False)
        
      EndIf
    Else
      Return(False)
      
    EndIf
  Else
    brush_id = brush
    
  EndIf

  Local tmpBrush = -1
  If GetType(brush) <> #STRING
    tmpBrush = CopyBrush(brush_id, Nil)
    TempBrushCreated = True
    
  Else
    tmpBrush = brush_id
    
  EndIf

  ; Check the alpha parameter
  If alpha <> #NONE
    GFX.OutputDevice.Select(#ALPHACHANNEL, tmpBrush)
      SetAlphaIntensity(alpha)
      Cls()
    GFX.OutputDevice.EndSelect()
    
  EndIf

  ; Check the offset parameter
  GFX.Brush.HShift(tmpBrush, Offset.x)
  GFX.Brush.VShift(tmpBrush, Offset.y)

  ; Ridimensiona il brush se necessario
  If Not(IsNil(size)) Then ScaleBrush(tmpBrush, Size.w, Size.h, GFX.SmoothZoom)

  ; Render the pattern
  self:fillPattern(tmpBrush)

  ; Free the resources
  If TempBrushCreated Then FreeBrush(tmpBrush)
  If BrushHasBeenLoaded Then FreeBrush(Brush_id)

  Return(True)

EndFunction

Function G2D.Area:SkinFitMax(brush, offset, alpha, align)
/*-------------------------------------------------------
result = G2D.Area:SkinFitMax(brush, offset, alpha, align)

Skin the area object with a scaled brush keeping its aspect ratio. The brush
can be shifted using the 'offset' table and you can control transparency 
with 'alpha' that allows yout to ovverride the existing one if defined.
Using this function the image will be maximized to cover the entire area, it
may be possible that the image cannot be completely visible because some part
go outside the visible area because of the maximization and the aspect ratio.

INPUT
  brush  : [ID|STR] The brush to use to skin the area. It can be a brush id
           or a filename, in the last case the brush will be loaded, used and
           removed from memory.
  offset : [TBL] This table is used to shift horizontally, vertically or in both
           directions the brush. It must have the following fields:
    x : [NUM] Horizontal shift in pixels
    y : [NUM] Vertical shift in pixels
  alpha  : [NUM] With this parameter you can override the brush's alpha channel
           (if defined) with a custom one. Set this parameter to #NONE to leave
           untouched the brush's alpha channel.
  align  : [NUM] Image alignment, can be #CENTER, #LEFT, #RIGHT, #TOP,
           or #BOTTOM, default value is #CENTER.

OUTPUT
  result : [BLN] Returns True if no error was raised-
----------------------------*/
  ; Round the self coordinates and size
  Local x, y, w, h = Round(self.x), Round(self.y), Round(self.w), Round(self.h)
  Local ox, oy = Round(Offset.x), Round(Offset.y)
  Local brush_id = -1
  Local BrushHasBeenLoaded = False
  Local TempBrushCreated   = False

  If IsNil(align) Then align = #CENTER

  ; Check the brush parameter
  If GetType(brush) = #STRING
    If Exists(brush)
      Local r, s = IsPicture(brush)
      If r
        ExitOnError(False)
        brush_id = LoadBrush(Nil, brush, { LoadAlpha = s.alpha })
        Local lastError = GetLastError()
        ExitOnError(True)
        If lastError = 0
          BrushHasBeenLoaded = True
        Else
          Return(False)
          BrushHasBeenLoaded = False
        EndIf
      Else
        Return(False)
      EndIf
    Else
      Return(False)
    EndIf
  Else
    brush_id = brush
  EndIf

  Local tmpBrush = -1
  If GetType(brush) <> #STRING
    tmpBrush = CopyBrush(brush_id, Nil)
    TempBrushCreated = True
  Else
    tmpBrush = brush_id
  EndIf

  ; Check the alpha parameter
  If alpha <> #NONE
    GFX.OutputDevice.Select(#ALPHACHANNEL, tmpBrush)
      SetAlphaIntensity(alpha)
      Cls()
    GFX.OutputDevice.EndSelect()
  EndIf

  ; Check the offset parameter
  GFX.Brush.HShift(tmpBrush, Offset.x)
  GFX.Brush.VShift(tmpBrush, Offset.y)

  ; Render the pattern
  GFX.ImageFX.Scale(tmpBrush, self.w, self.h, False, True)
  
  Local w = GetAttribute(#BRUSH, tmpBrush, #ATTRWIDTH)
  Local h = GetAttribute(#BRUSH, tmpBrush, #ATTRHEIGHT)
  Local ox = (self.w - w)/2
  Local oy = (self.h - h)/2
  If align = #LEFT
    ox = 0
  ElseIf align = #RIGHT
    ox = self.w - w
  EndIf
  
  If align = #TOP
    oy = 0
  ElseIf align = #BOTTOM
    oy = self.h - h
  EndIf
   
  Local cid = GFX.SafeClipRegion(Nil, #BOX, self.x, self.y, self.w, self.h)

  ;Local cid = CreateClipRegion(Nil, #BOX, self.x, self.y, self.w, self.h)
  SetClipRegion(cid)
  DisplayBrush(tmpBrush, self.x + ox, self.y + oy)
  SetClipRegion(#NONE)
  FreeClipRegion(cid)

  ; Free the resources
  If TempBrushCreated Then FreeBrush(tmpBrush)
  If BrushHasBeenLoaded Then FreeBrush(Brush_id)

  Return(True)

EndFunction

Function G2D.Area:SkinFitMin(brush, offset, alpha, align, border)
/*---------------------------------------------------------------
result = G2D.Area:SkinFitMin(brush, offset, alpha, align, border)

Skin the area object with a scaled brush keeping its aspect ratio.
The brush can be shifted using the table <offset> and you can control
transparency with 'alpha' argument to override the existing one if defined.
Using this function the image will be maximized to cover the entire area but
without letting the image go out of the area boundaries so you could have
visible borders.

INPUT
  brush  : [ID|STR] The brush to use to skin the area. It can be a brush id
           or a filename, in the last case the brush will be loaded, used
           and removed from memory.
  offset : [TBL] This table is used to shift horizontally, vertically or in
           both directions the brush. It must have the following fields:
    x : [NUM] Horizontal shift in pixels
    y : [NUM] Vertical shift in pixels
  alpha  : [NUM] With this parameter you can override the brush's alpha channel
           (if defined) with a custom one. Set this parameter to #NONE to leave
           untouched the brush's alpha channel.
  align  : [NUM] Image alignment within the area object, it can be #CENTER,
           #LEFT, #RIGHT, #TOP, #BOTTOM, default value is #CENTER.
  border : [NUM] Border color.

OUTPUT
  result : [BLN] Returns True if no error was raised-
----------------------------*/
  ; Round the self coordinates and size
  Local x, y, w, h = Round(self.x), Round(self.y), Round(self.w), Round(self.h)
  Local ox, oy = Round(Offset.x), Round(Offset.y)
  Local brush_id = -1
  Local BrushHasBeenLoaded = False
  Local TempBrushCreated   = False

  If IsNil(align) Then align = #CENTER

  ; Check the brush parameter
  If GetType(brush) = #STRING
    If Exists(brush)
      Local r, s = IsPicture(brush)
      If r
        ExitOnError(False)
        brush_id = LoadBrush(Nil, brush, { LoadAlpha = s.alpha })
        Local lastError = GetLastError()
        ExitOnError(True)
        If lastError = 0
          BrushHasBeenLoaded = True
        Else
          Return(False)
          BrushHasBeenLoaded = False
        EndIf
      Else
        Return(False)
      EndIf
    Else
      Return(False)
    EndIf
  Else
    brush_id = brush
  EndIf

  Local tmpBrush = -1
  If GetType(brush) <> #STRING
    tmpBrush = CopyBrush(brush_id, Nil)
    TempBrushCreated = True
  Else
    tmpBrush = brush_id
  EndIf

  ; Check the alpha parameter
  If alpha <> #NONE
    GFX.OutputDevice.Select(#ALPHACHANNEL, tmpBrush)
      SetAlphaIntensity(alpha)
      Cls()
    GFX.OutputDevice.EndSelect()
  EndIf

  ; Check the offset parameter
  GFX.Brush.HShift(tmpBrush, Offset.x)
  GFX.Brush.VShift(tmpBrush, Offset.y)

  ; Render the pattern
  GFX.ImageFX.Scale(tmpBrush, self.w, self.h, False, False)
   
  Local w = GetAttribute(#BRUSH, tmpBrush, #ATTRWIDTH)
  Local h = GetAttribute(#BRUSH, tmpBrush, #ATTRHEIGHT)
  Local ox = (self.w - w)/2
  Local oy = (self.h - h)/2
  If align = #LEFT
    ox = 0
  ElseIf align = #RIGHT
    ox = self.w - w
  EndIf
  
  If align = #TOP
    oy = 0
  ElseIf align = #BOTTOM
    oy = self.h - h
  EndIf
  
  Local cid = GFX.SafeClipRegion(Nil, #BOX, self.x, self.y, self.w, self.h)
  SetClipRegion(cid)

  ;::: BORDERS :::
  If HL.IsNotNil(Border)
    self:FillColor(Border)

    SetFillStyle(#FILLCOLOR)
    Local deltay = (self.h - h) / 2
    Local deltax = (self.w - w) / 2
    Local bt, bb = { 0, 0, 0, 0 }, { 0, 0, 0, 0 }
    Local bl, br = { 0, 0, 0, 0 }, { 0, 0, 0, 0 }
    
        bt = { self.x, self.y, w, deltay }
        bb = { self.x, self.y + h + deltay, w, deltay }
        bl = { self.x, self.y, deltax, h }
        br = { self.x + w + deltax, self.y, deltax, h }
    
    Switch align
      Case #CENTER
        bt = { self.x, self.y, w, deltay }
        bb = { self.x, self.y + h + deltay, w, deltay }
        bl = { self.x, self.y, deltax, h }
        br = { self.x + w + deltax, self.y, deltax, h }
        
      Case #TOP
        bt = Nil
        bb = { self.x, self.y + h, w, deltay*2 }
        
      Case #BOTTOM
        bb = Nil
        bt = { self.x, self.y, w, deltay*2 }
        
      Case #LEFT
        bl = Nil
        br = { self.x + w, self.y, deltax*2, h }
        
      Case #RIGHT
        br = Nil
        bl = { self.x, self.y, deltax*2, h }

    EndSwitch

  EndIf
  
  DisplayBrush(tmpBrush, self.x + ox, self.y + oy)
  SetClipRegion(#NONE)
  
  FreeClipRegion(cid)

  ; Free the resources
  If TempBrushCreated Then FreeBrush(tmpBrush)
  If BrushHasBeenLoaded Then FreeBrush(Brush_id)

  Return(True)

EndFunction

Function G2D.Area:SkinColor(color, alpha)
/*---------------------------------------
result = G2D.Area:SkinColor(color, alpha)

Use this function to skin the area object, color can be in RRGGBB format or in
AARRGGBB format. 'alpha' is the transparency level, but remember that if you
are using a color in AARRGGBB format the alpha channel will be replaced by the
'alpha' value.

INPUT
  color : [NUM] The color you want to use to fill the area with.
  alpha : [NUM] With this parameter you can override the color's alpha channel
          (if specified) with a custom one. Set this parameter with #NONE to leave
          untouched the color's alpha channel.

OUTPUT
  result : [BLN] Returns True if no error was raised
----------------------------*/
  ; Round the self coordinates and dimentions
  Local x, y, w, h = Round(self.x), Round(self.y), Round(self.w), Round(self.h)

  If IsNil(alpha) Then alpha = #NONE
  If alpha <> #NONE Then color = ARGB(255 - alpha, color)

  SetFillStyle(#FILLCOLOR)
  Box(self.x, self.y, self.w+1, self.h+1, color)

  Return(True)

EndFunction

Function G2D.Area:SkinBevel(colors, aspect)
/*-----------------------------------------
result = G2D.Area:SkinBevel(colors, aspect)

Use this method to skin the specified 'area'. 
'colors' is a table used to define the colors that must be used to render
the bevel box.

INPUT
  colors : [TBL] A table with the color to use, must have the following fields:
    light  : [NUM] Light Edges (top and left)
    dark   : [NUM] Dark Edges (bottom and right)
    middle : [NUM] Internal color (set to nil to not fill this space)
  aspect : [TBL] It is a table with further parameters with the following fields:
    fx : [NUM] Can be one of the following effect : 
           GFX.BevelFx_Raised     Raised look
           GFX.BevelFx_Recessed   Recessed look (inverted light & dark colors)
           GFX.BevelFx_Flat       Flat look (no 3d borders)
    height : [NUM] Border's height in pixels
    type : [NUM] Bevel box type :
             GFX.BevelType_Standard
             GFX.BevelType_Sunken

OUTPUT
  result : [BLN] Returns True if no error was raised
----------------------------*/
  ; Round the area coordinates and size
  Local x, y, w, h = Round(self.x), Round(self.y), Round(self.w), Round(self.h)

  ;::: FILL COLOR :::
  If HaveItem(colors, "middle")
    SetFillStyle(#FILLCOLOR)
    Local ww, hh = w - aspect.height * 2 + 1, h - aspect.height * 2 + 1
    If ww < 1 Then ww = 1
    If hh < 1 Then hh = 1
    Box(x + aspect.height, y + aspect.height, ww, hh, colors.middle)

  EndIf

  ;::: EDGES :::
  Local DColor = colors.dark
  Local LColor = colors.light

  ;::: EFFECTS :::
  If aspect.fx = GFX.BevelFx_Recessed
    DColor, LColor = LColor, DColor

  EndIf

  ;::: DRAW BORDERS :::
  If aspect.fx = GFX.BevelFx_Flat
    ;::: FLAT :::
    SetFillStyle(#FILLNONE)
    For Local i = 1 To aspect.height
      Local s = i - 1
      Local w1, h1 = w - (s*2)+1, h - (s*2)+1
      If w1>0 And h1>0 Then Box(x + s, y + s, w1, h1, LColor)
    Next

  Else
    If aspect.type = GFX.BevelType_Standard
      ;::: STANDARD :::
      For Local i = 1 To aspect.height
        Local s = i - 1

        Local TopLeft     = { x = x + s, y = y + s }
        Local TopRight    = { x = TopLeft.x + w - s*2, y = TopLeft.y }
        Local BottomLeft  = { x = TopLeft.x, y = TopLeft.y + h - s*2 }
        Local BottomRight = { x = TopRight.x, y = BottomLeft.y }

        ;::: BOTTOM :::
        Line(BottomLeft.x, BottomLeft.y, BottomRight.x, BottomRight.y, DColor)

        ;::: RIGHT :::
        Line(TopRight.x, TopRight.y, BottomRight.x, BottomRight.y, DColor)

        ;::: TOP :::
        Line(TopLeft.x, TopLeft.y, TopRight.x, TopRight.y, LColor)

        ;::: LEFT :::
        Line(TopLeft.x, TopLeft.y, BottomLeft.x, BottomLeft.y, LColor)

      Next

    ElseIf aspect.type = GFX.BevelType_Sunken
      ;::: SUNKEN :::

      ;::: OUTER BOX :::
      For Local i = 1 To aspect.height
        Local s = i - 1

        Local TopLeft     = { x = x + s, y = y + s }
        Local TopRight    = { x = TopLeft.x + w - s*2, y = TopLeft.y }
        Local BottomLeft  = { x = TopLeft.x, y = TopLeft.y + h - s*2 }
        Local BottomRight = { x = TopRight.x, y = BottomLeft.y }

        ;::: BOTTOM :::
        Line(BottomLeft.x, BottomLeft.y, BottomRight.x, BottomRight.y, DColor)

        ;::: RIGHT :::
        Line(TopRight.x, TopRight.y, BottomRight.x, BottomRight.y, DColor)

        ;::: TOP :::
        Line(TopLeft.x, TopLeft.y, TopRight.x, TopRight.y, LColor)

        ;::: LEFT :::
        Line(TopLeft.x, TopLeft.y, BottomLeft.x, BottomLeft.y, LColor)

      Next

      ;::: INNER BOX :::
      For Local i = 1 To aspect.height
        Local s = i - 1 + aspect.height

        Local TopLeft     = { x = x + s, y = y + s }
        Local TopRight    = { x = TopLeft.x + w - s*2, y = TopLeft.y }
        Local BottomLeft  = { x = TopLeft.x, y = TopLeft.y + h - s*2 }
        Local BottomRight = { x = TopRight.x, y = BottomLeft.y }

        ;::: BOTTOM :::
        Line(BottomLeft.x, BottomLeft.y, BottomRight.x, BottomRight.y, LColor)

        ;::: RIGHT :::
        Line(TopRight.x, TopRight.y, BottomRight.x, BottomRight.y, LColor)

        ;::: TOP :::
        Line(TopLeft.x, TopLeft.y, TopRight.x, TopRight.y, DColor)

        ;::: LEFT :::
        Line(TopLeft.x, TopLeft.y, BottomLeft.x, BottomLeft.y, DColor)
      Next

    Else
      Return(False)

    EndIf

  EndIf

  Return(True)

EndFunction

Function G2D.Area:SkinGradient(col1, col2, alpha, angle)
/*------------------------------------------------------
result = G2D.Area:SkinGradient(col1, col2, alpha, angle)

This method is able to skin an area object using a linear color gradient
defined by 'col1' and 'col2' colors. You can control the transparency using
'alpha' and you can also rotate the gradient using the parameter 'angle'.

INPUT
  col1  : [NUM] Fill color 1 in RRGGBB format, any alpha channel informations
         will be ignored.
  col2  : [NUM] Fill color 2 in RRGGBB format, any alpha channel informations
         will be ignored.
  alpha : [NUM] Use this parameter to control the gradient transparency, set
          it to #NONE to have the gradient fully opaque.
  angle : [NUM] Rotation angle of the gradient.

OUTPUT
  result : [BLN] Returns TRUE if the operation reported no errors.
----------------------------*/
  ; Round the area coordinates and dimentions
  Local x, y, w, h = Round(self.x), Round(self.y), Round(self.w), Round(self.h)

  If IsNil(alpha) Then alpha = #NONE
  If IsNil(angle) Then angle = 0

  If alpha <> #NONE
    Local tmpBrush = CreateBrush(Nil, self.w, self.h)
    GFX.OutputDevice.Select(#BRUSH, tmpBrush, #SELMODE_COMBO, 2)
      SetFillStyle(#FILLGRADIENT, #LINEAR, col1, col2, angle)
      Box(0, 0, self.w, self.h)
    GFX.OutputDevice.EndSelect()

    If alpha < 0
      alpha = 0
    ElseIf alpha > 255
      alpha = 255
    EndIf

    GFX.OutputDevice.Select(#ALPHACHANNEL, tmpBrush, #BRUSH)
      SetAlphaIntensity(alpha)
      Cls()
    GFX.OutputDevice.EndSelect()

    DisplayBrush(tmpBrush, self.x, self.y)
    FreeBrush(tmpBrush)

  Else
    SetFillStyle(#FILLGRADIENT, #LINEAR, col1, col2, angle)
    Box(self.x, self.y, self.w, self.h)
  EndIf

  Return(True)

EndFunction

Function G2D.Area:SkinShades(colList, angle)
/*------------------------------------------
result = G2D.Area:SkinShades(colList, angle)

This method is able to skin the area object using a parametric gradient
you have to provide with the table 'colList' where the color shades are
defined.
You can also rotate the color gradient but remember that only multiple of
90 degrees will be correctly rendered at this time.

INPUT
  colList : [TBL] Color table used to define the shades with thisg format:
            collist = { { step_1 }, { step_2 }, { step_2 }, ... }
            Where:
              step_n = { Color = RRGGBBC, Weight = n, Alpha = n }
            Color  : [NUM] Is a color in RRGGBB notation.
            Weight : [NUM] The last item must have Weight = 0, and the sum
                     of all entries must be 100. This parameter is used to
                     define the color bands width, infact the Weight of the
                     first item, for example, defines the width of the shade
                     composed by the first and the second color entries.
            Alpha  : [NUM] Is a value between 0 and 255 and will be faded
                     along the colors during the gradient creation.
  angle   : [NUM] Rotation angle of the gradient. Actually only multiple of 90
                 degrees will be rendered correctly.

OUTPUT
  result : [BLN] Returns TRUE if the operation has been completed without errors.
----------------------------*/
  ;+--------------------------------------------------------------------------+
  ;| *** FIXME : QUESTO METODO DI CREAZIONE NON SUPPORTA GLI ANGOLI NON x90 E |
  ;| ***         SGRANA LE ROTAZIONI 90 E 270.                                |
  ;+--------------------------------------------------------------------------+
  Local tmpBrush = CreateBrush(Nil, self.w, self.h)
  Local LxW = (self.h)/100
  Local bands = TB.Count(collist) - 1
  Local y = 0


  GFX.OutputDevice.Select(#BRUSH, tmpBrush, #SELMODE_COMBO, 2)
    For Local i = 0 To bands - 1
      ; Number of lines for this band
      Local cline = Round(LxW * collist[i].Weight)
      Local r_step = (Red(collist[i+1].Color) - Red(collist[i].Color))/cline
      Local g_step = (Green(collist[i+1].Color) - Green(collist[i].Color))/cline
      Local b_step = (Blue(collist[i+1].Color) - Blue(collist[i].Color))/cline
      Local a_step = (collist[i+1].Alpha - collist[i].Alpha)/cline
      Local c_color = { collist[i].Alpha, Red(collist[i].Color), Green(collist[i].Color), Blue(collist[i].Color)}
      For Local k = y To y + cline
        Local colrgb = RGB(c_color[1], c_color[2], c_color[3])
        Local colargb = ARGB(255 - c_color[0], colrgb)
        Line(0, k, self.w, k, colrgb)

        GFX.OutputDevice.Select(#ALPHACHANNEL, tmpBrush, #BRUSH)
          SetAlphaIntensity(255 - c_color[0])
          Line(0, k, self.w, k, #BLACK)
        GFX.OutputDevice.EndSelect()

        c_color[0] = c_color[0] + a_step
        c_color[1] = c_color[1] + r_step
        c_color[2] = c_color[2] + g_step
        c_color[3] = c_color[3] + b_step
      Next
      y = y + cline + 1
    Next
  GFX.OutputDevice.EndSelect()

  If angle <> 0
    RotateBrush(tmpBrush, angle, 1, 1, GFX.SmoothZoom)
    DisplayBrush(tmpBrush, self.x, self.y, { width = self.w, height = self.h })
    FreeBrush(tmpBrush)
  Else
    DisplayBrush(tmpBrush, self.x, self.y)
    FreeBrush(tmpBrush)
  EndIf

  Return(True)

EndFunction

Function G2D.Area:SkinVPattern(brush, offset, alpha)
/*--------------------------------------------------
result = G2D.Area:SkinVPattern(brush, offset, alpha)

This method is used to skin the area object using 'brush', the brush will be
first stretched to cover the area width and then the area will be filled with the
stretched brush vertically.
You can control transparency with 'alpha' to override the brush alpha channel,
if defined.

INPUT
  brush  : [ID|STR] The brush to use to skin the area. It can be a brush
           id or a filename, in the last case the brush will be loaded, used
           and finally removed from memory.
  offset : [TBL] This table is used to shift the brush horizontally, vertically
           or in both directions. It must have the following fields:
    x : [NUM] Horizontal shift in pixels
    y : [NUM] Vertical shift in pixels
  alpha  : [NUM] With this parameter you can override the brush's alpha channel,
           if defined, with a custom transparency value. Set this parameter
           to #NONE to leave untouched the brush's alpha channel.

OUTPUT
  result : [BLN] Returns TRUE if the operation has been completed without errors.
----------------------------*/
  ; Round the self coordinates and dimentions
  Local x, y, w, h = Round(self.x), Round(self.y), Round(self.w), Round(self.h)
  Local brush_id = -1
  Local BrushHasBeenLoaded = False
  Local TempBrushCreated   = False

  ; Check the brush parameter
  If GetType(brush) = #STRING
    If Exists(brush)
      Local r, s = IsPicture(brush)
      If r
        brush_id = LoadBrush(Nil, brush, { LoadAlpha = s.alpha })
        BrushHasBeenLoaded = True
      Else
        Return(False)
      EndIf
    Else
      Return(False)
    EndIf
  Else
    brush_id = brush
  EndIf

  Local tmpBrush = -1
  If GetType(brush) <> #STRING
    tmpBrush = CopyBrush(brush_id, Nil)
    TempBrushCreated = True
  Else
    tmpBrush = brush_id
  EndIf

  ; Check the alpha parameter
  If alpha <> #NONE
    GFX.OutputDevice.Select(#ALPHACHANNEL, tmpBrush)
      SetAlphaIntensity(alpha)
      Cls()
    GFX.OutputDevice.EndSelect()
  EndIf

  ; Stretch & render the brush
  ScaleBrush(tmpBrush, self.w, GetAttribute(#BRUSH, tmpBrush, #ATTRHEIGHT), GFX.SmoothZoom)
  self:skinPattern(tmpBrush, offset, alpha)

  ; Free the resources
  If TempBrushCreated Then FreeBrush(tmpBrush)
  If BrushHasBeenLoaded Then FreeBrush(Brush_id)

  Return(True)

EndFunction

Function G2D.Area:SkinHPattern(brush, offset, alpha)
/*--------------------------------------------------
result = G2D.Area:SkinHPattern(brush, offset, alpha)

This method is used to skin the area object using 'brush'. The brush will be
first stretched to cover the area height and then the area will be filled
with the stretched brush.
You can control transparency with 'alpha' overriding the brush alpha channel,
if defined.

INPUT
  brush  : [ID|STR] The brush to use to skin the area. It can be a brush
           id or a filename, in the last case the brush will be loaded, used
           and finally removed from memory.
  offset : [TBL] This table is used to shift the brush horizontally, vertically
           or in both directions. It must have the following fields:
    x : [NUM] Horizontal shift in pixels
    y : [NUM] Vertical shift in pixels
  alpha  : [NUM] With this parameter you can override the brush's alpha channel,
           if defined, with a custom transparency value. Set this parameter
           to #NONE to leave untouched the brush's alpha channel.

OUTPUT
  result : [BLN] Returns TRUE if the operation has been completed without errors.
----------------------------*/
  ; Round the area coordinates and dimentions
  Local x, y, w, h = Round(self.x), Round(self.y), Round(self.w), Round(self.h)
  Local brush_id = -1
  Local BrushHasBeenLoaded = False
  Local TempBrushCreated   = False

  ; Check the brush parameter
  If GetType(brush) = #STRING
    If Exists(brush)
      Local r, s = IsPicture(brush)
      If r
        brush_id = LoadBrush(Nil, brush, { LoadAlpha = s.alpha })
        BrushHasBeenLoaded = True
      Else
        Return(False)
      EndIf
    Else
      Return(False)
    EndIf
  Else
    brush_id = brush
  EndIf

  Local tmpBrush = -1
  If GetType(brush) <> #STRING
    tmpBrush = CopyBrush(brush_id, Nil)
    TempBrushCreated = True
  Else
    tmpBrush = brush_id
  EndIf

  ; Check the alpha parameter
  If alpha <> #NONE
    GFX.OutputDevice.Select(#ALPHACHANNEL, tmpBrush)
      SetAlphaIntensity(alpha)
      Cls()
    GFX.OutputDevice.EndSelect()
  EndIf

  ; Stretch & render the brush
  ScaleBrush(tmpBrush, GetAttribute(#BRUSH, tmpBrush, #ATTRWIDTH), self.h, GFX.SmoothZoom)
  self:skinPattern(tmpBrush, offset, alpha)

  ; Free the resources
  If TempBrushCreated Then FreeBrush(tmpBrush)
  If BrushHasBeenLoaded Then FreeBrush(Brush_id)

  Return(True)

EndFunction

Function G2D.Area:SkinVPattern3S(brush, sectors, alpha, vadapt)
/*-------------------------------------------------------------
result = G2D.Area:SkinVPattern3S(brush, sectors, alpha, vadapt)

This method is used to skin the area object using 'brush'. 
The brush should be a vertical strip subdivided into three sectors defined
using the 'sectors' table.
The top side and bottom side are fixed sized while the middle part will be used
to fill the area height repeating the middle part, or, if 'vadapt' is set to
TRUE, the middle part will be stretched.
You can control transparency with 'alpha' to override the brush alpha channel,
if defined.

INPUT
  brush   : [ID|STR] The brush to use to skin the area. It can be a brush
            id or a filename, in the last case the brush will be loaded, used
            and finally removed from memory.
  sectors : [TBL] It's a table describing the three brush's areas as following:
    top : [TBL] Top sector's description:
      start : [NUM] Sector's vertical position start
      size  : [NUM] Sector's height
    middle : [TBL] Middle sector's description:
      start : [NUM] Sector's vertical position start
      size  : [NUM] Sector's height
    bottom : [NUM] Bottom sector's description:
      start : [NUM] Sector's vertical position start
      size  : [NUM] Sector's height
  alpha   : [NUM] With this parameter you can override the brush's alpha channel,
            if defined, with a custom transparency value. Set this parameter
            to #NONE to leave untouched the brush's alpha channel.
  vadapt  : [BLN] If set to TRUE, the midlle part will be stretched instead of
            being used as a fill pattern.

OUTPUT
  result : [BLN] Returns TRUE if the operation has been completed without errors.
----------------------------*/
  ; Round the self coordinates and dimentions
  Local x, y, w, h = Round(self.x), Round(self.y), Round(self.w), Round(self.h)
  Local brush_id = -1
  Local BrushHasBeenLoaded = False
  Local TempBrushCreated   = False
  Local sectors = CopyTable(sectors)

  ; Check the brush parameter
  If GetType(brush) = #STRING
    If Exists(brush)
      Local r, s = IsPicture(brush)
      If r
        brush_id = LoadBrush(Nil, brush, { LoadAlpha = s.alpha })
        BrushHasBeenLoaded = True
      Else
        Return(False)
      EndIf
    Else
      Return(False)
    EndIf
  Else
    brush_id = brush
  EndIf

  Local tmpBrush = -1
  If GetType(brush) <> #STRING
    tmpBrush = CopyBrush(brush_id, Nil)
    TempBrushCreated = True
  Else
    tmpBrush = brush_id
  EndIf

  ; Check the alpha parameter
  If alpha <> #NONE
    GFX.OutputDevice.Select(#ALPHACHANNEL, tmpBrush)
      SetAlphaIntensity(alpha)
      Cls()
    GFX.OutputDevice.EndSelect()
  EndIf

  ; Stretch & render the brush
  Local oldWidth = GetAttribute(#BRUSH, tmpBrush, #ATTRWIDTH)
  GFX.ImageFX.Scale(tmpBrush, self.w, 1, False, True, False)

  Local newWidth = GetAttribute(#BRUSH, tmpBrush, #ATTRWIDTH)
  Local factor = newWidth/oldWidth

  sectors.top.start    = Round(sectors.top.start * factor)
  sectors.top.size     = Round(sectors.top.size * factor)
  sectors.middle.start = Round(sectors.middle.start * factor)
  sectors.middle.size  = Round(sectors.middle.size * factor)
  sectors.bottom.start = Round(sectors.bottom.start * factor)
  sectors.bottom.size  = Round(sectors.bottom.size * factor)

  ;::: TOP :::
  DisplayBrushPart(tmpBrush, 0, sectors.top.start, self.x, self.y, self.w, sectors.top.size)

  ;::: MIDDLE :::
  Local middle = G2D.Area:new(self.x, self.y + sectors.top.size, self.w-1, self.h - sectors.top.size - sectors.bottom.size )
  Local mBrush = CopyBrush(tmpBrush, Nil)
  CropBrush(mBrush, 0, sectors.middle.start, self.w, sectors.middle.size)

  If vadapt
    ; stretch fill
    middle:skinStretch(mBrush, { x = 0, y = 0 }, alpha, False)
  Else
    ; fill pattern
    middle:skinVPattern(mBrush, { x = 0, y = 0 }, alpha)
  EndIf

  ;::: BOTTOM :::
  DisplayBrushPart(tmpBrush, 0, sectors.bottom.start, self.x, self.y + self.h - sectors.bottom.size, self.w, sectors.bottom.size)

  ; Free the resources
  If TempBrushCreated Then FreeBrush(tmpBrush)
  If BrushHasBeenLoaded Then FreeBrush(Brush_id)
  FreeBrush(mBrush)

  Return(True)

EndFunction

Function G2D.Area:SkinHPattern3S(brush, sectors, alpha, vadapt)
/*-------------------------------------------------------------
result = G2D.Area:SkinHPattern3S(brush, sectors, alpha, vadapt)

This method is used to skin the area object using 'brush'. 
The brush should be an horizontal strip subdivided in three sectors,
described by the 'sectors' table).
The left side and right sides are fixed sized while the middle part will
be used to fill the area width repeating the middle part, or, if 'vadapt'
is set to TRUE, the middle part will be stretched.
You can control transparency with 'alpha' overriding the brush alpha channel,
if defined.

INPUT
  brush   : [ID|STR] The brush to use to skin the area. It can be a brush
            id or a filename, in the last case the brush will be loaded, used
            and finally removed from memory.
  sectors : [TBL] It's a table describing the three brush's areas as following:
    left : [TBL] Left sector's description:
      start : [NUM] Sector's vertical position start
      size  : [NUM] Sector's height
    middle : [TBL] Middle sector's description:
      start : [NUM] Sector's vertical position start
      size  : [NUM] Sector's height
    right : [NUM] Right sector's description:
      start : [NUM] Sector's vertical position start
      size  : [NUM] Sector's height
  alpha   : [NUM] With this parameter you can override the brush's alpha channel,
            if defined, with a custom transparency value. Set this parameter
            to #NONE to leave untouched the brush's alpha channel.
  vadapt  : [BLN] If set to TRUE, the midlle part will be stretched instead of
            being used as a fill pattern.

OUTPUT
  result : [BLN] Returns TRUE if the operation has been completed without errors.
----------------------------*/
  ; Round the self coordinates and dimentions
  Local x, y, w, h = Round(self.x), Round(self.y), Round(self.w), Round(self.h)
  Local brush_id = -1
  Local BrushHasBeenLoaded = False
  Local TempBrushCreated   = False
  Local sectors = CopyTable(sectors)

  ; Check the brush parameter
  If GetType(brush) = #STRING
    If Exists(brush)
      Local r, s = IsPicture(brush)
      If r
        brush_id = LoadBrush(Nil, brush, { LoadAlpha = s.alpha })
        BrushHasBeenLoaded = True
      Else
        Return(False)
      EndIf
    Else
      Return(False)
    EndIf
  Else
    brush_id = brush
  EndIf

  Local tmpBrush = -1
  If GetType(brush) <> #STRING
    tmpBrush = CopyBrush(brush_id, Nil)
    TempBrushCreated = True
  Else
    tmpBrush = brush_id
  EndIf

  ; Check the alpha parameter
  If alpha <> #NONE
    GFX.OutputDevice.Select(#ALPHACHANNEL, tmpBrush)
      SetAlphaIntensity(alpha)
      Cls()
    GFX.OutputDevice.EndSelect()
  EndIf

  ; Stretch & render the brush
  Local oldHeight = GetAttribute(#BRUSH, tmpBrush, #ATTRWIDTH)
  GFX.ImageFX.Scale(tmpBrush, 1, self.h, False, True, False)

  Local newHeight = GetAttribute(#BRUSH, tmpBrush, #ATTRWIDTH)
  Local factor = newHeight/oldHeight
  
  sectors.left.start    = Round(sectors.left.start * factor+0.5)
  sectors.left.size     = Round(sectors.left.size * factor+0.5)
  sectors.middle.start = Round(sectors.middle.start * factor+0.5)
  sectors.middle.size  = Round(sectors.middle.size * factor+0.5)
  sectors.right.start = Round(sectors.right.start * factor+0.5)
  sectors.right.size  = Round(sectors.right.size * factor+0.5)

  ;::: LEFT :::
  DisplayBrushPart(tmpBrush, sectors.left.start, 0, self.x, self.y, sectors.left.size, self.h)

  ;::: MIDDLE :::
  Local middle = G2D.Area:new(self.x + sectors.left.size, self.y, self.w - sectors.left.size - sectors.right.size, self.h)
  Local mBrush = CopyBrush(tmpBrush, Nil)
  CropBrush(mBrush, sectors.middle.start, 0, sectors.middle.size, self.w)

  If vadapt
    ; stretch fill
    middle:skinStretch(mBrush, { x = 0, y = 0 }, alpha, 0)
  Else
    ; fill pattern
    middle:skinHPattern(mBrush, { x = 0, y = 0 }, alpha)
  EndIf

  ;::: RIGHT :::
  If sectors.right.start < GetAttribute(#BRUSH, tmpBrush, #ATTRWIDTH) + sectors.right.size
    sectors.right.start =  GetAttribute(#BRUSH, tmpBrush, #ATTRWIDTH) - sectors.right.size
  EndIf
  If sectors.right.start < 0 Then sectors.right.start = 0
  DisplayBrushPart(tmpBrush, sectors.right.start, 0, self.x + self.w - sectors.right.size, self.y, sectors.right.size, self.h)

  ; Free the resources
  If TempBrushCreated Then FreeBrush(tmpBrush)
  If BrushHasBeenLoaded Then FreeBrush(Brush_id)
  FreeBrush(mBrush)

  Return(True)

EndFunction

Function G2D.Area:SkinPattern9S(brush, sectors, alpha, vadapt)
/*------------------------------------------------------------
result = G2D.Area:SkinPattern9S(brush, sectors, alpha, vadapt)

This method is used to skin the area object using the specified brush'brush'.
This method needs a brush subdivided in 9 sectors that will be described
using the 'sectors' table.

INPUT
  brush   : [ID|STR] The brush to use to skin the area. It can be a brush
            id or a filename, in the last case the brush will be loaded, used
            and finally removed from memory.
  sectors : [TBL] It's a table describing the three brush's areas as following:
    top : [TBL] Top sector's description:
      start : [NUM] Sector's vertical position start
      size  : [NUM] Sector's height
    vmiddle : [TBL] Vertical/Middle sector's description:
      start : [NUM] Sector's vertical position start
      size  : [NUM] Sector's height
    bottom : [NUM] Bottom sector's description:
      start : [NUM] Sector's vertical position start
      size  : [NUM] Sector's height
    left : [TBL] Left sector's description:
      start : [NUM] Sector's vertical position start
      size  : [NUM] Sector's height
    hmiddle : [TBL] Horizontal/Middle sector's description:
      start : [NUM] Sector's vertical position start
      size  : [NUM] Sector's height
    right : [NUM] Right sector's description:
      start : [NUM] Sector's vertical position start
      size  : [NUM] Sector's heighth      
  alpha   : [NUM] With this parameter you can override the brush's alpha channel,
            if defined, with a custom transparency value. Set this parameter
            to #NONE to leave untouched the brush's alpha channel.
  vadapt  : [BLN] If set to TRUE, the midlle part will be stretched instead of
            being used as a fill pattern.

OUTPUT
  result : [BLN] Returns TRUE if the operation has been completed without errors.
----------------------------*/
  ; Round the area coordinates and dimentions
  Local x, y, w, h = Round(self.x), Round(self.y), Round(self.w), Round(self.h)
  Local brush_id = -1
  Local BrushHasBeenLoaded = False
  Local TempBrushCreated = False

  ; Check the brush parameter
  If GetType(brush) = #STRING
    If Exists(brush)
      Local r, s = IsPicture(brush)
      If r
        brush_id = LoadBrush(Nil, brush, { LoadAlpha = s.alpha })
        BrushHasBeenLoaded = True
      Else
        Return(False)
      EndIf
    Else
      Return(False)
    EndIf
  Else
    brush_id = brush
  EndIf

  Local tmpBrush = -1
  If GetType(brush) <> #STRING
    tmpBrush = CopyBrush(brush_id, Nil)
    TempBrushCreated = True
  Else
    tmpBrush = brush_id
  EndIf

  ; Check the alpha parameter
  If alpha <> #NONE
    GFX.OutputDevice.Select(#ALPHACHANNEL, tmpBrush)
      SetAlphaIntensity(alpha)
      Cls()
    GFX.OutputDevice.EndSelect()
  EndIf

  ;::: TOP :::
  Local tsectors = { left   = { start = sectors.left.start,    size = sectors.left.size },
                     middle = { start = sectors.hmiddle.start, size = sectors.hmiddle.size },
                     right  = { start = sectors.right.start,   size = sectors.right.size } }
  Local tarea    = G2D.Area:new(self.x, self.y, self.w, sectors.top.size)
  Local tmp2     = CopyBrush(tmpBrush, Nil)
  CropBrush(tmp2, sectors.left.start, sectors.top.start, GetAttribute(#BRUSH, tmpBrush, #ATTRWIDTH), sectors.top.size)
  tarea:skinHPattern3S(tmp2, tsectors, alpha, vadapt)
  FreeBrush(tmp2)

  ;::: LEFT :::
  Local tarea    = G2D.Area:new(self.x, self.y + sectors.top.size, sectors.left.size, self.h - sectors.top.size - sectors.bottom.size)
  Local tmp2     = CopyBrush(tmpBrush, Nil)
  If sectors.vmiddle.start + sectors.vmiddle.size > GetAttribute(#BRUSH, tmp2, #ATTRHEIGHT)
    sectors.vmiddle.start = GetAttribute(#BRUSH, tmp2, #ATTRHEIGHT) - sectors.vmiddle.size
  EndIf
  If sectors.vmiddle.start < 0 Then sectors.vmiddle.start = 0
  CropBrush(tmp2, sectors.left.start, sectors.vmiddle.start, sectors.left.size, sectors.vmiddle.size)
  If vadapt
    tarea:skinStretch(tmp2, { x = 0, y = 0 }, alpha, 0)
  Else
    tarea:skinVPattern(tmp2, { x = 0, y = 0 }, alpha)
  EndIf
  FreeBrush(tmp2)

  ;::: RIGHT :::
  Local tarea    = G2D.Area:new(self.x + self.w - sectors.right.size, self.y + sectors.top.size, sectors.right.size, self.h - sectors.top.size - sectors.bottom.size)
  Local tmp2     = CopyBrush(tmpBrush, Nil)
  If sectors.right.start + sectors.right.size > GetAttribute(#BRUSH, tmp2, #ATTRWIDTH)
    sectors.right.start = GetAttribute(#BRUSH, tmp2, #ATTRWIDTH) - sectors.right.size
  EndIf
  If sectors.right.start < 0 Then sectors.right.start = 0
  CropBrush(tmp2, sectors.right.start, sectors.vmiddle.start, sectors.right.size, sectors.vmiddle.size)
  If vadapt
    tarea:skinStretch(tmp2, { x = 0, y = 0 }, alpha, 0)
  Else
    tarea:skinVPattern(tmp2, { x = 0, y = 0 }, alpha)
  EndIf
  FreeBrush(tmp2)

  ;::: BOTTOM :::
  Local tsectors = { left   = { start = sectors.left.start,    size = sectors.left.size },
                     middle = { start = sectors.hmiddle.start, size = sectors.hmiddle.size },
                     right  = { start = sectors.right.start,   size = sectors.right.size } }
  Local tarea    = G2D.Area:new(self.x, self.y + self.h - sectors.bottom.size, self.w, sectors.bottom.size)
  Local tmp2     = CopyBrush(tmpBrush, Nil)
  If sectors.bottom.start + sectors.bottom.size > GetAttribute(#BRUSH, tmp2, #ATTRHEIGHT)
    sectors.bottom.start = GetAttribute(#BRUSH, tmp2, #ATTRHEIGHT) - sectors.bottom.size
  EndIf
  If sectors.bottom.start < 0 Then sectors.bottom.start = 0
  CropBrush(tmp2, sectors.left.start, sectors.bottom.start, GetAttribute(#BRUSH, tmpBrush, #ATTRWIDTH), sectors.bottom.size)
  tarea:skinHPattern3S(tmp2, tsectors, alpha, vadapt)
  FreeBrush(tmp2)

  ;::: MIDDLE AREA :::
  ; 18/07/2019 : Ho modificato l'area rimuovendo i margini -1 sulle coord e +2 sulle dimensioni
  ;              perch causavano glitch nel rendering.
  ; 12/08/2020 : Rimesso perch c'erano altri glitch -_-'
  Local tarea    = G2D.Area:new(self.x + sectors.left.size-1, self.y + sectors.top.size-1, self.w - sectors.left.size - sectors.right.size+2, self.h - sectors.top.size - sectors.bottom.size+2)
  Local tmp2     = CopyBrush(tmpBrush, Nil)
  CropBrush(tmp2, sectors.hmiddle.start, sectors.vmiddle.start, sectors.hmiddle.size, sectors.vmiddle.size)
  If vadapt
    tarea:skinStretch(tmp2, { x = 0, y = 0 }, alpha, 2)
  Else
    tarea:skinPattern(tmp2, { x = 0, y = 0 }, alpha)
  EndIf
  FreeBrush(tmp2)

  If BrushHasBeenLoaded Then FreeBrush(brush_id)
  If TempBrushCreated Then FreeBrush(tmpBrush)

  Return(True)

EndFunction

;-------------------------------------------------------
; The following table is used to handle multiple skin layers
; that are rendered by the :SkinMulti() method.
; ------------------------------------------------------
G2D._skinValidator =
  { [ GFX.SkinType_Stretch ] = 
      Function(skinLayer, t_area)
        If Not(HaveItem(skinLayer.params, "brush"       )) Then Return(False)
        If Not(HaveItem(skinLayer.params, "offset"      )) Then skinLayer.params.offset      = { x = 0, y = 0 }
        If Not(HaveItem(skinLayer.params, "alpha"       )) Then skinLayer.params.alpha       = #NONE
        If Not(HaveItem(skinLayer.params, "stretch_fix" )) Then skinLayer.params.stretch_fix = -999
        
        t_area:skinStretch(
          skinLayer.params.brush,
          skinLayer.params.offset,
          skinLayer.params.alpha,
          skinLayer.params.stretch_fix)
      EndFunction,
    ;--------------------------
    [ GFX.SkinType_Pattern ] =
      Function(skinlayer, t_area)
        Local size
        If Not(HaveItem(skinLayer.params, "brush" )) Then Return(False)
        If Not(HaveItem(skinLayer.params, "offset")) Then skinLayer.params.offset = { x = 0, y = 0 }
        If Not(HaveItem(skinLayer.params, "alpha" )) Then skinLayer.params.alpha  = #NONE
        If Not(HaveItem(skinLayer.params, "size"  )) Then size = skinLayer.params.size

        t_area:skinPattern(
          skinLayer.params.brush,
          skinLayer.params.offset,
          skinLayer.params.alpha,
          size)
      EndFunction,
    ;--------------------------
    [ GFX.SkinType_FitMax ] =
      Function(skinLayer, t_area)
        If Not(HaveItem(skinLayer.params, "brush" )) Then Return(False)
        If Not(HaveItem(skinLayer.params, "offset")) Then skinLayer.params.offset = { x = 0, y = 0 }
        If Not(HaveItem(skinLayer.params, "alpha" )) Then skinLayer.params.alpha  = #NONE
        If Not(HaveItem(skinLayer.params, "align" )) Then skinLayer.params.align  = #CENTER

        t_area:skinFitMax(
          skinLayer.params.brush,
          skinLayer.params.offset,
          skinLayer.params.alpha,
          skinLayer.params.align)
      EndFunction,
    ;--------------------------
    [ GFX.SkinType_FitMin ] =
      Function(skinLayer, t_area)
        If Not(HaveItem(skinLayer.params, "brush" )) Then Return(False)
        If Not(HaveItem(skinLayer.params, "offset")) Then skinLayer.params.offset = { x = 0, y = 0 }
        If Not(HaveItem(skinLayer.params, "alpha" )) Then skinLayer.params.alpha  = #NONE
        If Not(HaveItem(skinLayer.params, "align" )) Then skinLayer.params.align  = #CENTER
        If Not(HaveItem(skinLayer.params, "border")) Then skinLayer.params.border = $FF000000

        t_area:skinFitMin(
          skinLayer.params.brush,
          skinLayer.params.offset,
          skinLayer.params.alpha,
          skinLayer.params.align,
          skinLayer.params.border)
      EndFunction,
    ;--------------------------
    [ GFX.SkinType_Color ] =
      Function(skinLayer, t_area)
        If Not(HaveItem(skinLayer.params, "color")) Then Return(False)
        If Not(HaveItem(skinLayer.params, "alpha")) Then skinLayer.params.alpha = #NONE

        t_area:skinColor(
          skinLayer.params.color,
          skinLayer.params.alpha)
      EndFunction,
    ;--------------------------
    [ GFX.SkinType_Bevel ] =
      Function(skinLayer, t_area)
        If Not(HaveItem(skinLayer.params, "colors")) Then skinLayer.params.colors = { light = $EEEEEE, dark = $444444 }
        If Not(HaveItem(skinLayer.params, "aspect")) Then skinLayer.params.aspect = { fx = GFX.BevelFx_Raised, height = 1 }
        If Not(HaveItem(skinLayer.params, "type"  )) Then skinLayer.params.type   = GFX.BevelType_Standard

        t_area:skinBevel(
          skinLayer.params.colors,
          skinLayer.params.aspect,
          skinLayer.params.type)
      EndFunction,
    ;--------------------------
    [ GFX.SkinType_Gradient ] =
      Function(skinLayer, t_area)
        If Not(HaveItem(skinLayer.params, "color1")) Then Return(False)
        If Not(HaveItem(skinLayer.params, "color2")) Then Return(False)
        If Not(HaveItem(skinLayer.params, "alpha" )) Then skinLayer.params.alpha = #NONE
        If Not(HaveItem(skinLayer.params, "angle" )) Then skinLayer.params.angle = 0

        t_area:skinGradient(
          skinLayer.params.color1,
          skinLayer.params.color2,
          skinLayer.params.alpha,
          skinLayer.params.angle)
      EndFunction,
    ;--------------------------
    [ GFX.SkinType_Shades ] =
      Function(skinLayer, t_area)
        If Not(HaveItem(skinLayer.params, "colorlist")) Then Return(False)
        If Not(HaveItem(skinLayer.params, "angle"    )) Then skinLayer.params.angle = 0

        t_area:skinShades(
          skinLayer.params.ColorList,
          skinLayer.params.angle)
      EndFunction,
    ;--------------------------
    [ GFX.SkinType_VPattern ] =
      Function(skinLayer, t_area)
        If Not(HaveItem(skinLayer.params, "brush" )) Then Return(False)
        If Not(HaveItem(skinLayer.params, "offset")) Then skinLayer.params.offset = { x = 0, y = 0 }
        If Not(HaveItem(skinLayer.params, "alpha" )) Then skinLayer.params.alpha  = #NONE

        t_area:skinVPattern(
          skinLayer.params.Brush,
          skinLayer.params.offset,
          skinLayer.params.alpha)
      EndFunction,
    ;--------------------------
    [ GFX.SkinType_HPattern ] =
      Function(skinLayer, t_area)
        If Not(HaveItem(skinLayer.params, "brush" )) Then Return(False)
        If Not(HaveItem(skinLayer.params, "offset")) Then skinLayer.params.offset = { x = 0, y = 0 }
        If Not(HaveItem(skinLayer.params, "alpha" )) Then skinLayer.params.alpha  = #NONE

        t_area:skinHPattern(
          skinLayer.params.Brush,
          skinLayer.params.offset,
          skinLayer.params.alpha)
      EndFunction,
    ;--------------------------
    [ GFX.SkinType_VPattern3S ] =
      Function(skinLayer, t_area)
        If Not(HaveItem(skinLayer.params, "brush"  )) Then Return(False)
        If Not(HaveItem(skinLayer.params, "sectors")) Then Return(False)
        If Not(HaveItem(skinLayer.params, "alpha"  )) Then skinLayer.params.alpha  = #NONE
        If Not(HaveItem(skinLayer.params, "vadapt" )) Then skinLayer.params.vadapt = False

        t_area:skinVPattern3S(
          skinLayer.params.Brush,
          skinLayer.params.sectors,
          skinLayer.params.alpha,
          skinLayer.params.vadapt)
      EndFunction,
    ;--------------------------
    [ GFX.SkinType_HPattern3S ] =
      Function(skinLayer, t_area)
        If Not(HaveItem(skinLayer.params, "brush"  )) Then Return(False)
        If Not(HaveItem(skinLayer.params, "sectors")) Then Return(False)
        If Not(HaveItem(skinLayer.params, "alpha"  )) Then skinLayer.params.alpha  = #NONE
        If Not(HaveItem(skinLayer.params, "vadapt" )) Then skinLayer.params.vadapt = False

        t_area:skinHPattern3S(
          skinLayer.params.Brush,
          skinLayer.params.sectors,
          skinLayer.params.alpha,
          skinLayer.params.vadapt)
      EndFunction,
    ;--------------------------
    [ GFX.SkinType_Pattern9S ] =
      Function(skinLayer, t_area)
        If Not(HaveItem(skinLayer.params, "brush"  )) Then Return(False)
        If Not(HaveItem(skinLayer.params, "sectors")) Then Return(False)
        If Not(HaveItem(skinLayer.params, "alpha"  )) Then skinLayer.params.alpha  = #NONE
        If Not(HaveItem(skinLayer.params, "vadapt" )) Then skinLayer.params.vadapt = False

        t_area:skinPattern9S(
          skinLayer.params.Brush,
          skinLayer.params.sectors,
          skinLayer.params.alpha,
          skinLayer.params.vadapt)
      EndFunction
    }


Function G2D.Area:SkinMulti(levels, offset)
/*-----------------------------------------
result = G2D.Area:SkinMulti(levels, offset)

This method is used to skin the area object using one or more skin layers
defined in the 'levels' table.
With this method you can apply multiple skin layers to an area object.

INPUT
  levels : [TBL] Table describing each skin layer to apply to the area, each
           entry must have the following fields:
             area : [TBL] This table represent a sub-area to adjust the level's
                    position and size, values specified here will be added to
                    the corresponding areaObj fields we have to skin.
                    This parameter is optional. If specified, the table, must
                    have the fields : x, y, w, h
             type : [NUM] This field is used to specify what skin mode must
                    be used for this layer, it can be one of the following:
                      GFX.SkinType_Stretch
                      GFX.SkinType_Pattern
                      GFX.SkinType_FitMax
                      GFX.SkinType_FitMin
                      GFX.SkinType_Color
                      GFX.SkinType_Gradient
                      GFX.SkinType_Shades         
                      GFX.SkinType_VPattern
                      GFX.SkinType_HPattern
                      GFX.SkinType_VPattern3S
                      GFX.SkinType_HPattern3S
                      GFX.SkinType_Pattern9S
                      GFX.SkinType_Bevel
             params : [TBL] This is a table with further values needed by each
                      skin mode, below, for each skin type, will be listed all
                      the fields that must be provided in this table:
                       
                       ** GFX.SkinType_Stretch **
                       brush : Brush id or brush filename
                       offset : Skin offset, must have:
                         x : Offset X
                         y : Offset Y
                         alpha : Transparency or #NONE
                        stretch_fix : See notes at the top of this module

                       ** GFX.SkinType_Pattern **
                       brush : Brush id or brush filename
                       offset : Skin offset, must have:
                         x : Offset X
                         y : Offset Y
                       alpha : Transparency or #NONE or any positive value to override
                               brush's alpha channel.
                       size : Optional size of the single tile, is specified, must have:
                         w : Horizontal size
                         h : Vertical size

                       ** GFX.SkinType_FitMax **
                       brush : Brush id or brush filename
                       offset : Skin offset, must have:
                         x : Offset X
                         y : Offset Y
                       alpha : Transparency or #NONE or any positive value to override
                               brush's alpha channel.
                       align : Horizontal skin alignment, can be #LEFT, #CENTER, #RIGHT

                       ** GFX.SkinType_FitMin **
                       brush : Brush id or brush filename
                       offset : Skin offset, must have:
                         x : Offset X
                         y : Offset Y
                       alpha : Transparency or #NONE or any positive value to override
                               brush's alpha channel.
                       align : Horizontal skin alignment, can be #LEFT, #CENTER, #RIGHT
                       border : Borders color

                       ** GFX.SkinType_Color **
                       color : Solid color to use
                       alpha : Transparency or #NONE or any positive value.

                       ** GFX.SkinType_Gradient **
                       color1 : Gradient's starting color
                       color2 : Gradient's ending color
                       alpha : Transparency or #NONE or any positive value.
                       angle : Gradient's angle

                       ** GFX.SkinType_Shades ***
                       ColorList : Table used to define the shades, each entry
                                   must have the following fields:
                                     Color : Color in RRGGBB notation
                                     Weight : Band ColorN <-> ColorN+1                                                  weight
                                     Alpha : Color transparency level
                       angle : Shades's angle. Actually only 0, 90, 180, 270, ... 
                               are rendered correctly.
  
                       ** GFX.SkinType_VPattern **
                       brush : Brush id or brush filename
                       offset : Skin offset, must have:
                         x : Offset X
                         y : Offset Y
                       alpha : Transparency or #NONE or any positive value to override
                               brush's alpha channel.

                       ** GFX.SkinType_HPattern **
                       brush : Brush id or brush filename
                       offset : Skin offset, must have:
                         x : Offset X
                         y : Offset Y
                       alpha : Transparency or #NONE or any positive value to override
                               brush's alpha channel.

                       ** GFX.SkinType_VPattern3S **
                       brush : Brush id or brush filename            
                       sectors : Table describing skin sectors:        
                         top : Top sector                           
                           start : Starting y coordinate           
                           height   sector's height                 
                         middle : Middle sector                        
                           start : Starting y coordinate           
                           height : sector's height                 
                         bottom : Bottom sector                        
                           start : Starting y coordinate           
                           height : sector's height                 
                       alpha : Transparency or #NONE or any positive value to override
                               brush's alpha channel.            
                       vadapt : Adapt the brush size vertically       

                       ** GFX.SkinType_HPattern3S **
                       brush : Brush id or brush filename            
                       sectors : Table describing skin sectors:        
                         left : Left sector                           
                           start : Starting y coordinate           
                           height   sector's height                 
                         middle : Middle sector                        
                           start : Starting y coordinate           
                           height : sector's height                 
                         right : Right sector                        
                           start : Starting y coordinate           
                           height : sector's height                 
                       alpha : Transparency or #NONE or any positive value to override
                               brush's alpha channel.            
                       vadapt : Adapt the brush size horizontally       

                       ** GFX.SkinType_Pattern9S **
                       brush : Brush id or brush filename            
                       sectors : Table describing skin sectors:        
                         left : Left sector                           
                           start : Starting y coordinate           
                           height   sector's height                 
                         hmiddle : Horizontal/Middle sector                        
                           start : Starting y coordinate           
                           height : sector's height                 
                         right : Right sector                        
                           start : Starting y coordinate           
                           height : sector's height                 
                         top : Top sector                           
                           start : Starting y coordinate           
                           height   sector's height                 
                         vmiddle : Vertical/Middle sector                        
                           start : Starting y coordinate           
                           height : sector's height                 
                         bottom : Bottom sector                        
                           start : Starting y coordinate           
                           height : sector's height                 
                       alpha : Transparency or #NONE or any positive value to override
                               brush's alpha channel.            
                       vadapt : Adapt the brush size

                       ** GFX.SkinType_Bevel **
                       colors : Colors table                          
                         Light : Light color                          
                         Dark : Dark color                           
                         Middle : Middle color (NIL for empty bevels)  
                       aspect : Further aspect options                
                         fx : Can be one of the following: GFX.BevelFx_Raised. GFX.BevelFx_Recessed, GFX.BevelFx_Flat
                         height : Border's height                      
                         type : Bevel type, one of the following: GFX.BevelType_Standard, GFX.BevelType_Sunken
  offset : [TBL] Optional table with the global skin offset for all layers
           that needs it. It must hold the fields 'x' and 'y'.

OUTPUT
  result : [BLN] Returns TRUE if the operation has been completed without errors.
----------------------------*/
  ; Main skinning loop
  Local lcount, i = ListItems(levels) - 1
  For i = 0 To lcount
    ; Check <area> table and make a new area object for the current layer
    If Not(HaveItem(levels[i], "area"))
      levels[i].area = { x = 0, y = 0, w = 0, h = 0 }
    EndIf
    
    If IsNil(offset)
      offset = { x = 0, y = 0 }
      
    Else
      If Not(HaveItem(offset, "x")) Then offset.x = 0
      If Not(HaveItem(offset, "y")) Then offset.y = 0
      
    EndIf

    Local t_area = G2D.Area:new(self.x + levels[i].area.x + offset.x, self.y + levels[i].area.y + offset.y,
                                self.w + levels[i].area.w, self.h + levels[i].area.h )


    ; NEW IMPLEMENTATION (20.03.2023)
    G2D._skinValidator[levels[i].type](levels[i], t_area)
    
  Next
  
  Return(True)

EndFunction

Function G2D.Area:Snapshot(BGPic)
/*-------------------------------
brush = G2D.Area:snapshot(BGPic)

This method returns a brush with the content 'seen' by the object area.
'BGPic' is the currently active background picture, if you don't specify it
BGPic 1 will be selected.

INPUT
  BGPic : [ID] Optional BGPic, default = 1
  
OUTPUT
  brush : [ID] Brush id of the captured area
----------------------------*/
  If IsNil(BGPic) Then BGPic = 1

  Local bg = CreateBrush(Nil, Area.w + 1, Area.h + 1)
  GFX.OutputDevice.Select(#BRUSH, bg, #SELMODE_NORMAL)
    DisplayBGPicPart(BGPic, Area.x, Area.y, Area.w + 1, Area.h + 1, 0, 0, { Layers = True } )
  GFX.OutputDevice.EndSelect()

  Return(bg)

EndFunction

Function G2D.BGPic.CreateSkinned(width, height, skin_struct)
/*----------------------------------------------------------
BGId = G2DBGPic.CreateSkinned(width, height, skin)

Returns a BGPic of the desired sizes ('width' and 'height') skinned with the
the skin layers defined by 'skin'.

INPUT
  width  : [NUM] BGPic width
  height : [NUM] BGPic height
  skin   : [TBL] Multi Skin definition (see skinning functions)
  
OUTPUT
  BGId : [ID] BGPic id
----------------------------*/
  ; Returns the id of the created BG picture
  Local tarea = G2D.Area:new(0, 0, width, height)
  Local tbrush = CreateBrush(Nil, width, height, #BLACK, { AlphaChannel = True, Clear = True })
  GFX.OutputDevice.Select(#BRUSH, tbrush, #SELMODE_COMBO)
    G2D.Area:skinMulti(Skin_Struct.Levels)
  GFX.OutputDevice.EndSelect()
  Local t_file = GetTempFileName()
  SaveBrush(tBrush, t_file, Nil, #IMGFMT_PNG)
  FreeBrush(tBrush)
  Local BGID = LoadBGPic(Nil, t_file, { loadalpha = True })
  DeleteFile(t_file)

  Return(BGID)

EndFunction

   
/* TEST AREA
   =========
   Uncomment the test function you want to run */

 ; G2D.TEST_Poly()
