/* ************************************************************************** */
/* HGui Module                                                                */
/*                                                                            */
/* Documentation : http://docs.a-mc.biz/doku.php?id=hollywoodlibs:hgui:main   */
/*                 No more mantained, instead docs have been improved in the  */
/*                 source code and in the examples.                           */
/* ************************************************************************** */
;:: ABOUT DOCS ::
;:: *TriDoc*     means documentation has been transcribed
;:: *TriDoc* *   means that after transcription the internal docs has been adjusted
;::
;
;:: Finding stuff in the source code:
;::   NEW <gadname> is where the gadget:new() method is implemented
;::   DRAW <gadname> is where the gadget is rendered
;
; *** WARNINGS / BUGS ***
; Text gadget
; - When home/end key is pressed, the cursor become broken
; - When used with password there is an extra character rendered (but not considered)
; Treeview gadget
; - Seems that on the first column resize the rightmost column uncovered does not have
;   an active area of the right dimensions, but smaller.
;   Just move the horizontal scroller to return to the normal behaviour, maybe it
;   just miss a refresh of the header buttons.
;
;:: TODO ::
; Optimizations
; - When refreshing gadgets or windows we could also use BeginRefresh/EndRefresh
;   to reduce flickering at this time this feature is disabled with:
;     HGui.RefreshBlockEnabled = False
;   but you are free to enable it and check how it works, it is active only
;   with gadgetObj:set() method but just this implementation could reduce flickering a lot.
;
; Themes
; - HGui.Themes.SetGlobalTheme() must be completed (last done was treeview)
; - Theme save & load must be implemented (JSON format)
;
; Gadgets
; - Dropdown gadget : it could be nice to have a droplist with relative sizes
;     if column sizes are specified using "%n" strings, this % is relative to
;     the combo button width. This change must be done on listview/treeview
;     gadgets, maybe it's already implemented.
; - Tabs are still missing
;
; Keyboard
; - Keyboard navigation is not yet implemented
;
; Showcase
; - Must be revised, it's a mess to understand
;
; Misc
; - Special tags handling in CText:Render() method it's a bit confusing,
; especially with the 'bbcolor' tag.
;
; ============================================================================

@INCLUDE "+Includes.hws"               ; Where all modules has been defined
@INCLUDE #INC_HELPERS
@INCLUDE #INC_TABLES
@INCLUDE #INC_G2D
@INCLUDE #INC_DEBUG
@INCLUDE #INC_TEXTPROC

Global HGui = {}                       ; Module root table
;--- This global is used by the builder to include all the
;--- needed files in the distribution package
HGui.Dependancies =  
  { #INC_HELPERS,
    #INC_TABLES,
    #INC_EASING,
    #INC_G2D,
    #INC_GFX,
    #INC_DEBUG,
    #INC_ANSI,
    #INC_TEXTPROC,
    "+Includes.hws"
    }
;---------------------------------------------------------
HGui.Areas = {}                           ; Stores all defined areas
HGui.Windows = {}                         ; Stores all defined windows
HGui.WinOrder = {}                        ; Stores windows order
HGui.Gadgets = {}                         ; Stores all defined gadgets
HGui.MenuWindows = {}                     ; Stores all opened menu windows stack
HGui.CTexts = {}                          ; Stores all defined CTexts objects
HGui.Shortcuts = {}                       ; Stores all keyboard shortcuts
HGui.Theme   = {}                         ; Stores the current theme
HGui.Tip = {}                             ; Opened tip windpw
HGui.DropDown = {}                        ; Opened DropDown window
HGui.WindowsHotKeys = {}                  ; Stores Window's actions hot keys
       
HGui.CurrentMachine = GetVersion()        ; Current platform data
HGui.QuitOnLastWindow = True              ; Close the application automatically when the last window is closed
HGui.AutoRendering  = True                ; Automatic Rendering status
HGui.CacheGadtext   = True                ; Cache text gadget with the skin (on or off)
HGui.EventHandling  = True                ; Handle gadget's events or not

HGui.DragKey        = "LSHIFT"            ; Drag key
HGui.Key_MoveFocusFFW = { Qualifier = "",       Key = "TAB" }   ; Move focus to the next gadget combo
HGui.Key_MoveFocusRWD = { Qualifier = "LSHIFT", Key = "TAB" }   ; Move focus to the previous gadget combo
HGui.Key_SetFocus     = { Qualifier = "",       Key = "ENTER" } ; Set focus the the hilighted gadget combo

HGui.ActiveWindow   = Nil                 ; Current active window object
HGui.PushedOut_Gadget = Nil               ; Current Gadget in Pushed-Out state
HGui.ScrollBarDragging = False            ; Says if there is a dragging active on a scrollbar's cursor
HGui.MouseInsideCursor = False            ; Says if the mouse is inside a scrollbar's cursor

HGui.ModalWindow = Nil                    ; Modal window currently active if any

HGui.ActiveText = Nil                     ; Active text object if any
HGui.ActiveGadget = Nil                   ; Active gadget object if any
HGui.MinSBCursorSize = 8                  ; Minimum scrollbar cursor's size
HGui.LVResizeColumnOffset = 4             ; Listview/Treeview: Resize columns offset
HGui.LVResizeColumnMode = False           ; Listview/Treeview: Says if a resize is activated

HGui.RBTracker = {}                       ; Used to track BeginRefresh/EndRefresh activities
HGui.RefreshBlockEnabled = True           ; Enable/Disable BeginRefresh()/EndRefresh()

HGui.ignoreNextWindowAEvents = False
HGui.ignoreNextWindowDEvents = False

; ** TODO **
; NEW CLASS NEEDED : Gallery

; ** TODO **
; THESE ONES ARE THEME-RELATED!! MUST BE PLACED IN THE THEME!!
HGui.LVResizeLineColor1 = $000000         ; Column resize marker color 1
HGui.LVResizeLineColor2 = $FF0000         ; Column resize marker color 2
       
HGui.Version = { 1, 7, "20/03/2023" }     ; Current library version (Maj, Min, build date)
                                                 
; All predefined channels for which you can enable the debug output
HGui.DebugChannel = "HGui"                ; Main debug channel
HGui.WChannel     = "Window"              ; Window handler debug channel
HGui.AreaChannel  = "Area"                ; Area handler debug channel
HGui.CTextChannel = "CText"               ; CText handler debug channel
       
HGui.TextEncoding = #ENCODING_UTF8        ; Default text encoding
       
SetDefaultEncoding(HGui.TextEncoding, HGui.TextEncoding)
TP.Encoding = HGui.TextEncoding

; CONSTANTS
Const #HGUI_AREA = 1                             ; AREA object type
Const #HGUI_BOX_GADGET = 2                       ; BEVELBOX gadget
Const #HGUI_VDIVIDER_GADGET = 3                  ; VERTICAL DIVIDER gadget
Const #HGUI_HDIVIDER_GADGET = 4                  ; HORIZONTAL DIVIDER gadget
Const #HGUI_LABEL_GADGET = 5                     ; LABEL gadget
Const #HGUI_GROUP_GADGET = 6                     ; GROUP gadget (CHECKBOXES / RADIOBUTTONS)
   Const #HGUI_GTYPE_GENERIC = 9
   Const #HGUI_GTYPE_CHECK = 10
   Const #HGUI_GTYPE_RADIO = 11
Const #HGUI_BUTTON_GADGET = 12                   ; BUTTON gadget
Const #HGUI_SWITCH_GADGET = 13                   ; SWITCH gadget
Const #HGUI_SCROLLBAR_GADGET = 14                ; SCROLLBAR gadget
Const #HGUI_PROGRESSBAR_GADGET = 15              ; PROGRESSBAR gadget
Const #HGUI_SLIDER_GADGET = 16                   ; SLIDER gadget
Const #HGUI_KNOB_GADGET = 17                     ; KNOB gadget
Const #HGUI_TEXT_GADGET = 18                     ; TEXT gadget
Const #HGUI_LISTVIEW_GADGET = 19                 ; LISTVIEW GADGET
Const #HGUI_TREEVIEW_GADGET = 20                 ; TREEVIEW GADGET
Const #HGUI_DROPDOWN_GADGET = 21                 ; DROPDOWN Gadget
Const #HGUI_IMAGE_GADGET = 22                    ; IMAGE Gadget
Const #HGUI_VIRTUAL_GADGET = 23                  ; VIRTUAL Gadget
Const #HGUI_CANVAS_GADGET = 24                   ; CANVAS Gadget

Const #HGUI_PREBUILT_GROUP = 99                  ; PREBUILT GROUP used mostly for Menus

HGui.GadgetDescriptions =
  { [#HGUI_BOX_GADGET         ] = "BOX",
    [#HGUI_VDIVIDER_GADGET    ] = "VDIVIDER",
    [#HGUI_HDIVIDER_GADGET    ] = "HDIVIDER",
    [#HGUI_LABEL_GADGET       ] = "LABEL",
    [#HGUI_GROUP_GADGET       ] = "GROUP",
    [#HGUI_BUTTON_GADGET      ] = "BUTTON",
    [#HGUI_SWITCH_GADGET      ] = "SWITCH",
    [#HGUI_SCROLLBAR_GADGET   ] = "SCROLL BAR",
    [#HGUI_PROGRESSBAR_GADGET ] = "PROGRESS BAR",
    [#HGUI_SLIDER_GADGET      ] = "SLIDER",
    [#HGUI_KNOB_GADGET        ] = "KNOB",
    [#HGUI_TEXT_GADGET        ] = "TEXT",
    [#HGUI_LISTVIEW_GADGET    ] = "LISTVIEW",
    [#HGUI_TREEVIEW_GADGET    ] = "TREEVIEW",
    [#HGUI_DROPDOWN_GADGET    ] = "DROP DOWN",
    [#HGUI_IMAGE_GADGET       ] = "IMAGE",
    [#HGUI_VIRTUAL_GADGET     ] = "VIRTUAL",
    [#HGUI_CANVAS_GADGET      ] = "CANVAS",
    [#HGUI_PREBUILT_GROUP     ] = "MENU GROUP"
    }

; Statuses
Const #HGUI_ENABLED  = True                      ; ENABLED gadget
Const #HGUI_DISABLED = False                     ; DISABLED gadget

; Statuses 2
Const #HGUI_NORMAL_STATE    = 1                  ; NORMAL gadget state
Const #HGUI_HILIGHTED_STATE = 2                  ; HILIGHTED gadget state
Const #HGUI_PUSHED_STATE    = 4                  ; PUSHED gadget state
Const #HGUI_DISABLED_STATE  = 8                  ; DISABLED gadget state
Const #HGUI_NPUSHED_STATE   = 16                 ; NORMAL PUSHED
Const #HGUI_HPUSHED_STATE   = 32                 ; HILIGHTED PUSHED
Const #HGUI_DPUSHED_STATE   = 64                 ; DISABLED PUSHED

HGui.StatusDescriptions =
  { [#HGUI_NORMAL_STATE]   = "Normal",
    [#HGUI_HILIGHTED_STATE]= "Hilighted",
    [#HGUI_PUSHED_STATE]   = "Pushed",
    [#HGUI_DISABLED_STATE] = "Disabled",
    [#HGUI_NPUSHED_STATE]  = "Normal/Pushed",
    [#HGUI_HPUSHED_STATE]  = "Hilighted/Pushed",
    [#HGUI_DPUSHED_STATE]  = "Disabled/Pushed"
    }
    
Const #HGUI_VISIBLE = True                       ; VISIBLE gadget
Const #HGUI_HIDDEN  = False                      ; HIDDEN gadget

; Layouts
Const #HGUI_VERTICAL_LAYOUT   = 1
Const #HGUI_HORIZONTAL_LAYOUT = 2
Const #HGUI_GRID_LAYOUT       = 3

; Alignments
Const #HGUI_ALIGN_LEFT   = 1
Const #HGUI_ALIGN_RIGHT  = 2
Const #HGUI_ALIGN_TOP    = 4
Const #HGUI_ALIGN_BOTTOM = 8
Const #HGUI_ALIGN_HCENTER = 16
Const #HGUI_ALIGN_VCENTER = 32
Const #HGUI_ALIGN_CENTER  = 48

; Text edge effects
Const #HGUI_TEXTEDGE_FLAT     = 1
Const #HGUI_TEXTEDGE_RAISED   = 2
Const #HGUI_TEXTEDGE_RECESSED = 3

; Image gadgets scale modes
Const #HGUI_IMAGEMODE_FITMIN  = 1
Const #HGUI_IMAGEMODE_FITMAX  = 2
Const #HGUI_IMAGEMODE_SCALE   = 3
Const #HGUI_IMAGEMODE_STRETCH = 4


;::: UTILITY TO HANDLE NESTED BeginRefresh() EndRefresh()
; THIS MUST BE TIED TO THE SCREEN ID!!
Function HGui.BeginRefresh(winObj)
  If HGui.RefreshBlockEnabled
    ;DebugPrint("RB:", winObj.name)
    If TB.Item.Exists(HGui.RBTracker, winObj)
      HGui.RBTracker[winObj] = HGui.RBTracker[winObj] + 1   
      ;DebugPrint("  ", HGui.RBTracker[winObj])
    Else
      HGui.RBTracker[winObj] = 1
      SelectDisplay(winObj.private.hwid, True)
      BeginRefresh()
    EndIf
  EndIf
  
EndFunction

Function HGui.EndRefresh(winObj)
  If HGui.RefreshBlockEnabled
    If TB.Item.Exists(HGui.RBTracker, winObj)
      HGui.RBTracker[winObj] = HGui.RBTracker[winObj] - 1
    
      If HGui.RBTracker[winObj] = 0
        HGui.RBTracker[winObj] = Nil
        ;DebugPrint("  closed ", winObj.name)
        SelectDisplay(winObj.private.hwid, True)
        EndRefresh()
      EndIf
    EndIf
  EndIf
  
EndFunction

;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::: THEME DEFINITION :::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

Function HGui.Theme.Generate_SkinColor(color) ; *TriDoc*
/******************************************************************************
skin = HGui.Theme.Generate_SkinColor(color)

Generate a standard skin composed by a fill color.
---------------------------------------------------------------------
INPUT
  color : [NUM] ARGB Color
  
OUTPUT
  skin : [TBL] Table with the generated skin definition
  
EXAMPLE
  f001 - HGui.Theme.Generate_SkinColor().hws
******************************************************************************/
  Return({{ Area   = { x = 0, y = 0, w = 0, h = 0 },
            Type   = GFX.SkinType_Color,
            Params = { Color = color, Alpha = -1 }}})
EndFunction

Function HGui.Theme.Generate_SkinBevel(type, fx, height, light, dark, middle) ; *TriDoc*
/******************************************************************************
skin = HGui.Theme.Generate_SkinBevel(type, fx, height, light, dark, middle)

Generate a standard skin composed by a bevel box.
---------------------------------------------------------------------
INPUT
  type   : [NUM] Bevel type, can be one of the folliwing : GFX.BevelType_Standard, GFX.BevelType_Sunken
  fx     : [NUM] Bevel effect, can be one of the following : GFX.BevelFx_Raised, GFX.BevelFx_Recessed, GFX.BevelFx_Flat
  height : [NUM] Bevel height in pixel
  light  : [NUM] ARGB color for bright edges
  dark   : [NUM] ARGB color for dark edges
  middle : [NUM] ARGB color for middle area
  
OUTPUT
  skin : [TBL] Table with the skin definition
  
EXAMPLE
  f002 - HGui.Theme.Generate_SkinBevel().hws
******************************************************************************/
  Return({{ Area   = { x = 0, y = 0, w = 0, h = 0 },
            Type   = GFX.SkinType_Bevel,
            Params = { Colors = { Light = light, Dark = dark, Middle = middle },
                       Aspect = { Fx = fx, Height = height, Type = type }}}})
EndFunction

Function HGui.Theme.Generate_SkinDoubleGradient(color1, color2, h) ; *TriDoc*
/******************************************************************************
skin = HGui.Theme.Generate_SkinDoubleGradient(color1, color2, h)

Generate a standard skin composed by two nested and inverted gradients.
---------------------------------------------------------------------
INPUT
  color1 : [NUM] ARGB Color 1
  color2 : [NUM] ARGB Color 2
  
OUTPUT
  skin : [TBL] Table with the skin definition
  
EXAMPLE
  f003 - HGui.Theme.Generate_SkinDoubleGradient().hws
******************************************************************************/
  If IsNil(h) Then h = 2
  Return({{ Area   = { x = 0, y = 0, w = 0, h = 0 },
            Type   = GFX.SkinType_Gradient,
            Params = { Color1 = color1, Color2 = color2, Alpha = -1, Angle = 0 }},
          { Area   = { x = h, y = h, w = -h*2, h = -h*2 },
            Type   = GFX.SkinType_Gradient,
            Params = { Color1 = color2, Color2 = color1, Alpha = -1, Angle = 0 }}})
EndFunction

Function HGui.Theme.Generate_Set_SkinGradient(color1, color2) ; *TriDoc*
/******************************************************************************
states = HGui.Theme.Generate_Set_SkinGradient(state, color1, color2)

Generate a full set for the button gagdet.
---------------------------------------------------------------------
INPUT
  color1 : [NUM] ARGB Color 1
  color2 : [NUM] ARGB Color 2
  
OUTPUT
  states : [TBL] Table with every skin state definition (nState, hState, pState, dState)
  
EXAMPLE
  f005 - HGui.Theme.Generate_Set_SkinGradient().hws
******************************************************************************/
  Local states = {}
  
  ; Create color objects
  Local c1, c2 = HL.Color:new(color1), HL.Color:new(color2)

  ; Normal State
  Local c1n, c2n = c1:Clone(), c2:Clone()
  c1n:Brighten(10)
  c2n:Darken(10)
  states.nSkin = HGui.Theme.Generate_SkinGradient(color1, color2)
  Local skin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, c1n:toRGBValue(), c2n:toRGBValue, $FF000000)
  InsertItem(states.nSkin, skin[0])

  ; Hilighted State (The button is hilighted)
  Local c1h, c2h = c1:Clone(), c2:Clone()
  c1h:Brighten(20)
  c2h:Brighten(20)
  states.hSkin = HGui.Theme.Generate_SkinGradient(c1h:toRGBValue(), c2h:toRGBValue())
  InsertItem(states.hSkin, skin[0])

  ; Pushed State (The color are inverted)
  states.pSkin = HGui.Theme.Generate_SkinGradient(c2h:toRGBValue(), c1h:toRGBValue())
  Local skin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, c2n:toRGBValue(), c1n:toRGBValue, $FF000000)
  InsertItem(states.pSkin, skin[0])
  
  ; Disabled State (Range restriction)
  Local c1d, c2d = c1:Clone(), c2:Clone()
  c1h:Darken(20)
  c2h:Brighten(20)
  states.dSkin = HGui.Theme.Generate_SkinGradient(c1h:toRGBValue(), c2h:toRGBValue())
  
  Return(States)
  
EndFunction

Function HGui.Theme.Generate_SkinGradient(color1, color2) ; *TriDoc*
/******************************************************************************
skin = HGui.Theme.Generate_SkinGradient(color1, color2)

Generate a standard skin composed by a gradient.
---------------------------------------------------------------------
INPUT
  color1 : [NUM] ARGB Color 1
  color2 : [NUM] ARGB Color 2
  
OUTPUT
  skin : [TBL] Table with the skin definition
  
EXAMPLE
  f004 - HGui.Theme.Generate_SkinGradient().hws
******************************************************************************/  
  Return({{ Area   = { x = 0, y = 0, w = 0, h = 0 },
            Type   = GFX.SkinType_Gradient,
            Params = { Color1 = color1, Color2 = color2, Alpha = -1, Angle = 0 }}})
EndFunction

Function HGui.Theme.Generate_Text(size, style, color, align, edge, shadow, margins) ; *TriDoc*
/******************************************************************************
skin = HGui.Theme.Generate_Text(size, style, color, align, edge, shadow, margins)

Generate a standard cText skin.
---------------------------------------------------------------------
INPUT
  size    : [NUM] Fontsize
  style   : [CNS] Font style
  color   : [NUM] ARGB Color for the text
  align   : [CNS] Text alignment, can be one or a combination of the following constants : #HGUI_ALIGN_LEFT, #HGUI_ALIGN_RIGHT, #HGUI_ALIGN_TOP, #HGUI_ALIGN_BOTTOM, #HGUI_ALIGN_HCENTER, #HGUI_ALIGN_VCENTER, #HGUI_ALIGN_CENTER
  edge    : [BLN] Set to TRUE to apply a raised 3d edge effect
  shadow  : [BLN] Set to TRUE to apply a south-east shadow effect
  margins : [TBL] An optional table with the text margins in pixels, accepted fields are : Top, Left, Right, Bottom
    
OUTPUT
  skin : [TBL] Table with the cText skin definition
  
EXAMPLE
  f006 - HGui.Theme.Generate_Text().hws
******************************************************************************/  
  If HL.IsNil(margins) Then margins = { top = 0, bottom = 0, left = 0, right = 0 }
  
  Return({ name        = Nil,
           first_line  = 1,
           ;caption     = {""},
           wordwrap    = False,
           interline   = 0,
           angle       = 0,
           encoding    = HGui.TextEncoding,
           vert_adjust = 0,
           font        = { name = #SANS, size = size, style = style, color = color, align = align },
           effects     = { edge   = IIf(edge,   { type = #HGUI_TEXTEDGE_RAISED, size = 1, color1 = $444444, color2 = $FFFFFF }, 
                                                { type = #NONE, size = 1, color1 = $444444, color2 = $44FFFF }),
                           shadow = IIf(shadow, { type = #SHDWSOUTHEAST, distance = 1, color = $88444444 },
                                                { type = #NONE, distance = 1, color = $88666666 })},
           margins     = margins })
EndFunction     


;:::[ WINDOW'S BACKGROUND COLOR ]::::::::::::::::::::::::::::::::::::::::::DOC:
HGui.Theme.WindowBG = $050511

;:::[ TIP'S WINDOW ]:::::::::::::::::::::::::::::::::::::::::::::::::::::::DOC:
HGui.Theme.Tip = {}
HGui.Theme.Tip.BGColor = $FFFFFF
HGui.Theme.Tip.nSkin   = HGui.Theme.Generate_SkinColor($00DDDDDD)
HGui.Theme.Tip.nText   = HGui.Theme.Generate_Text(14, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)

;:::[ WINDOW'S ROOT GADGET ]:::::::::::::::::::::::::::::::::::::::::::::::DOC:
HGui.Theme.Root = {}
HGui.Theme.Root.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $88FFFFFF, $88666666, #NONE)

;:::[ WINDOW'S TOP MENU AREA ]:::::::::::::::::::::::::::::::::::::::::::::DOC:
HGui.Theme.Menu = {}
HGui.Theme.Menu.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Flat, 1, $DDDDDD, $DDDDDD, $DDDDDD)
HGui.Theme.Menu.Height          = 20             ; Top bar size
HGui.Theme.Menu.FontOffset      = -4             ; Adjust font size into the top bar
HGui.Theme.Menu.Borders         = 
  { Top = 0, Bottom = 0, Left = 0, Right = 0 }   ; Top bar container offsets
HGui.Theme.Menu.TopBoxSpacing   = 0              ; Space between top box and gadget area
HGui.Theme.Menu.TopItemsSpacing = 0              ; Space bewtween top items
HGui.Theme.Menu.ItemsBorder     =                ; Top items borders
  { Top = 1, Bottom = 1, Left = 1, Right = 1 }
HGui.Theme.Menu.ItemsLook      = {}              ; TOP ITEMS LOOK
HGui.Theme.Menu.ItemsLook.nSkin = HGui.Theme.Generate_SkinColor($00DDDDDD)
HGui.Theme.Menu.ItemsLook.hSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $EEF0F0)
HGui.Theme.Menu.ItemsLook.pSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $EEEEEE, $888888, $AAAAAA)
HGui.Theme.Menu.ItemsLook.dSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $BBBBBB)
HGui.Theme.Menu.ItemsLook.npSkin= HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $EEEEEE, $888888, $AAAAAA)
HGui.Theme.Menu.ItemsLook.hpSkin= HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $EEEEEE, $888888, $EEEEEE)
HGui.Theme.Menu.ItemsLook.dpSkin= HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $EEEEEE, $888888, $BBBBBB)
; Nota : la dimensione del font non viene considerata perch√© conta <HGui.Theme.Menu.Height>
HGui.Theme.Menu.ItemsLook.nText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, False)
HGui.Theme.Menu.ItemsLook.hText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.Menu.ItemsLook.pText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.Menu.ItemsLook.dText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $AAAAAA, #HGUI_ALIGN_CENTER, False, False)
HGui.Theme.Menu.ItemsLook.npText= HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.Menu.ItemsLook.hpText= HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.Menu.ItemsLook.dpText= HGui.Theme.Generate_Text(16, #ANTIALIAS, $AAAAAA, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.SubMenu = {}                          ; MENU WINDOW & ITEMS
HGui.Theme.SubMenu.BGColor      = $CCCCCC
HGui.Theme.SubMenu.RootSkin     = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $FFFFFF, $444444, $DDDDDD)
HGui.Theme.SubMenu.Height       = 18             ; SubItem size
HGui.Theme.SubMenu.FontOffset   = -2             ; SubItem font adjustment
HGui.Theme.SubMenu.Borders      =                ; SubItems group borders
  { Top = 2, Bottom = 2, Left = 2, Right =  2 }
HGui.Theme.SubMenu.Gap          = 4              ; Space between items
HGui.Theme.SubMenu.HorizontalOverlap = 8
HGui.Theme.SubMenu.MenuHOverlap  = 8
HGui.Theme.SubMenu.MenuVOverlap  = 2
HGui.Theme.SubMenu.ItemsLook = {}
HGui.Theme.SubMenu.ItemsLook.nSkin = HGui.Theme.Generate_SkinColor($00DDDDDD)
HGui.Theme.SubMenu.ItemsLook.hSkin = HGui.Theme.Generate_SkinColor($00EEF0F0)
HGui.Theme.SubMenu.ItemsLook.pSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $EEEEEE, $888888, $999999)
HGui.Theme.SubMenu.ItemsLook.dSkin = HGui.Theme.Generate_SkinColor($00DDDDDD)
HGui.Theme.SubMenu.ItemsLook.npSkin= HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $EEEEEE, $888888, $999999)
HGui.Theme.SubMenu.ItemsLook.hpSkin= HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $EEEEEE, $888888, $BBA099)
HGui.Theme.SubMenu.ItemsLook.dpSkin= HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $EEEEEE, $888888, $BBBBBB)
HGui.Theme.SubMenu.ItemsLook.nText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_LEFT, False, False, { top = 0, bottom = 0, left = 5, right = 0 })
HGui.Theme.SubMenu.ItemsLook.hText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_LEFT, False, True, { top = 0, bottom = 0, left = 5, right = 0 })
HGui.Theme.SubMenu.ItemsLook.pText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $FFFFFF, #HGUI_ALIGN_LEFT, False, True, { top = 0, bottom = 0, left = 5, right = 0 })
HGui.Theme.SubMenu.ItemsLook.dText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $777777, #HGUI_ALIGN_LEFT, False, False, { top = 0, bottom = 0, left = 5, right = 0 })
HGui.Theme.SubMenu.ItemsLook.npText= HGui.Theme.Generate_Text(16, #ANTIALIAS, $FFEE66, #HGUI_ALIGN_LEFT, False, False, { top = 0, bottom = 0, left = 5, right = 0 })
HGui.Theme.SubMenu.ItemsLook.hpText= HGui.Theme.Generate_Text(16, #ANTIALIAS, $FFFF88, #HGUI_ALIGN_LEFT, False, False, { top = 0, bottom = 0, left = 5, right = 0 })
HGui.Theme.SubMenu.ItemsLook.dpText= HGui.Theme.Generate_Text(16, #ANTIALIAS, $666666, #HGUI_ALIGN_LEFT, False, False, { top = 0, bottom = 0, left = 5, right = 0 })

;:::[ EMPTY BOX GADGET ]:::::::::::::::::::::::::::::::::::::::::::::::::::DOC:
HGui.Theme.Empty = {}
HGui.Theme.Empty.nSkin = HGui.Theme.Generate_SkinColor($FF000000)

;:::[ SYSTEM REQUEST ]:::::::::::::::::::::::::::::::::::::::::::::::::::::   :
Local hsw, hsh = GFX.GetHostSize()
HGui.Theme.SysRequest = {}
HGui.Theme.SysRequest.WindowSize = { w = Int(hsw/3), h = Int(hsh/4) }
HGui.Theme.SysRequest.nSkin = HGui.Theme.Generate_SkinColor($CCCCCC)
HGui.Theme.SysRequest.nText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, False, { left = 20, right = 20 })
HGui.Theme.SysRequest.imageBorder = $CCCCCC
HGui.Theme.SysRequest.imageMode = 1
HGui.Theme.SysRequest.imageAlign = #CENTER
HGui.Theme.SysRequest.imageBorders = { Left = 4, Right = 4, Top = 4, Bottom = 4 }
HGui.Theme.SysRequest.iconSize = 64
HGui.Theme.SysRequest.Buttons = {}
HGui.Theme.SysRequest.Buttons.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEFF, $8888AA, $BBBBEE)
HGui.Theme.SysRequest.Buttons.hSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEFF, $8888AA, $DDDDFF)
HGui.Theme.SysRequest.Buttons.pSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $EEEEFF, $8888AA, $999999BB)
HGui.Theme.SysRequest.Buttons.dSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEFF, $8888AA, $AAAAAACC)
HGui.Theme.SysRequest.Buttons.nText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, False)
HGui.Theme.SysRequest.Buttons.hText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.SysRequest.Buttons.pText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.SysRequest.Buttons.dText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $666666, #HGUI_ALIGN_CENTER, False, False)

;:::[ BOX GADGET ]:::::::::::::::::::::::::::::::::::::::::::::::::::::::::DOC:
HGui.Theme.Box = {}
HGui.Theme.Box.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $333333, $99CCCCCC)

;:::[ HDIVIDER GADGET ]::::::::::::::::::::::::::::::::::::::::::::::::::::DOC:
HGui.Theme.HDivider = {}
HGui.Theme.HDivider.Colors = {}
HGui.Theme.HDivider.Colors.Color1 = $666666
HGui.Theme.HDivider.Colors.Color2 = $DDDDDD
HGui.Theme.HDivider.Size = 1
HGui.Theme.HDivider.Padding = 0
HGui.Theme.HDivider.nSkin = HGui.Theme.Generate_SkinColor($FF000000)

;:::[ VDIVIDER GADGET ]:::::::::::::::::::::::::::::::::::::::::::::::::::DOC:
HGui.Theme.VDivider = {}
HGui.Theme.VDivider.Colors = {}
HGui.Theme.VDivider.Colors.Color1 = $666666
HGui.Theme.VDivider.Colors.Color2 = $DDDDDD
HGui.Theme.VDivider.Size = 1
HGui.Theme.VDivider.Padding = 0
HGui.Theme.VDivider.nSkin = HGui.Theme.Generate_SkinColor($FF000000)

;:::[ LABEL GADGET ]:::::::::::::::::::::::::::::::::::::::::::::::::::::::DOC:
HGui.Theme.sLabel = {} 
HGui.Theme.sLabel.nSkin = HGui.Theme.Generate_SkinColor($CCCCCC)
HGui.Theme.sLabel.nText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, False)

;:::[ GROUP GADGET ]:::::::::::::::::::::::::::::::::::::::::::::::::::::::DOC:
HGui.Theme.Group = {}
HGui.Theme.Group.obSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $DDDDDD)
HGui.Theme.Group.ibSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Sunken, GFX.BevelFx_Recessed, 1, $EEEEEE, $888888, $DDDDDD)
HGui.Theme.Group.nText  = HGui.Theme.Generate_Text(14, #ANTIALIAS, $444444, #HGUI_ALIGN_CENTER, False, False)
HGui.Theme.Group.nSkin  = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 2, $EEEEEE, $888888, $CCCCCC, { Top = 1, Bottom = 1, Left = 1, Right = 1 })
HGui.Theme.Group.iBorders = {}
HGui.Theme.Group.iBorders.Top = 2
HGui.Theme.Group.iBorders.Bottom = 2
HGui.Theme.Group.iBorders.Left = 2
HGui.Theme.Group.iBorders.Right = 2
HGui.Theme.Group.oBorders = {}
HGui.Theme.Group.oBorders.Top = 1
HGui.Theme.Group.oBorders.Bottom = 1
HGui.Theme.Group.oBorders.Left = 1
HGui.Theme.Group.oBorders.Right = 1
HGui.Theme.Group.gap = 0
HGui.Theme.Group.AnonymousGroupHeader = 0

;::: KNOB GADGET :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::DOC:
HGui.Theme.Knob = {}
HGui.Theme.Knob.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $DDDDDD)
HGui.Theme.Knob.Style =
   { BorderSize1  = 2, BorderSize2 = 1,
     Border1Light = $ffffff, Border1Dark  = $444444,
     Border1FillA = $ddeeff, Border1FillB = $778899,
     Border2Light = $ffffff, Border2Dark  = $666666,
     Border2FillA = $000000, Border2FillB = $FF0000,
     Radius1      = 0.4,     Radius2      = 0.8, RadiusWidth = 8,
     Type         = 1 }

;:::[ BUTTON GADGET ]::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
HGui.Theme.Button = {}
HGui.Theme.Button.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $DDDDDD)
HGui.Theme.Button.hSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $EEEEEE)
HGui.Theme.Button.pSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $EEEEEE, $888888, $AAAAAA)
HGui.Theme.Button.dSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $BBBBBB)
HGui.Theme.Button.nText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, False)
HGui.Theme.Button.hText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.Button.pText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.Button.dText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $666666, #HGUI_ALIGN_CENTER, False, False)

;::: DROPDOWN :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
HGui.Theme.DropDown = {}
HGui.Theme.DropDown.nSkin = HGui.Theme.Generate_SkinDoubleGradient($666666, $FFFFFF)
HGui.Theme.DropDown.hSkin = HGui.Theme.Generate_SkinDoubleGradient($888888, $FFFFFF)
HGui.Theme.DropDown.pSkin = HGui.Theme.Generate_SkinDoubleGradient($444444, $DDDDDD)
HGui.Theme.DropDown.dSkin = HGui.Theme.Generate_SkinDoubleGradient($666666, $888888)
HGui.Theme.DropDown.nText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, False)
HGui.Theme.DropDown.hText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.DropDown.pText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.DropDown.dText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $777777, #HGUI_ALIGN_CENTER, False, False)
HGui.Theme.DropDown.WindowBGColor = $000000
HGui.Theme.DropDown.WindowBorders = 1
;HGui.Theme.DropDown.listText = HGui.Theme.Generate_Text(14, #ANTIALIAS, $000000, #HGUI_ALIGN_LEFT, False, False)
;HGui.Theme.DropDown.listExtra = 4
;HGui.Theme.DropDown.listInterline = 2

HGui.Theme.DropDown.LVFont         = { Name = #SANS, Style = #ANTIALIAS, Color = $000000, SizeOffset = 0 }
HGui.Theme.DropDown.LVBGColors     = { odd = $DDEEDD, even = $EEEEEE }
HGui.Theme.DropDown.EntryHeight    = 16
HGui.Theme.DropDown.AlternateLines = False

;::: LISTVIEW GADGET ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
HGui.Theme.ListView = {}
HGui.Theme.ListView.OuterBox  = {}
HGui.Theme.ListView.Body      = {}
HGui.Theme.ListView.TopBox    = {}
HGui.Theme.ListView.Scrollbar = {}

HGui.Theme.ListView.OuterBox.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $DDDDDD)
HGui.Theme.ListView.Body.nSkin     = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $DDDDDD)
HGui.Theme.ListView.TopBox.nSkin   = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $DDDDDD)

  ; Column headers
HGui.Theme.ListView.nSkin = HGui.Theme.Generate_SkinGradient($EEEEEE, $888888)
HGui.Theme.ListView.hSkin = HGui.Theme.Generate_SkinGradient($FFFFFF, $999999)
HGui.Theme.ListView.pSkin = HGui.Theme.Generate_SkinGradient($666666, $AAAAAA)
HGui.Theme.ListView.dSkin = HGui.Theme.Generate_SkinGradient($999999, $888888)
HGui.Theme.ListView.nText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_LEFT, False, False, { top = 0, bottom = 0, left = 4, right = 0 })
HGui.Theme.ListView.hText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_LEFT, False, True, { top = 0, bottom = 0, left = 4, right = 0 })
HGui.Theme.ListView.pText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_LEFT, False, True, { top = 0, bottom = 0, left = 4, right = 0 })
HGui.Theme.ListView.dText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $777777, #HGUI_ALIGN_LEFT, False, False, { top = 0, bottom = 0, left = 4, right = 0 })

  ; Content's area
HGui.Theme.ListView.Font     = { Name = #SANS, SizeOffset = -2, Style = #ANTIALIAS, Color = $000000 }
HGui.Theme.ListView.BGColors = { odd = $BBAABB, even = $CCBBCC }
HGui.Theme.ListView.Selected = { FontColor = $FFFFFF, BGColor = $99FF0000 }
HGui.Theme.ListView.EntryHeight = 20
;--NEW--
HGui.Theme.ListView.AlternateLines = True
HGui.Theme.ListView.VerticalLines = True
HGui.Theme.ListView.VLinesColor1 = $666666
HGui.Theme.ListView.VLinesColor2 = $DDDDDD
HGui.Theme.ListView.ColumnsGap = 0
HGui.Theme.ListView.HeadersHeight = 20
HGui.Theme.ListView.IconTextGap = 2

  ; Scrollbars
HGui.Theme.ListView.Scrollbar.oBox = {}
HGui.Theme.ListView.Scrollbar.oBox.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $AAAAAA, $444444, $888888)
HGui.Theme.ListView.Scrollbar.oBox.hSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $AAAAAA, $444444, $AA8888)
HGui.Theme.ListView.Scrollbar.oBox.pSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 2, $AAAAAA, $444444, $AA6666)
HGui.Theme.ListView.Scrollbar.oBox.dSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $AAAAAA, $444444, $888888)
;--NEW--
HGui.Theme.ListView.Scrollbar.Size = 16

  ; Scrollbars Cursor
HGui.Theme.ListView.Scrollbar.cBox = {}
HGui.Theme.ListView.Scrollbar.cBox.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEFFFF, $557788, $BBCCCC)
HGui.Theme.ListView.Scrollbar.cBox.hSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEFFFF, $557788, $CCDDDD)
HGui.Theme.ListView.Scrollbar.cBox.pSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $EEFFFF, $446666, $AABBBB)
HGui.Theme.ListView.Scrollbar.cBox.dSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $BBBBBB)
HGui.Theme.ListView.Scrollbar.cBox.nText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, False)
HGui.Theme.ListView.Scrollbar.cBox.hText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.ListView.Scrollbar.cBox.pText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.ListView.Scrollbar.cBox.dText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $777777, #HGUI_ALIGN_CENTER, False, False)

  ; Cursor's handle
HGui.Theme.ListView.Scrollbar.Handle = 
  { normal    = { color1 = $EEEEEE, color3 = $CCCCCC, color2 = $444444 },
    hilighted = { color1 = $FFFFFF, color3 = $CCCCCC, color2 = $666666 },
    pushed    = { color1 = $444444, color3 = $777777, color2 = $DDDDDD },
    disabled  = { color1 = $777777, color3 = $888888, color2 = $999999 },
    type      = "dots", ; lines, dots, box, none
    quantity  = 2,      ; solo per lines, dots
    size      = 2,
    gap       = 1 }     ; solo per lines, dots, box = border's height

;::: TREEVIEW GADGET ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
HGui.Theme.TreeView = {}
HGui.Theme.TreeView.OuterBox = {}
HGui.Theme.TreeView.Body = {}
HGui.Theme.TreeView.TopBox = {}
HGui.Theme.TreeView.Scrollbar = {}

HGui.Theme.TreeView.OuterBox.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $DDDDDD)
HGui.Theme.TreeView.Body.nSkin     = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $DDDDDD)
HGui.Theme.TreeView.TopBox.nSkin   = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $DDDDDD)

  ; Column headers
HGui.Theme.TreeView.nSkin = HGui.Theme.Generate_SkinGradient($888888, $EEEEEE)
HGui.Theme.TreeView.hSkin = HGui.Theme.Generate_SkinGradient($999999, $FFFFFF)
HGui.Theme.TreeView.pSkin = HGui.Theme.Generate_SkinGradient($555555, $FFFFFF)
HGui.Theme.TreeView.dSkin = HGui.Theme.Generate_SkinGradient($888888, $999999)
HGui.Theme.TreeView.nText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_LEFT, False, False, { top = 0, bottom = 0, left = 4, right = 0 })
HGui.Theme.TreeView.hText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_LEFT, False, True, { top = 0, bottom = 0, left = 4, right = 0 })
HGui.Theme.TreeView.pText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_LEFT, False, True, { top = 0, bottom = 0, left = 4, right = 0 })
HGui.Theme.TreeView.dText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $777777, #HGUI_ALIGN_LEFT, False, False, { top = 0, bottom = 0, left = 4, right = 0 })

  ; Content's area
HGui.Theme.TreeView.Font     = { Name = #SANS, SizeOffset = -2, Style = #ANTIALIAS, Color = $000000 }
HGui.Theme.TreeView.BGColors = { odd = $BBBBAA, even = $CCCCBB }
HGui.Theme.TreeView.Selected = { FontColor = $FFFF00, BGColor = $99007777 }
;--NEW--
HGui.Theme.TreeView.EntryHeight = 20
HGui.Theme.TreeView.AlternateLines = True
HGui.Theme.TreeView.VerticalLines = True
HGui.Theme.TreeView.VLinesColor1 = $DDDDDD
HGui.Theme.TreeView.VLinesColor2 = $666666
HGui.Theme.TreeView.ColumnsGap = 0
HGui.Theme.TreeView.HeadersHeight = 20
HGui.Theme.TreeView.NodeStyle = 1
HGui.Theme.TreeView.IconTextGap = 2

  ; Scrollbars
HGui.Theme.TreeView.Scrollbar.oBox = {}
HGui.Theme.TreeView.Scrollbar.oBox.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $AAAAAA, $444444, $888888)
HGui.Theme.TreeView.Scrollbar.oBox.hSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $AAAAAA, $444444, $AA8888)
HGui.Theme.TreeView.Scrollbar.oBox.pSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 2, $AAAAAA, $444444, $AA6666)
HGui.Theme.TreeView.Scrollbar.oBox.dSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $AAAAAA, $444444, $888888)
;--NEW--
HGui.Theme.TreeView.Scrollbar.Size = 16

; Scrollbars Cursor
HGui.Theme.TreeView.Scrollbar.cBox = {}
HGui.Theme.TreeView.Scrollbar.cBox.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEFFFF, $557788, $BBCCCC)
HGui.Theme.TreeView.Scrollbar.cBox.hSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEFFFF, $557788, $CCDDDD)
HGui.Theme.TreeView.Scrollbar.cBox.pSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $EEFFFF, $446666, $AABBBB)
HGui.Theme.TreeView.Scrollbar.cBox.dSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $BBBBBB)
HGui.Theme.TreeView.Scrollbar.cBox.nText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, False)
HGui.Theme.TreeView.Scrollbar.cBox.hText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.TreeView.Scrollbar.cBox.pText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.TreeView.Scrollbar.cBox.dText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $777777, #HGUI_ALIGN_CENTER, False, False)

; Cursor's handle
HGui.Theme.TreeView.Scrollbar.Handle = 
  { normal    = { color1 = $EEEEEE, color3 = $DDDDDD, color2 = $444444 },
    hilighted = { color1 = $FFFFFF, color3 = $EEEEEE, color2 = $666666 },
    pushed    = { color1 = $444444, color3 = $777777, color2 = $DDDDDD },
    disabled  = { color1 = $777777, color3 = $888888, color2 = $999999 },
    type      = "box", ; lines, dots, box, none
    quantity  = 1,      ; solo per lines, dots
    size      = 4,
    gap       = 1 }     ; solo per lines, dots, box = border's height

;::: SCROLLBAR GADGET :::::::::::::::::::::::::::::::::::::::::::::::::::::::::
; OuterBox
HGui.Theme.Scrollbar = {}
HGui.Theme.Scrollbar.oBox = {}
HGui.Theme.Scrollbar.oBox.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $DDDDDD, $444444, $888888)
HGui.Theme.Scrollbar.oBox.hSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $EEEEEE, $333333, $777777)
HGui.Theme.Scrollbar.oBox.pSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 2, $FFFFFF, $222222, $666666)
HGui.Theme.Scrollbar.oBox.dSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $AAAAAA, $444444, $888888)
HGui.Theme.Scrollbar.oBox.nText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_LEFT, False, False)
HGui.Theme.Scrollbar.oBox.hText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_LEFT, False, True)
HGui.Theme.Scrollbar.oBox.pText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_LEFT, False, True)
HGui.Theme.Scrollbar.oBox.dText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $666666, #HGUI_ALIGN_LEFT, False, False)

; Cursor
HGui.Theme.Scrollbar.cBox = {}
HGui.Theme.Scrollbar.cBox.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEFFFF, $557788, $BBCCCC)
HGui.Theme.Scrollbar.cBox.hSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEFFFF, $557788, $CCDDDD)
HGui.Theme.Scrollbar.cBox.pSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 2, $EEFFFF, $222222, $AABBBB)
HGui.Theme.Scrollbar.cBox.dSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $BBBBBB)
HGui.Theme.Scrollbar.cBox.nText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, False)
HGui.Theme.Scrollbar.cBox.hText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.Scrollbar.cBox.pText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.Scrollbar.cBox.dText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $777777, #HGUI_ALIGN_CENTER, False, False)

; Cursor's handle
HGui.Theme.Scrollbar.Handle = 
  { normal    = { color1 = $EEEEEE, color3 = $CCCCCC, color2 = $444444 },
    hilighted = { color1 = $FFFFFF, color3 = $CCCCCC, color2 = $666666 },
    pushed    = { color1 = $444444, color3 = $777777, color2 = $DDDDDD },
    disabled  = { color1 = $777777, color3 = $888888, color2 = $999999 },
    type      = "lines", ; lines, dots, box, none
    quantity  = 2,       ; solo per lines, dots
    size      = 1,
    gap       = 4 }      ; solo per lines, dots

;::: SLIDER GADGET ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ; OuterBox
HGui.Theme.Slider = {}
HGui.Theme.Slider.oBox = {}
HGui.Theme.Slider.oBox.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $AAAAAA, $444444, $888888)
HGui.Theme.Slider.oBox.hSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $AAAAAA, $444444, $AA8888)
HGui.Theme.Slider.oBox.pSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 2, $AAAAAA, $444444, $AA6666)
HGui.Theme.Slider.oBox.dSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $AAAAAA, $444444, $888888)
HGui.Theme.Slider.oBox.nText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, False)
HGui.Theme.Slider.oBox.hText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.Slider.oBox.pText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.Slider.oBox.dText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $777777, #HGUI_ALIGN_CENTER, False, False)

; CursorBox
HGui.Theme.Slider.cBox = {}
HGui.Theme.Slider.cBox.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEFFFF, $557788, $BBCCCC)
HGui.Theme.Slider.cBox.hSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEFFFF, $557788, $CCDDDD)
HGui.Theme.Slider.cBox.pSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $EEFFFF, $446666, $AABBBB)
HGui.Theme.Slider.cBox.dSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $BBBBBB)
HGui.Theme.Slider.cBox.nText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, False)
HGui.Theme.Slider.cBox.hText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.Slider.cBox.pText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.Slider.cBox.dText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $777777, #HGUI_ALIGN_CENTER, False, False)

; Cursor's handle rendering function
HGui.Theme.Slider.Handle = 
  { normal    = { color1 = $EEEEEE, color3 = $CCCCCC, color2 = $444444 },
    hilighted = { color1 = $FFFFFF, color3 = $CCCCCC, color2 = $666666 },
    pushed    = { color1 = $444444, color3 = $777777, color2 = $DDDDDD },
    disabled  = { color1 = $777777, color3 = $888888, color2 = $999999 },
    type      = "lines", ; lines, dots, box, none
    quantity  = 2,    ; solo per lines, dots
    size      = 1,
    gap       = 3 }   ; solo per lines, dots

;::: PROGRESSBAR GADGET :::::::::::::::::::::::::::::::::::::::::::::::::::::::
; OuterBox
HGui.Theme.Progressbar = {}
HGui.Theme.Progressbar.oBox = {}
HGui.Theme.Progressbar.oBox.nskin = HGui.Theme.Generate_SkinGradient($444444, $BBBBBB)

; CursorBox
HGui.Theme.Progressbar.cBox = {}
HGui.Theme.Progressbar.cBox.nSkin = HGui.Theme.Generate_SkinGradient($BBFFDD, $55AA66)
HGui.Theme.Progressbar.cBox.nText = HGui.Theme.Generate_Text(14, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, False)

;:::[ SWITCH GADGET ]::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
HGui.Theme["switch"] = {}
HGui.Theme["switch"].nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $D0D0C6)
HGui.Theme["switch"].hSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $E0E0D6)
HGui.Theme["switch"].pSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 2, $EEEEEE, $888888, $C0C0B6)
HGui.Theme["switch"].dSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $BBBBBB)
HGui.Theme["switch"].npSkin= HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $EEEEEE, $888888, $B0B0A6)
HGui.Theme["switch"].hpSkin= HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $EEEEEE, $888888, $C6C6B6)
HGui.Theme["switch"].dpSkin= HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $EEEEEE, $888888, $A6A6A6)
HGui.Theme["switch"].nText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, False)
HGui.Theme["switch"].hText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, False)
HGui.Theme["switch"].pText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme["switch"].dText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $666666, #HGUI_ALIGN_CENTER, False, False)
HGui.Theme["switch"].npText= HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme["switch"].hpText= HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme["switch"].dpText= HGui.Theme.Generate_Text(16, #ANTIALIAS, $666666, #HGUI_ALIGN_CENTER, False, True)

;:::[ VIRTUAL BOX ]::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
HGui.Theme.Virtual = {}
  ; Container
HGui.Theme.Virtual.Container = {}
HGui.Theme.Virtual.Container.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $EEEEEE, $888888, $D0D0C6)
  ; Virtual Container
HGui.Theme.Virtual.VirtualBox = {}
HGui.Theme.Virtual.VirtualBox.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $D0D0C6)
  ; Scrollbars
HGui.Theme.Virtual.Scroller = {}
HGui.Theme.Virtual.Scroller.oBox = {}
HGui.Theme.Virtual.Scroller.oBox.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $AAAAAA, $444444, $888888)
HGui.Theme.Virtual.Scroller.oBox.hSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $AAAAAA, $444444, $AA8888)
HGui.Theme.Virtual.Scroller.oBox.pSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 2, $AAAAAA, $444444, $AA6666)
HGui.Theme.Virtual.Scroller.oBox.dSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $AAAAAA, $444444, $888888)

; Scrollbars Cursor
HGui.Theme.Virtual.Scroller.cBox = {}
HGui.Theme.Virtual.Scroller.cBox.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEFFFF, $557788, $BBCCCC)
HGui.Theme.Virtual.Scroller.cBox.hSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEFFFF, $557788, $CCDDDD)
HGui.Theme.Virtual.Scroller.cBox.pSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Recessed, 1, $EEFFFF, $446666, $AABBBB)
HGui.Theme.Virtual.Scroller.cBox.dSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $BBBBBB)
HGui.Theme.Virtual.Scroller.cBox.nText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, False)
HGui.Theme.Virtual.Scroller.cBox.hText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.Virtual.Scroller.cBox.pText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $000000, #HGUI_ALIGN_CENTER, False, True)
HGui.Theme.Virtual.Scroller.cBox.dText = HGui.Theme.Generate_Text(16, #ANTIALIAS, $777777, #HGUI_ALIGN_CENTER, False, False)

; Cursor's handle
HGui.Theme.Virtual.Scroller.Handle = 
  { normal    = { color1 = $EEEEEE, color3 = $DDDDDD, color2 = $444444 },
    hilighted = { color1 = $FFFFFF, color3 = $EEEEEE, color2 = $666666 },
    pushed    = { color1 = $444444, color3 = $777777, color2 = $DDDDDD },
    disabled  = { color1 = $777777, color3 = $888888, color2 = $999999 },
    type      = "box", ; lines, dots, box, none
    quantity  = 1,      ; solo per lines, dots
    size      = 4,
    gap       = 1 }     ; solo per lines, dots, box = border's height

;::: TEXT :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
HGui.Theme.Text = {}
HGui.Theme.Text.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Sunken, GFX.BevelFx_Raised, 1, $EEFFFF, $557788, $BBCCCC)
HGui.Theme.Text.hSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Sunken, GFX.BevelFx_Raised, 1, $EEFFFF, $557788, $CCDDDD)
HGui.Theme.Text.pSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Sunken, GFX.BevelFx_Recessed, 1, $EEFFFF, $557788, $BBCCCC)
HGui.Theme.Text.dSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Flat, 1, $EEFFFF, $557788, $BBCCCC)
HGui.Theme.Text.Gfx = { bgColor  = $DDDDDD,
                        fgColor  = $000000,
                        bgCursor = $FF0000,
                        fgCursor = $FFFFFF,
                        bgSelect = $FFFF00,
                        FontName = #SANS,
                        FontSize = 16,
                        FontStyle = #ANTIALIAS,
                        AdjustFontSize = False }

; ===================================================================
; ===================================================================
; ===================================================================

Function HGui.SetDragKey(dKey) ; *TriDoc*
/******************************************************************************
HGui.SetDragKey(dKey)

Sets the key that allow gadgets dragging.
---------------------------------------------------------------------
INPUT
  dKey : Qualifier key to associate with the dragging operation
******************************************************************************/
  DBG.Console.Out(".SetDragKey() : " .. dKey, DBG.OpenFunc, HGui.DebugChannel)

  HGui.DragKey = dKey

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
EndFunction

Function HGui.GetVersion() ; *TriDoc*
/*-------------------------------------------------------------------
major, minor, build_date = HGui.GetVersion()

Returns the HGui library version.
---------------------------------------------------------------------
OUTPUT
  major      : Major version number
  minor      : Minor version number
  build_date : Build date (yyyy-mm-dd)
  
NOTE
  The HGui library version is stored in the table 'HGui.Version'.
------------------------------------------------------------------*/
  ;DBG.Console.Out(".GetVersion()", DBG.OpenFunc, HGui.DebugChannel)

  Return(HGui.Version[0], HGui.Version[1], HGui.Version[2])

  ;DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
EndFunction


Function HGui.Theme.SetGlobalTheme(GadgetType, Theme) ; *TriDoc* INCOMPLETE
/******************************************************************************
HGui.Theme.SetGlobalTheme(GadgetType, Theme)

Apply the given 'Theme' to all gadget classes specified by 'GadgetType' only
if the gadget's theme has not be customized at creation time.
---------------------------------------------------------------------
INPUT
  GadgetType : [CNS] The involved gadget type constant. Additionally you can use the constant #ALL to set all supported gadgets in one go.
  Theme      : [TBL] The complete theme table to apply.
  
OUTPUT
  Result : TRUE if success, FALSE if fails
  
NOTE
  Custom skins will not be changed.
  A custom skin is a skin that has been set using the gadget's method :setTheme()
  This method will cause a refresh of all windows
  
EXAMPLE

******************************************************************************/
  DBG.Console.Out(".Theme.SetGlobalTheme() : " .. ToString(GadgetType) .. ", " .. ToString(Theme), DBG.OpenFunc, HGui.DebugChannel)

  Local activeWindow = HGui.ActiveWindow
  
  Switch GadgetType
    ;:::::::::::
    ;::: BOX :::
    ;:::::::::::
    Case #HGUI_BOX_GADGET
      ;| HGui.Theme.Box = {}
      ;| HGui.Theme.Box.nSkin
    
      ; Set the global theme
      If TB.Item.Exists(Theme, "nskin") Then HGui.Theme.Box.nSkin = Nil
      TB.Merge(HGui.Theme.Box, Theme, True)

      ; Rebuild Cache & apply changes to all existing gadgets
      For i, v In Pairs(HGui.Gadgets)
        If v.Type = #HGUI_BOX_GADGET And Not(v.Private.IsRoot) And Not(v.Private.IsMenu) And Not(v.Private.IsMasterRoot)
          If Not(v.Look.IsCustom)
            v.Look.nSkin = HGui.Theme.Box.nSkin
            v:cacheBuild()
          EndIf
        EndIf
      Next

    ;::::::::::::::::
    ;::: VDIVIDER :::
    ;::::::::::::::::
    Case #HGUI_VDIVIDER_GADGET
      ;| HGui.Theme.VDivider = {}
      ;| HGui.Theme.VDivider.Colors
      ;| HGui.Theme.VDivider.Colors.Color1
      ;| HGui.Theme.VDivider.Colors.Color2
      ;| HGui.Theme.VDivider.Size
      ;| HGui.Theme.VDivider.Padding
      ;| HGui.Theme.VDivider.nSkin
    
      ; Set the global theme
      If TB.Item.Exists(Theme, "nskin") Then HGui.Theme.VDivider.nSkin = Nil      
      TB.Merge(HGui.Theme.VDivider, Theme, True)

      ; Rebuild Cache & apply changes to all existing gadgets
      For i, v In Pairs(HGui.Gadgets)
        If v.Type = #HGUI_VDIVIDER_GADGET
          If Not(v.Look.IsCustom)
            v.Look.nSkin = HGui.Theme.VDivider.nSkin
            v:cacheBuild()
          EndIf
        EndIf
      Next

    ;::::::::::::::::
    ;::: HDIVIDER :::
    ;::::::::::::::::
    Case #HGUI_HDIVIDER_GADGET
      ;| HGui.Theme.HDivider = {}
      ;| HGui.Theme.HDivider.Colors
      ;| HGui.Theme.HDivider.Colors.Color1
      ;| HGui.Theme.HDivider.Colors.Color2
      ;| HGui.Theme.HDivider.Size
      ;| HGui.Theme.HDivider.Padding
      ;| HGui.Theme.HDivider.nSkin

      If TB.Item.Exists(Theme, "nskin") Then HGui.Theme.HDivider.nSkin = Nil      
      TB.Merge(HGui.Theme.HDivider, Theme, True)

      ; Rebuild Cache & apply changes to all existing gadgets
      For i, v In Pairs(HGui.Gadgets)
        If v.Type = #HGUI_HDIVIDER_GADGET
          If Not(v.Look.IsCustom)
            v.Look.nSkin = HGui.Theme.HDivider.nSkin
            v:cacheBuild()
          EndIf
        EndIf
      Next

    ;:::::::::::::
    ;::: LABEL :::
    ;:::::::::::::
    Case #HGUI_LABEL_GADGET
      ;| HGui.Theme.sLabel = {} 
      ;| HGui.Theme.sLabel.nSkin
      ;| HGui.Theme.sLabel.nText

      If TB.Item.Exists(Theme, "nskin") Then HGui.Theme.sLabel.nSkin = Nil
      TB.Merge(HGui.Theme.sLabel, Theme, True)
      
      ; Rebuild Cache & apply changes to all existing gadgets
      For i, v In Pairs(HGui.Gadgets)
        If v.Type = #HGUI_LABEL_GADGET
          If Not(v.Look.IsCustom)
            v.Look.nSkin = HGui.Theme.sLabel.nSkin
            v.Look.nText:set(HGui.Theme.sLabel.nText, True)
            v:cacheBuild()
          EndIf
        EndIf
      Next
      
    ;:::::::::::::
    ;::: GROUP :::
    ;:::::::::::::
    Case #HGUI_GROUP_GADGET
      ;| HGui.Theme.Group = {}
      ;| HGui.Theme.Group.obSkin
      ;| HGui.Theme.Group.ibSkin
      ;| HGui.Theme.Group.nText
      ;| HGui.Theme.Group.nSkin
      ;| HGui.Theme.Group.iBorders
      ;| HGui.Theme.Group.iBorders.Top
      ;| HGui.Theme.Group.iBorders.Bottom
      ;| HGui.Theme.Group.iBorders.Left
      ;| HGui.Theme.Group.iBorders.Right
      ;| HGui.Theme.Group.oBorders = {}
      ;| HGui.Theme.Group.oBorders.Top
      ;| HGui.Theme.Group.oBorders.Bottom
      ;| HGui.Theme.Group.oBorders.Left
      ;| HGui.Theme.Group.oBorders.Right
      ;| HGui.Theme.Group.gap
      ;| HGui.Theme.Group.AnonymousGroupHeader

      If TB.Item.Exists(Theme, "obskin") Then HGui.Theme.Group.obSkin = Nil
      If TB.Item.Exists(Theme, "ibskin") Then HGui.Theme.Group.ibSkin = Nil
      If TB.Item.Exists(Theme, "nskin") Then HGui.Theme.Group.nSkin = Nil
      TB.Merge(HGui.Theme.Group, Theme, True)
      
      ; Rebuild Cache
      Local i, v
      For i, v In Pairs(HGui.Gadgets)
        If v.Type = #HGUI_GROUP_GADGET And Not(v.Private.IsRoot)
          If Not(v.OuterBox.Look.IsCustom)
            v.OuterBox.Look.nSkin = HGui.Theme.Group.obSkin
            v.OuterBox:cacheBuild()
          EndIf
          If Not(v.InnerBox.Look.IsCustom)
            v.InnerBox.Look.nSkin = HGui.Theme.Group.ibSkin
            v.InnerBox:cacheBuild()
          EndIf
          If Not(v.Header.Look.IsCustom)
            v.Header.Look.nSkin   = HGui.Theme.Group.nSkin
            If v.Header.Type = #HGUI_LABEL_GADGET
              v.Header.Look.nText:set(HGui.Theme.Group.nText, True)
            EndIf
            v.Header:cacheBuild()     
          EndIf
        EndIf
      Next
      
    ;::::::::::::
    ;::: KNOB :::
    ;::::::::::::
    Case #HGUI_KNOB_GADGET
      ;| HGui.Theme.Knob = {}
      ;| HGui.Theme.Knob.nSkin = HGui.Theme.Generate_SkinBevel(GFX.BevelType_Standard, GFX.BevelFx_Raised, 1, $EEEEEE, $888888, $DDDDDD)
      ;| HGui.Theme.Knob.Style =
      ;|    { BorderSize1B
      ;|      BorderSize2
      ;|      Border1Light
      ;|      Border1Dark
      ;|      Border1FillAB
      ;|      Border1FillB
      ;|      Border2Light
      ;|      Border2Dark
      ;|      Border2FillA
      ;|      Border2FillB
      ;|      Radius1
      ;|      Radius2
      ;|      RadiusWidth
      ;|      Type }

      If TB.Item.Exists(Theme, "nskin") Then HGui.Theme.Knob.nSkin = Nil
      TB.Merge(HGui.Theme.Knob, Theme, True)
      
      ; Rebuild Cache
      Local i, v
      For i, v In Pairs(HGui.Gadgets)
        If v.Type = #HGUI_KNOB_GADGET
          If Not(v.Look.IsCustom)
            v.Look.nSkin = HGui.Theme.Knob.nSkin
            v:cacheBuild()
          EndIf
        EndIf
      Next

    ;::::::::::::::
    ;::: BUTTON :::
    ;::::::::::::::
    Case #HGUI_BUTTON_GADGET
      ;| HGui.Theme.Button = {}
      ;| HGui.Theme.Button.nSkin
      ;| HGui.Theme.Button.hSkin
      ;| HGui.Theme.Button.pSkin
      ;| HGui.Theme.Button.dSkin
      ;| HGui.Theme.Button.nText
      ;| HGui.Theme.Button.hText
      ;| HGui.Theme.Button.pText
      ;| HGui.Theme.Button.dText
      
      If TB.Item.Exists(Theme, "nskin") Then HGui.Theme.Button.nSkin = Nil
      If TB.Item.Exists(Theme, "hskin") Then HGui.Theme.Button.hSkin = Nil
      If TB.Item.Exists(Theme, "pskin") Then HGui.Theme.Button.pSkin = Nil
      If TB.Item.Exists(Theme, "dskin") Then HGui.Theme.Button.dSkin = Nil
      TB.Merge(HGui.Theme.Button, Theme, True)
      
      Local skins = { "nskin", "hskin", "pskin", "dskin" }
      Local texts = { "ntext", "htext", "ptext", "dtext" }
      
      ; Rebuild Cache
      Local i, v, k
      For i, v In Pairs(HGui.Gadgets)
        If v.Type = #HGUI_BUTTON_GADGET
          ; Skip all custom skin
          If Not(v.Look.IsCustom)
            For k = 0 To 3
              Local skin, text = skins[k], texts[k]
              v.Look[skin] = HGui.Theme.Button[skin]
              v.Look[text]:set(HGui.Theme.Button[text], True)
            Next
            v:cacheBuild()
          EndIf
        EndIf
      Next

    ;::::::::::::::::
    ;::: DROPDOWN :::
    ;::::::::::::::::
    Case #HGUI_DROPDOWN_GADGET
      ;| HGui.Theme.DropDown = {}
      ;| HGui.Theme.DropDown.nSkin
      ;| HGui.Theme.DropDown.hSkin
      ;| HGui.Theme.DropDown.pSkin
      ;| HGui.Theme.DropDown.dSkin
      ;| HGui.Theme.DropDown.nText
      ;| HGui.Theme.DropDown.hText
      ;| HGui.Theme.DropDown.pText
      ;| HGui.Theme.DropDown.dText
      ;| HGui.Theme.DropDown.WindowBGColor
      ;| HGui.Theme.DropDown.WindowBorders
      ;| HGui.Theme.DropDown.LVFont
      ;|    .Name
      ;|    .SizeOffset
      ;|    .Style
      ;|    .Color
      ;| HGui.Theme.DropDown.LVBGColors
      ;|    .odd
      ;|    .even
      ;| HGui.Theme.DropDown.EntryHeight
      ;| HGui.Theme.DropDown.AlternateLines

      If TB.Item.Exists(Theme, "nskin") Then HGui.Theme.DropDown.nSkin = Nil
      If TB.Item.Exists(Theme, "hskin") Then HGui.Theme.DropDown.hSkin = Nil
      If TB.Item.Exists(Theme, "pskin") Then HGui.Theme.DropDown.pSkin = Nil
      If TB.Item.Exists(Theme, "dskin") Then HGui.Theme.DropDown.dSkin = Nil
      TB.Merge(HGui.Theme.DropDown, Theme, True)

      Local skins = { "nskin", "hskin", "pskin", "dskin" }
      Local texts = { "ntext", "htext", "ptext", "dtext" }
      
      ; Rebuild Cache
      Local i, v, k
      For i, v In Pairs(HGui.Gadgets)
        If v.Type = #HGUI_DROPDOWN_GADGET
          ; Skip all custom skin
          If Not(v.Look.IsCustom)
            For k = 0 To 3
              Local skin, text = skins[k], texts[k]
              v.ComboButton.Look[skin] = HGui.Theme.DropDown[skin]
              v.ComboButton.Look[text]:set(HGui.Theme.DropDown[text], True)
            Next
            v.ComboButton:cacheBuild()
            v:cacheBuild()
          EndIf
        EndIf
      Next

    ;::::::::::::::::
    ;::: LISTVIEW :::
    ;::::::::::::::::
    Case #HGUI_LISTVIEW_GADGET
      ;| HGui.Theme.ListView = {}
      ;| HGui.Theme.ListView.OuterBox  = {}
      ;| HGui.Theme.ListView.OuterBox.nSkin
      ;| HGui.Theme.ListView.Body = {}
      ;| HGui.Theme.ListView.Body.nSkin
      ;| HGui.Theme.ListView.TopBox    = {}
      ;| HGui.Theme.ListView.TopBox.nSkin
      ;| HGui.Theme.ListView.Scrollbar = {}
      ;|-- Column headers --
      ;| HGui.Theme.ListView.nSkin
      ;| HGui.Theme.ListView.hSkin
      ;| HGui.Theme.ListView.pSkin
      ;| HGui.Theme.ListView.dSkin
      ;| HGui.Theme.ListView.nText
      ;| HGui.Theme.ListView.hText
      ;| HGui.Theme.ListView.pText
      ;| HGui.Theme.ListView.dText
      ;| HGui.Theme.ListView.ColumnGap
      ;| HGui.Theme.ListView.HeadersHeight
      ;|-- Content's area --
      ;| HGui.Theme.ListView.Font
      ;|   .Name
      ;|   .SizeOffset
      ;|   .Style
      ;|   .Color
      ;| HGui.Theme.ListView.BGColors
      ;|   .odd
      ;|   .even
      ;| HGui.Theme.ListView.Selected
      ;|   .FontColor
      ;|   .BGColor
      ;| HGui.Theme.ListView.EntryHeight
      ;| HGui.Theme.ListView.AlternateLines (new)
      ;| HGui.Theme.ListView.VerticalLines (new)
      ;| HGui.Theme.ListView.VLinesColor1 (new)
      ;| HGui.Theme.ListView.VLinesColor2 (new)
      ;|
      ;|-- Scrollbars --
      ;| HGui.Theme.ListView.Scrollbar.Size
      ;| BELOW CANNOT BE THEMED AT RUNTIME
      ;| HGui.Theme.ListView.Scrollbar.oBox = {}
      ;| HGui.Theme.ListView.Scrollbar.oBox.nSkin
      ;| HGui.Theme.ListView.Scrollbar.oBox.hSkin
      ;| HGui.Theme.ListView.Scrollbar.oBox.pSkin
      ;| HGui.Theme.ListView.Scrollbar.oBox.dSkin
      ;|
      ;|-- Scrollbars Cursor --
      ;| BELOW CANNOT BE THEMED AT RUNTIME
      ;| HGui.Theme.ListView.Scrollbar.cBox = {}
      ;| HGui.Theme.ListView.Scrollbar.cBox.nSkin
      ;| HGui.Theme.ListView.Scrollbar.cBox.hSkin
      ;| HGui.Theme.ListView.Scrollbar.cBox.pSkin
      ;| HGui.Theme.ListView.Scrollbar.cBox.dSkin
      ;| HGui.Theme.ListView.Scrollbar.cBox.nText
      ;| HGui.Theme.ListView.Scrollbar.cBox.hText
      ;| HGui.Theme.ListView.Scrollbar.cBox.pText
      ;| HGui.Theme.ListView.Scrollbar.cBox.dText
      ;|
      ;|-- Cursor's handle --
      ;| BELOW CANNOT BE THEMED AT RUNTIME
      ;| HGui.Theme.ListView.Scrollbar.Handle
      ;|   .normal
      ;|     .color1
      ;|     .color3
      ;|     .color2
      ;|  .hilighted
      ;|     .color1
      ;|     .color3
      ;|     .color2
      ;|  .pushed
      ;|     .color1
      ;|     .color3
      ;|     .color2
      ;|  .disabled
      ;|     .color1
      ;|     .color3
      ;|     .color2
      ;|  .type
      ;|  .quantity
      ;|  .size
      ;|  .gap

      If TB.Item.Exists(Theme, "outerbox")
        If TB.Item.Exists(Theme.OuterBox, "nskin")
          HGui.Theme.ListView.OuterBox.nSkin = Theme.OuterBox.nSkin
        EndIf
      EndIf      
      If TB.Item.Exists(Theme, "body")
        If TB.Item.Exists(Theme.Body, "nskin")
          HGui.Theme.ListView.Body.nSkin = Theme.Body.nSkin
        EndIf
      EndIf
      If TB.Item.Exists(Theme, "topbox")
        If TB.Item.Exists(Theme.TopBox, "nskin")
          HGui.Theme.ListView.TopBox.nSkin = Theme.TopBox.nSkin
        EndIf
      EndIf     
      If TB.Item.Exists(Theme, "nskin") Then HGui.Theme.ListView.nSkin = Nil
      If TB.Item.Exists(Theme, "hskin") Then HGui.Theme.ListView.hSkin = Nil
      If TB.Item.Exists(Theme, "pskin") Then HGui.Theme.ListView.pSkin = Nil
      If TB.Item.Exists(Theme, "dskin") Then HGui.Theme.ListView.dSkin = Nil      
      
      TB.Merge(HGui.Theme.ListView, Theme, True)
      
      Local skins = { "nskin", "hskin", "pskin", "dskin" }
      Local texts = { "ntext", "htext", "ptext", "dtext" }
      
      ; Rebuild Cache
      Local i, v, k, h
      For i, v In Pairs(HGui.Gadgets)
        If v.Type = #HGUI_LISTVIEW_GADGET
          ; Skip all custom skin
          If Not(v.Look.IsCustom)
            v.OuterBox.Look.nSkin = HGui.Theme.ListView.OuterBox.nSkin
            v.OuterBox:cacheBuild()
            v.Body.Look.nSkin = HGui.Theme.ListView.Body.nSkin
            v.Body:cacheBuild()
            v.TopBox.Look.nSkin = HGui.Theme.ListView.TopBox.nSkin
            v.TopBox:cacheBuild()
          
            Local headsCount = ListItems(v.Headers)-1
            For k = 0 To 3
              Local skin, text = skins[k], texts[k]
              ; Column headers
              For h = 0 To headsCount
                Local headButton = v.Headers[h]
                headButton.Look[skin] = HGui.Theme.ListView[skin]
                headButton.Look[text]:set(HGui.Theme.ListView[text], True)
                headButton:cacheBuild()
              Next
            Next
            
            ; Contents area
            If TB.Item.Exists(Theme, "font")
              If TB.Item.Exists(Theme.Font, "name") Then v.FontName = Theme.Font.name
              If TB.Item.Exists(Theme.Font, "name") Then v.FontSizeOffset = Theme.Font.sizeOffset
              If TB.Item.Exists(Theme.Font, "name") Then v.FontStyle = Theme.Font.style
              If TB.Item.Exists(Theme.Font, "name") Then v.FontColor = Theme.Font.color
            EndIf
            
            ; BG Colors
            If TB.Item.Exists(Theme, "bgcolors")
              If TB.Item.Exists(Theme.BGColors, "odd") Then v.ListAreaBG1 = HGui.Theme.ListView.BGColors.Odd
              If TB.Item.Exists(Theme.BGColors, "even") Then v.ListAreaBG2 = HGui.Theme.ListView.BGColors.Even
            EndIf

            ; Selected Colors
            If TB.Item.Exists(Theme, "selected")
              If TB.Item.Exists(Theme.Selected, "fontcolor") Then v.SelectedFontColor = HGui.Theme.ListView.Selected.FontColor
              If TB.Item.Exists(Theme.Selected, "bgcolor") Then v.SelectedListAreaBG = HGui.Theme.ListView.Selected.BGColor
            EndIf
         
            ; Entries height
            If TB.Item.Exists(Theme, "entryheight") Then v.EntryHeight = HGui.Theme.ListView.EntryHeight
         
            ; Alternate Lines
            If TB.Item.Exists(Theme, "alternatelines") Then v.AlternateLines = HGui.Theme.ListView.AlternateLines
            
            ; Vertical Lines
            If TB.Item.Exists(Theme, "verticallines") Then v.VLines = HGui.Theme.ListView.VerticalLines
            If TB.Item.Exists(Theme, "vlinescolor1") Then v.VLinesColor1 = HGui.Theme.ListView.VLinesColor1
            If TB.Item.Exists(Theme, "vlinescolor2") Then v.VLinesColor2 = HGui.Theme.ListView.VLinesColor2
            
            Local rebuildLayout = False
            
            ; Columns
            If TB.Item.Exists(Theme, "columnsgap")
              ;rebuildLayout = True
              v.columnsgap = HGui.Theme.ListView.ColumnsGap
              v.TopBox:layoutSet({ gadgets = v.Headers,
                                   weights = v.Data.ColumnSizes,
                                   gap     = v.ColumnsGap,
                                   type    = #HGUI_HORIZONTAL_LAYOUT,
                                   borders = v.ColumnsBorders })
              v.TopBox:layoutUpdate(True)
            EndIf
            
            If TB.Item.Exists(Theme, "headersheight")
              HGui.Theme.ListView.HeadersHeight = Theme.HeadersHeight
              v.TopBoxSize = Theme.HeadersHeight
              rebuildLayout = True
            EndIf
            
            ; Scrollbars
            If TB.Item.Exists(Theme, "scrollbar")
              If TB.Item.Exists(Theme.Scrollbar, "size") Then v.ScrollerSize = HGui.Theme.ListView.Scrollbar.Size
              rebuildLayout = True
            EndIf
            
            If rebuildLayout
              v:rebuildLayout()
              v:layoutUpdate(True)
            EndIf
            
            v:cacheBuild()
          EndIf
        EndIf
      Next

    ;::::::::::::::::
    ;::: TREEVIEW :::
    ;::::::::::::::::
    Case #HGUI_TREEVIEW_GADGET
      ;| HGui.Theme.TreeView = {}
      ;| HGui.Theme.TreeView.OuterBox  = {}
      ;| HGui.Theme.TreeView.OuterBox.nSkin
      ;| HGui.Theme.TreeView.Body = {}
      ;| HGui.Theme.TreeView.Body.nSkin
      ;| HGui.Theme.TreeView.TopBox    = {}
      ;| HGui.Theme.TreeView.TopBox.nSkin
      ;| HGui.Theme.TreeView.Scrollbar = {}
      ;|-- Column headers --
      ;| HGui.Theme.TreeView.nSkin
      ;| HGui.Theme.TreeView.hSkin
      ;| HGui.Theme.TreeView.pSkin
      ;| HGui.Theme.TreeView.dSkin
      ;| HGui.Theme.TreeView.nText
      ;| HGui.Theme.TreeView.hText
      ;| HGui.Theme.TreeView.pText
      ;| HGui.Theme.TreeView.dText
      ;| HGui.Theme.TreeView.ColumnGap
      ;| HGui.Theme.TreeView.HeadersHeight
      ;|-- Content's area --
      ;| HGui.Theme.TreeView.Font
      ;|   .Name
      ;|   .SizeOffset
      ;|   .Style
      ;|   .Color
      ;| HGui.Theme.TreeView.BGColors
      ;|   .odd
      ;|   .even
      ;| HGui.Theme.TreeView.Selected
      ;|   .FontColor
      ;|   .BGColor
      ;| HGui.Theme.TreeView.EntryHeight
      ;| HGui.Theme.TreeView.AlternateLines (new)
      ;| HGui.Theme.TreeView.VerticalLines (new)
      ;| HGui.Theme.TreeView.VLinesColor1 (new)
      ;| HGui.Theme.TreeView.VLinesColor2 (new)
      ;| HGui.Theme.TreeView.NodeStyle
      ;|
      ;|-- Scrollbars --
      ;| HGui.Theme.TreeView.Scrollbar.Size
      ;| BELOW CANNOT BE THEMED AT RUNTIME
      ;| HGui.Theme.TreeView.Scrollbar.oBox = {}
      ;| HGui.Theme.TreeView.Scrollbar.oBox.nSkin
      ;| HGui.Theme.TreeView.Scrollbar.oBox.hSkin
      ;| HGui.Theme.TreeView.Scrollbar.oBox.pSkin
      ;| HGui.Theme.TreeView.Scrollbar.oBox.dSkin
      ;|
      ;|-- Scrollbars Cursor --
      ;| BELOW CANNOT BE THEMED AT RUNTIME
      ;| HGui.Theme.TreeView.Scrollbar.cBox = {}
      ;| HGui.Theme.TreeView.Scrollbar.cBox.nSkin
      ;| HGui.Theme.TreeView.Scrollbar.cBox.hSkin
      ;| HGui.Theme.TreeView.Scrollbar.cBox.pSkin
      ;| HGui.Theme.TreeView.Scrollbar.cBox.dSkin
      ;| HGui.Theme.TreeView.Scrollbar.cBox.nText
      ;| HGui.Theme.TreeView.Scrollbar.cBox.hText
      ;| HGui.Theme.TreeView.Scrollbar.cBox.pText
      ;| HGui.Theme.TreeView.Scrollbar.cBox.dText
      ;|
      ;|-- Cursor's handle --
      ;| BELOW CANNOT BE THEMED AT RUNTIME
      ;| HGui.Theme.TreeView.Scrollbar.Handle
      ;|   .normal
      ;|     .color1
      ;|     .color3
      ;|     .color2
      ;|  .hilighted
      ;|     .color1
      ;|     .color3
      ;|     .color2
      ;|  .pushed
      ;|     .color1
      ;|     .color3
      ;|     .color2
      ;|  .disabled
      ;|     .color1
      ;|     .color3
      ;|     .color2
      ;|  .type
      ;|  .quantity
      ;|  .size
      ;|  .gap
      
      If TB.Item.Exists(Theme, "outerbox")
        If TB.Item.Exists(Theme.OuterBox, "nskin")
          HGui.Theme.TreeView.OuterBox.nSkin = Theme.OuterBox.nSkin
        EndIf
      EndIf      
      If TB.Item.Exists(Theme, "body")
        If TB.Item.Exists(Theme.Body, "nskin")
          HGui.Theme.TreeView.Body.nSkin = Theme.Body.nSkin
        EndIf
      EndIf
      If TB.Item.Exists(Theme, "topbox")
        If TB.Item.Exists(Theme.TopBox, "nskin")
          HGui.Theme.TreeView.TopBox.nSkin = Theme.TopBox.nSkin
        EndIf
      EndIf     
      If TB.Item.Exists(Theme, "nskin") Then HGui.Theme.TreeView.nSkin = Nil
      If TB.Item.Exists(Theme, "hskin") Then HGui.Theme.TreeView.hSkin = Nil
      If TB.Item.Exists(Theme, "pskin") Then HGui.Theme.TreeView.pSkin = Nil
      If TB.Item.Exists(Theme, "dskin") Then HGui.Theme.TreeView.dSkin = Nil      
      
      TB.Merge(HGui.Theme.TreeView, Theme, True)
      
      Local skins = { "nskin", "hskin", "pskin", "dskin" }
      Local texts = { "ntext", "htext", "ptext", "dtext" }
      
      ; Rebuild Cache
      Local i, v, k, h
      For i, v In Pairs(HGui.Gadgets)
        If v.Type = #HGUI_TREEVIEW_GADGET
          ; Skip all custom skin
          If Not(v.Look.IsCustom)
            v.OuterBox.Look.nSkin = HGui.Theme.TreeView.OuterBox.nSkin
            v.OuterBox:cacheBuild()
            v.Body.Look.nSkin = HGui.Theme.TreeView.Body.nSkin
            v.Body:cacheBuild()
            v.TopBox.Look.nSkin = HGui.Theme.TreeView.TopBox.nSkin
            v.TopBox:cacheBuild()
          
            Local headsCount = ListItems(v.Headers)-1
            For k = 0 To 3
              Local skin, text = skins[k], texts[k]
              ; Column headers
              For h = 0 To headsCount
                Local headButton = v.Headers[h]
                headButton.Look[skin] = HGui.Theme.TreeView[skin]
                headButton.Look[text]:set(HGui.Theme.TreeView[text], True)
                headButton:cacheBuild()
              Next
            Next
            
            ; Contents area
            If TB.Item.Exists(Theme, "font")
              If TB.Item.Exists(Theme.Font, "name") Then v.FontName = Theme.Font.name
              If TB.Item.Exists(Theme.Font, "name") Then v.FontSizeOffset = Theme.Font.sizeOffset
              If TB.Item.Exists(Theme.Font, "name") Then v.FontStyle = Theme.Font.style
              If TB.Item.Exists(Theme.Font, "name") Then v.FontColor = Theme.Font.color
            EndIf
            
            ; BG Colors
            If TB.Item.Exists(Theme, "bgcolors")
              If TB.Item.Exists(Theme.BGColors, "odd") Then v.ListAreaBG1 = HGui.Theme.TreeView.BGColors.Odd
              If TB.Item.Exists(Theme.BGColors, "even") Then v.ListAreaBG2 = HGui.Theme.TreeView.BGColors.Even
            EndIf

            ; Selected Colors
            If TB.Item.Exists(Theme, "selected")
              If TB.Item.Exists(Theme.Selected, "fontcolor") Then v.SelectedFontColor = HGui.Theme.TreeView.Selected.FontColor
              If TB.Item.Exists(Theme.Selected, "bgcolor") Then v.SelectedListAreaBG = HGui.Theme.TreeView.Selected.BGColor
            EndIf
         
            ; Entries height
            If TB.Item.Exists(Theme, "entryheight") Then v.EntryHeight = HGui.Theme.TreeView.EntryHeight
         
            ; Alternate Lines
            If TB.Item.Exists(Theme, "alternatelines") Then v.AlternateLines = HGui.Theme.TreeView.AlternateLines
            
            ; Vertical Lines
            If TB.Item.Exists(Theme, "verticallines") Then v.VLines = HGui.Theme.TreeView.VerticalLines
            If TB.Item.Exists(Theme, "vlinescolor1") Then v.VLinesColor1 = HGui.Theme.TreeView.VLinesColor1
            If TB.Item.Exists(Theme, "vlinescolor2") Then v.VLinesColor2 = HGui.Theme.TreeView.VLinesColor2
            
            ; Node type
            If TB.Item.Exists(Theme, "nodestyle") Then v.OCStyle = HGui.Theme.TreeView.NodeStyle
            
            Local rebuildLayout = False
            
            ; Columns
            If TB.Item.Exists(Theme, "columnsgap")
              ;rebuildLayout = True
              v.columnsgap = HGui.Theme.ListView.ColumnsGap
              v.TopBox:layoutSet({ gadgets = v.Headers,
                                   weights = v.Data.ColumnSizes,
                                   gap     = v.ColumnsGap,
                                   type    = #HGUI_HORIZONTAL_LAYOUT,
                                   borders = v.ColumnsBorders })
              v.TopBox:layoutUpdate(True)
            EndIf
            
            If TB.Item.Exists(Theme, "headersheight")
              HGui.Theme.ListView.HeadersHeight = Theme.HeadersHeight
              v.TopBoxSize = Theme.HeadersHeight
              rebuildLayout = True
            EndIf
            
            ; Scrollbars
            If TB.Item.Exists(Theme, "scrollbar")
              If TB.Item.Exists(Theme.Scrollbar, "size") Then v.ScrollerSize = HGui.Theme.ListView.Scrollbar.Size
              rebuildLayout = True
            EndIf
            
            If rebuildLayout
              v:rebuildLayout()
              v:layoutUpdate(True)
            EndIf
            
            v:cacheBuild()
          EndIf
        EndIf
      Next

    ;::::::::::::::
    ;::: SLIDER :::
    ;::::::::::::::
    Case #HGUI_SLIDER_GADGET
      TB.Set(HGui.Theme.Slider, Theme, False)
      
      Local skins = { "nskin", "hskin", "pskin", "dskin" }
      Local texts = { "ntext", "htext", "ptext", "dtext" }
      
      ; Rebuild Cache
      Local i, v, k
      For i, v In Pairs(HGui.Gadgets)
        If v.Type = #HGUI_SLIDER_GADGET
          ; Skip all custom skin
          If Not(v.Look.IsCustom)
            For k = 0 To 3
              Local skin, text = skins[k], texts[k]
              v.Look.oBox[skin] = HGui.Theme.Slider.oBox[skin]
              v.Look.oBox[text]:set(HGui.Theme.Slider.oBox[text], True)
              v.Look.cBox[skin] = HGui.Theme.Slider.cBox[skin]
              v.Look.cBox[text]:set(HGui.Theme.Slider.cBox[text], True)
            Next
            v:cacheBuild()
          EndIf
        EndIf
      Next

    ;:::::::::::::::
    ;::: VIRTUAL :::
    ;:::::::::::::::
    Case #HGUI_VIRTUAL_GADGET
      TB.Set(HGui.Theme.Virtual, Theme, False)
      
      Local skins = { "nskin", "hskin", "pskin", "dskin" }
      Local texts = { "ntext", "htext", "ptext", "dtext" }
      
      ; Rebuild Cache
      Local i, v, k
      For i, v In Pairs(HGui.Gadgets)
        If v.Type = #HGUI_VIRTUAL_GADGET
          ; Skip all custom skin
          If Not(v.Look.IsCustom)
            v.Look.Container.nSkin = HGui.Theme.Virtual.Container.nSkin
            v.Look.VirtualBox.nSkin = HGui.Theme.Virtual.VirtualBox.nSkin
            For k = 0 To 3
              Local skin, text = skins[k], texts[k]
              v.Look.oBox[skin] = HGui.Theme.Virtual.Scroller.oBox[skin]
              v.Look.cBox[skin] = HGui.Theme.Virtual.Scroller.cBox[skin]
              v.Look.cBox[text]:set(HGui.Theme.Virtual.Scroller.cBox[text], True)
            Next
            v:cacheBuild()
          EndIf
        EndIf
      Next

    ;::::::::::::
    ;::: TEXT :::
    ;::::::::::::
    Case #HGUI_TEXT_GADGET
      TB.Set(HGui.Theme.Text, Theme, False)
      Local skins = { "nskin", "hskin", "pskin", "dskin" }
      
      ; Rebuild Cache
      Local i, v, k
      For i, v In Pairs(HGui.Gadgets)
        If v.Type = #HGUI_TEXT_GADGET
          ; Skip all custom skin
          If Not(v.Look.IsCustom)
            For k = 0 To 3
              Local skin = skins[k]
              v.Look[skin] = HGui.Theme.Text[skin]
            Next
            v:cacheBuild()
          EndIf
        EndIf
      Next
      
    ;::::::::::::::::::::
    ;::: PROGRESS BAR :::
    ;::::::::::::::::::::
    Case #HGUI_PROGRESSBAR_GADGET
      TB.Set(HGui.Theme.Progressbar, Theme, False)
      
      ; Rebuild Cache
      For i, v In Pairs(HGui.Gadgets)
        If v.Type = #HGUI_PROGRESSBAR_GADGET
          ; Skip all custom skin
          If Not(v.Look.IsCustom)
            v.Look.oBox.nSkin = Theme.nSkin
            v.Look.cBox.nSkin = Theme.nSkin
            v.Look.cBox.nText:set(Theme.nText, True)
            v:cacheBuild()
          EndIf
        EndIf
      Next

    ;::::::::::::::
    ;::: SWITCH :::
    ;::::::::::::::
    Case #HGUI_SWITCH_GADGET
      Local skins = { "nskin", "hskin", "pskin", "dskin", "npskin", "hpskin", "dpskin" }
      Local texts = { "ntext", "htext", "ptext", "dtext", "nptext", "hptext", "dptext" }
      TB.Set(HGui.Theme["switch"], Theme, False)
      ; HGui.Theme["switch"] = CopyTable(Theme)
      
      ; Rebuild Cache
      Local i, v, k
      For i, v In Pairs(HGui.Gadgets)
        If v.Type = #HGUI_SWITCH_GADGET
          ; Skip all custom skin
          If Not(v.Look.IsCustom)
            For k = 0 To 6
              Local skin, text = skins[k], texts[k]
              v.Look[skin] = Theme[skin]
              v.Look[text]:set(Theme[text], True)
            Next
            v:cacheBuild()
          EndIf
        EndIf
      Next
      
      
    ;:::::::::::::::::
    ;::: SCROLLBAR :::
    ;:::::::::::::::::
    Case #HGUI_SCROLLBAR_GADGET
    TB.Set(HGui.Theme.Scrollbar, Theme, False)
    ; HGui.Theme.Scrollbar = CopyTable(Theme)
    
    Local skins = { "nskin", "hskin", "pskin", "dskin" }
    Local texts = { "ntext", "htext", "ptext", "dtext" }
    
    ; Rebuild Cache
    Local i, v, k
    For i, v In Pairs(HGui.Gadgets)
      If v.Type = #HGUI_SCROLLBAR_GADGET
        ; Skip all custom skin
        If Not(v.Look.IsCustom)
          v.Cursor.CursorHandle = CopyTable(Theme.Handle)
          For k = 0 To 3
            Local skin, text = skins[k], texts[k]
            v.OuterBox.Look[skin] = Theme.oBox[skin]
            v.Cursor.Look[skin] = Theme.cBox[skin]
            v.Cursor.Look[text]:set(Theme.cBox[text], True)
          Next
          v.OuterBox:cacheBuild()
          v.Cursor:cacheBuild() 
          v:cacheBuild()
        EndIf
      EndIf
    Next

    ;:::::::::::::::::::
    ;::: ALL CLASSES :::
    ;:::::::::::::::::::
    Case #ALL
      /*
        Togliere queste funzioni e utilizzare questa stessa funzione per
        modificare il tema di ogni singolo gadget presente:
        theme = { button =
                    {...},
                  label =
                    {...},
                  ... }
        Cos√¨ posso passare anche parziali
      */
      
      HGui.ThemeGlobal_BoxGadget(Theme)
      HGui.ThemeGlobal_VDividerGadget(Theme)
      HGui.ThemeGlobal_HDividerGadget(Theme)
      HGui.ThemeGlobal_LabelGadget(Theme)
      HGui.ThemeGlobal_GroupGadget(Theme)
      
    Default
      DBG.Console.Out("Gadget class not yet supported! -> " .. ToString(GadgetType), DBG.Warning, HGui.DebugChannel)
      DebugPrompt("---| Hit Enter to continue |---")

  EndSwitch

  If HGui.AutoRendering
    DBG.Console.Out("Refreshing all windows and their gadgets...", Nil, HGui.DebugChannel)
    
    Local i, v
    For i = 0 To ListItems(HGui.Windows)-1
      HGui.Windows[i]:render()
    Next
  EndIf

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
  Return(True)
  
EndFunction


Function HGui.SetQuitOnLastWindow(value) ; *TriDoc*
/******************************************************************************
HGui.SetQuitOnLastWindow(value)

Switch the auto-quit feature on last-window-close ON or OFF.
---------------------------------------------------------------------
INPUT
  Value : TRUE to activate, otherwise FALSE

NOTES
  If this feature is active, when the last opened window is closed the application will be automatically ended.
  If the feature is not active, instead, the application will continue to run without any opened window.
******************************************************************************/
  DBG.Console.Out(".SetQuitOnLastWindow() : " .. ToString(Value), DBG.OpenFunc, HGui.DebugChannel)

  HGui.QuitOnLastWindow = value

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
EndFunction


Function HGui.Theme.WindowBGColor(value) ; *TriDoc*
/******************************************************************************
HGui.Theme.WindowBGColor(value)

Set the default window's background color.
---------------------------------------------------------------------
INPUT
  Value : Color to use as background color for the new windows
---------------------------------------------------------------------
NOTE
  The window background color will be used when new windows are opened using the default background settings (whithout setting the background).
******************************************************************************/
  DBG.Console.Out(".Theme.WindowBGColor() : " .. ToString(Value), DBG.OpenFunc, HGui.DebugChannel)

  HGui.Theme.WindowBG = value

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
EndFunction


Function HGui.Theme.TipsBGColor(value) ; *TriDoc*
/******************************************************************************
HGui.Theme.TipsBGColor(value)

Set the default tip's window background color.
---------------------------------------------------------------------
INPUT
  Value : Color to use as background color for the tip messages
******************************************************************************/
  DBG.Console.Out(".Theme.TipsBGColor() : " .. ToString(Value), DBG.OpenFunc, HGui.DebugChannel)

  HGui.Theme.Tip.BGColor = value

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
EndFunction


/* *****************************************************************************
   CLASS HGui.Window

   Title      : [String] Window's title, default to empty string.
   Name       : [String] Unique window's name, optional.
   Position   : [Table] Window's position table
      x            : [Number] Horizontal coordinate (pixels)
      y            : [Number] Vertical coordinate (pixels)
   Size       : [Table] Window's size table
      w            : [Number] Width (pixels)
      h            : [Number] Height (pixels)
   NativeSize : [Table] PRIVATE. Native GUI resolution.
      w            : [Number] Width (pixels)
      h            : [Number] Height (pixels)
   SizeMax    : [Table] Maximum window's size
      w            : [Number] Width (pixels)
      h            : [Number] Height (pixels)
   SizeMin    : [Table] Minimum window's size
      w            : [Number] Width (pixels)
      h            : [Number] Height (pixels)
   DontOpen   : [Boolean] Don't open the window after creation?
   RootGadget : [Obj:Gadget] Root window's gadget
   Focus      : [Obj:Gadget] Gadget that own the focus
   Flags      : [Table] Window's flags
      Resizeable   : [Boolean] Can be resized?
      Closeable    : [Boolean] Can be closed?
      Moveable     : [Boolean] Can be moved?
      Borderless   : [Boolean] Borderless window?
      Modal        : [Boolean] Modal window?
      Hideable     : [Boolean] Can hide/iconify?
      AutoClose    : [Boolean] Close the window immediatly after have sent the
                               close event?
   Events     : [Table] Callback functions
      OnClose      : [Function] On close event callback function
      OnMove       : [Function] On move event callback function
      OnActivate   : [Function] On activate event callback function
      OnDeactivate : [Function] On deactivate event callback function
      OnHide       : [Function] On hide/iconify event callback function
      OnShow       : [Function] On show/deiconify event callback function
      OnSize       : [Function] On size event callback function
   Private    : [Table] PRIVATE.
      HWId         : [Handle] Hollywood display ID
      Hidden       : [Boolean] Is this window hidden?
      Closed       : [Boolean] Is this window closed?
      BGFile       : [String] Background image file name
      BGId         : [Handle] Hollywood background picture ID
      Events       : [Boolean] Is event detection enabled?
      ActGadList   : [Table] Active gadgets list for keyboard navigation
      IgnoreNxRes  : [Boolean] Used to avoid double resize events
   ****************************************************************************/

HGui.Window = {}
HGui.Window.Title = ""
HGui.Window.Name  = Nil
HGui.Window.Position = {}
HGui.Window.Position.x = #CENTER
HGui.Window.Position.y = #CENTER
HGui.Window.Size = {}
HGui.Window.Size.w = 320
HGui.Window.Size.h = 320
HGui.Window.NativeSize = {}
HGui.Window.NativeSize.w = 320
HGui.Window.NativeSize.h = 240
HGui.Window.SizeMax = {}
HGui.Window.SizeMax.w = 320
HGui.Window.SizeMax.h = 240
HGui.Window.SizeMin = {}
HGui.Window.SizeMin.w = 320
HGui.Window.SizeMin.h = 240
HGui.Window.VSync = False
HGui.Window.DontOpen = False
HGui.Window.CacheRoot = False
HGui.Window.Root = {}
HGui.Window.RootGadget = {}
HGui.Window.Focus = Nil
HGui.Window.Menu = {}
HGui.Window.TopMenu = {}
HGui.Window.Contextual = {}
HGui.Window.Flags = {}
HGui.Window.Flags.Resizeable = True
HGui.Window.Flags.Closeable = True
HGui.Window.Flags.Moveable = True
HGui.Window.Flags.Borderless = False
HGui.Window.Flags.Modal = False
HGui.Window.Flags.Hideable = True
HGui.Window.Flags.AutoClose = True
HGui.Window.Flags.HideFromTaskBar = False
HGui.Window.Events = {}
HGui.Window.Events.OnClose = Function() Return EndFunction
HGui.Window.Events.OnMove  = Function() Return EndFunction
HGui.Window.Events.OnActivate = Function() Return EndFunction
HGui.Window.Events.OnDeactivate = Function() Return EndFunction 
HGui.Window.Events.OnHide = Function() Return EndFunction 
HGui.Window.Events.OnShow = Function() Return EndFunction
HGui.Window.Events.OnSize = Function() Return EndFunction
HGui.Window.IgnoreRMBUp = False
HGui.Window.Private = {}
HGui.Window.Private.HWId = Nil
HGui.Window.Private.Hidden = False
HGui.Window.Private.Closed = False
HGui.Window.Private.BGFile = ""
HGui.Window.Private.BGId = Nil
HGui.Window.Private.Events = True
HGui.Window.Private.ActGadList = {}
HGui.Window.Private.IgnoreNxRes = False
HGui.Window.Private.HotKeys = {}
HGui.Window.Private.HotKeys.hide = Nil
HGui.Window.Private.HotKeys.show = Nil
HGui.Window.Private.HotKeys.activate = Nil
HGui.Window.Private.HotKeys.close = Nil
HGui.Window.Private.HotKeys.open = Nil
HGui.Window.Private.CustomHotKeys = {}

/*
   { Title      = "",
     Name       = Nil,
     Position   = { x = #CENTER, y = #CENTER },
     Size       = { w = 320, h = 240 },
     NativeSize = { w = 320, h = 240 },
     SizeMax    = { w = 320, h = 240 },
     SizeMin    = { w = 320, h = 240 },
     DontOpen   = False,
     CacheRoot  = False,
     Root       = {},
     RootGadget = {},
     Focus      = Nil,
     Menu       = {},
     TopMenu    = {},
     Flags = { Resizeable = True,
               Closeable  = True,
               Moveable   = True,
               Borderless = False,
               Modal      = False,
               Hideable   = True,
               AutoClose  = True },
     Events = { OnClose      = Nil,
                OnMove       = Nil,
                OnActivate   = Nil,
                OnDeactivate = Nil,
                OnHide       = Nil,
                OnShow       = Nil,
                OnSize       = Nil },
     Private = { HWId        = Nil,
                 Hidden      = False,
                 Closed      = False,
                 BGFile      = "",
                 BGId        = Nil,
                 Events      = True,
                 ActGadList  = {},
                 IgnoreNxRes = False }
      }
      */

;------------------------------------------------------------------------------

Function HGui.Window:Move(x, y) ; *TriDoc*
/******************************************************************************
HGui.Window:Move(x, y)

Move the window to the given coordinates
---------------------------------------------------------------------
INPUT
  x : Horizontal position
  y : Vertical position
******************************************************************************/
  Local currentWin = HGui.ActiveWindow
  self:Activate()
  self.position.x = x
  self.position.y = y
  MoveDisplay(x, y)
  currentWin:Activate()

EndFunction

Function HGui.Window._closeSysRequest(event) ; *TriDoc*
/******************************************************************************
HGui.Window._closeSysRequest(event)

Internal function used to close System Requesters.
---------------------------------------------------------------------
INPUT
  event : Event handler data
    id : Display Id

NOTES
  Internal function.
******************************************************************************/
  Local win = HGui.windowFindByHWID(event.id)
  win._globalCallback(win, {}, -1)
  HGui._lastSystemRequestButton = { win, {}, -1 }
  win:Close()
  win:Free()
  
EndFunction

Function HGui.Window._reactivateModalWindow(win) ; *TriDoc*
/******************************************************************************
HGui.Window._reactivateModalWindow(win)

Internal function used to reactivate modal window that lost the focus.
---------------------------------------------------------------------
INPUT
  win : Window object

NOTES
  The window is reactivated only if it is the latest opened modal window otherwise the event will be ignored.
******************************************************************************/
  Local isLast = False
  Local c = ListItems(HGui.Windows)-1
  Local found = -1
  For Local i = 0 To c
    Local w = HGui.Windows[i]
    If w = win
      found = i
    EndIf
    
    If found <> -1 And found <> i
      If w.flags.modal
        ; non √® l'ultima finestra modale! ne ho trovato un'altra!'
        Return()
      EndIf
    EndIf
  Next
  
  ;DebugPrint("DEACTIVATED WINDOW:", win.name)
  For Local i = c To 0 Step -1
    Local w = HGui.Windows[i]
    If w.flags.modal
      ;DebugPrint("ACTIVATING MODAL:", i, w.name)
      w:Activate()
      
      Return()
    EndIf
  Next
  
EndFunction

Function HGui.Window._handleSysRequestButtons(btn) ; *TriDoc*
/******************************************************************************
HGui.Window._handleSysRequestButtons(btn)

Internal function used to manage System Request's buttons.
---------------------------------------------------------------------
INPUT
  btn : Table generated by the event handler
    _onpushed : Optional OnPushed callback function, if present it will be called with the window object, the button object and the button id arguments.
    window : Window object
    _id : Button Id

NOTES
  The System Request will be closed.
******************************************************************************/
  btn.window:Close()
  If TB.Item.Exists(btn.actions, "_onpushed")
    btn.Actions._OnPushed(btn.Window, btn, btn._id)
    
  EndIf
  
  btn.window._globalCallback(btn.Window, btn, btn._id)
  HGui._lastSystemRequestButton = { btn.Window, btn, btn._id }
  btn.window:Free() 
  
EndFunction

Function HGui.Window:SysRequestNew(params) ; *TriDoc*
/******************************************************************************
result = HGui.Window:SysRequestNew(params)

Create a system request window to show messages and let the user interact with the available options.
The requester can work in two modes 'blocking' and 'non-blocking', in both modes button's callbacks and a global callback function can be used to manage the specified buttons.
In 'blocking' mode the code will be blocked until an option is selected and the requester will be threated as a modal window. This mode will return the number of the selected option or -1 if the requester is closed by its close gadget.
---------------------------------------------------------------------
INPUT
  params : A table that defines the window, see :New() method for details. Also these additinal tags are supported:
    name : Unique window name
    icon : Icon file name / Brush id
    blocking : Blocking requester (default True)
    text : Message to show in the requester body.
    wordwrap : wordwrap text, default = False
    buttons : A table composed by subtables, each representing a button with the following format:
              | {
              |   { button-parameters },
              |   ...
              |   }
    align : Text alignment, default = #HGUI_ALIGN_CENTER
    buttonweights : A table with the button weights (optional)
    groupweights : A table with the body & button weights (optional)
    layout : Buttons alignment, one of the following : #HGUI_VERTICAL_LAYOUT, #HGUI_HORIZONTAL_LAYOUT, #HGUI_GRID_LAYOUT
    callback : You can define your callback functions in the buttons parameters or you can use a global callback that will be called with the following parameters:
               - window object
               - button object (Nil if the requester is closed)
               - button number (-1 if the requester is closed)
OUTPUT
  BLOCKING = False
  The callback functions will be executed and will return the window object, the button object and the button number (-1 if the close gadget is pressed).

  BLOCKING = TRUE
  The callback functions will be executed and will return the window object, the button object and the button number (-1 if the close gadget is pressed).
  Also the selected option number will be returned.
  
NOTE
  The input box is closed automatically.
******************************************************************************/
  If TB.Item.IsNil(params, "name")
    Return()
  EndIf
  
  If HGui.windowExists(params.name)
    Local w = HGui.windowFindByName(params.name)
    w:Activate()
    Return()
  EndIf
  
  Local w, h = GFX.GetHostSize()
  If TB.Item.IsNil(params, "size"   ) Then params.size = HGui.Theme.SysRequest.WindowSize
  If TB.Item.IsNil(params, "text"   ) Then params.text = ""
  If TB.Item.IsNil(params, "icon"   ) Then params.icon = ""
  If TB.Item.IsNil(params, "align"  ) Then params.align = #HGUI_ALIGN_CENTER
  If TB.Item.IsNil(params, "buttons") Then params.buttons = { { Caption = "OK" } }
  If TB.Item.IsNil(params, "layout" ) Then params.layout = #HGUI_VERTICAL_LAYOUT
  If TB.Item.IsNil(params, "callback") Then params.callback = Function() EndFunction
  If TB.Item.IsNil(params, "blocking") Then params.blocking = True
  If TB.Item.IsNil(params, "wordwrap") Then params.wordwrap = False

  If TB.Item.Exists(params, "events")
    params.events.onClose = HGui.Window._closeSysRequest
    If params.blocking
    /*
      params.events.OnDeactivate =
        Function(msg)
          Local win = HGui.windowFindByHWID(msg.id)
          win:Activate()
        EndFunction */
    EndIf
  Else
    params.events = { onClose = HGui.Window._closeSysRequest }
    If params.blocking
    /*
      params.events.OnDeactivate =
        Function(msg)
          Local win = HGui.windowFindByHWID(msg.id)
          win:Activate()
        EndFunction */
    EndIf    
  EndIf

  If TB.Item.Exists(params, "flags")
    params.flags.AutoClose = False
    If TB.Item.IsNil(params.flags, "modal")
      params.flags.modal = True
    EndIf
  Else
    params.flags = { AutoClose = False, Modal = True }
  EndIf
  
  Local NewWin = HGui.Window:New(params)
  NewWin.IsSysRequest = True
  
  NewWin._globalCallback = params.callback
  
  ; Setup Layout
  HGui.SetAutoRendering(False)
  NewWin._TGrp = HGui.Gadget:new(#HGUI_BOX_GADGET)
  If params.icon <> "" And IsPicture(params.icon)
    NewWin._TIco = HGui.Gadget:new(#HGUI_IMAGE_GADGET, 
                    { Source  = params.icon, 
                      Alpha   = #NONE, 
                      Mode    = HGui.Theme.SysRequest.imageMode, 
                      Align   = HGui.Theme.SysRequest.imageAlign, 
                      Borders = HGui.Theme.SysRequest.imageBorders })
  Else
    params.icon = ""
  EndIf
  HGui.Theme.SysRequest.nText.Font.Align = params.Align
  HGui.Theme.SysRequest.nText.Wordwrap   = params.Wordwrap
  NewWin._Body = HGui.Gadget:new(#HGUI_LABEL_GADGET, { Caption = params.text, Look = { nSkin = HGui.Theme.SysRequest.nSkin, nText = HGui.Theme.SysRequest.nText } })
  NewWin._Grp  = HGui.Gadget:new(#HGUI_BOX_GADGET)

  ; Buttons
  Local buttons = {}
  For Local i = 0 To ListItems(params.buttons)-1
    
    If TB.Item.IsNil(params.buttons[i], "look")
      params.buttons[i].Look = HGui.Theme.SysRequest.Buttons
    Else
      If TB.Item.IsNil(params.buttons[i].Look, "nskin") Then params.buttons[i].Look.nSkin = HGui.Theme.SysRequest.Buttons.nSkin
      If TB.Item.IsNil(params.buttons[i].Look, "hskin") Then params.buttons[i].Look.hSkin = HGui.Theme.SysRequest.Buttons.hSkin
      If TB.Item.IsNil(params.buttons[i].Look, "pskin") Then params.buttons[i].Look.pSkin = HGui.Theme.SysRequest.Buttons.pSkin
      If TB.Item.IsNil(params.buttons[i].Look, "dskin") Then params.buttons[i].Look.dSkin = HGui.Theme.SysRequest.Buttons.dSkin
      If TB.Item.IsNil(params.buttons[i].Look, "ntext") Then params.buttons[i].Look.nText = HGui.Theme.SysRequest.Buttons.nText
      If TB.Item.IsNil(params.buttons[i].Look, "htext") Then params.buttons[i].Look.hText = HGui.Theme.SysRequest.Buttons.hText
      If TB.Item.IsNil(params.buttons[i].Look, "ptext") Then params.buttons[i].Look.pText = HGui.Theme.SysRequest.Buttons.pText
      If TB.Item.IsNil(params.buttons[i].Look, "dtext") Then params.buttons[i].Look.dText = HGui.Theme.SysRequest.Buttons.dText
    EndIf    
    
    buttons[i] = HGui.Gadget:new(#HGUI_BUTTON_GADGET, params.buttons[i])
    If TB.Item.Exists(buttons[i], "actions")
      If TB.Item.Exists(buttons[i].actions, "onpushed")
        buttons[i].actions._onpushed = buttons[i].actions.onpushed
        buttons[i].actions.onpushed = HGui.Window._handleSysRequestButtons
        buttons[i]._id = i
      Else
        buttons[i].actions.onpushed = HGui.Window._handleSysRequestButtons
        buttons[i]._id = i
      EndIf
    Else
      buttons[i].actions = {}
      buttons[i].actions.onpushed = HGui.Window._handleSysRequestButtons
      buttons[i]._id = i
    EndIf
      
  Next

  Local layout2 = #HGUI_HORIZONTAL_LAYOUT
  Local weights = { 0.80, 0.20 }
  
  If params.layout = #HGUI_VERTICAL_LAYOUT
    layout2 = #HGUI_HORIZONTAL_LAYOUT
    weights = { 0.80, -0.20 }
  Else
    layout2 = #HGUI_VERTICAL_LAYOUT
    weights = { 0.70, -0.30 }
  EndIf
  If TB.Item.Exists(params, "groupweights")
    weights = params.GroupWeights
  EndIf
  
  Local btnw = Nil
  If TB.Item.Exists(params, "buttonweights")
    btnw = params.buttonweights
  EndIf
  
  NewWin._Grp:layoutSet({ gadgets = buttons,
                          weights = btnw,
                          gap = 2,
                          type = layout2,
                          borders = { top = 0, bottom = 0, left = 0, right = 0 } }, True )

  If params.icon = ""
    NewWin._TGrp:layoutSet({ gadgets = { NewWin._Body },
                                  gap = 0,
                                  type = #HGUI_HORIZONTAL_LAYOUT,
                                  borders = { top = 0, bottom = 0, left = 0, right = 0 } }, True )
  Else
    NewWin._TGrp:layoutSet({ gadgets = { NewWin._TIco, NewWin._Body },
                                  weights = { HGui.Theme.SysRequest.iconSize, 1 },
                                  gap = 0,
                                  type = #HGUI_HORIZONTAL_LAYOUT,
                                  borders = { top = 0, bottom = 0, left = 0, right = 0 } }, True )
  EndIf
  
  NewWin.RootGadget:layoutSet({ gadgets = { NewWin._TGrp, NewWin._Grp },
                                weights = weights,
                                gap = 1,
                                type = params.layout,
                                borders = { top = 1, bottom = 1, left = 1, right = 1 } }, True )
  HGui.SetAutoRendering(True)
  
  NewWin:Render()

  If params.blocking
    HGui.ModalWindow = NewWin
    
    While HGui.windowExists(params.name)
      CheckEvent()
      Wait(1, #MILLISECONDS)
    Wend

    HGui.ModalWindow = Nil

    Return(HGui._LastSystemRequestButton[2], HGui._LastSystemRequestButton[1], HGui._LastSystemRequestButton[0])
  
  Else
    Return(NewWin)
  EndIf

EndFunction

Function HGui.Window:textBoxNew(params) ; *TriDoc*
/*---------------------------------------------------------
winObj = HGui.Window:textBoxNew(params)

Creates a new text box window to allow user to read a text and optionally make choices.
-----------------------------------------------------------
INPUT
  params : A table that defines the window, see :New() method for details. Also these additional tags are supported:
    caption        : Optional string to preload the text box with some text caption can also be a file, you can specify the text file name using this format:   ::file::<filename>
    caption_tags   : it's an optional table with pairs (tag, replacer) you can use to replace custom tags with the given text in the specified caption, it works also with text files. Example : { { "$name", "Jhon" }, { "$surname", "Doe" } }
    ok             : Text to put into the 'ok' button
    cancel         : Text to put into the 'cancel' button
    callbackOk     : Callback function called when the 'ok' button is pressed
    callbackCancel : Callback function called when the 'cancel' button is pressed
    callbackClose  : Callback function called when the window is closed
    labellook      : Optional field you can use to override the label(s) look.

OUTPUT
  winObj : The created window object

NOTES
  The callback functions will receive a table with the button object that has been pressed, the button will have the additional fields:
  | result = {
  |   ok       = True if the OK button has been pressed
  |   cancel   = True if the CANCEL button has been pressed
  |   window   = textBox window's structure
  |  }
  If the window is closed the 'result' field is missing, however you will get the window's structure as the second parameter so you can close the window by yourself.
  
  If callback functions are not specified the window will be closed automatically otherwise you have to include the :free() method in your callback function.
  
  OnClose event is not supported because used internally
  
METHODS
  :AppendLine(text) : Used to append text to the TextBox and to automatically scroll down the contents.

INTERNAL NOTES
  win.boxLabel     : The label gadget used to display the text
  win.pwGrpButtons : Box to group 'ok' and 'cancel' buttons
  win.pwGrpTop     : Box to group label gadget and the scrollbar
  win.scrollBar    : The text scrollbar
  win._isTextBox   : Marker to recognize the TextBox window
  win._sourceText  : The non-processed/wrapped text
---------------------------------------------------------*/
  
  ; Check parameters
  If TB.Item.IsNil(params, "size"  )
    Local scrW, scrH = GFX.GetHostSize()
    params.size   = { w = Int(scrW/2), h = Int(scrH/1.5) }
    
  EndIf
  
  If TB.Item.IsNil(params, "text"  ) Then params.text   = ""
  If TB.Item.IsNil(params, "ok"    ) Then params.ok     = "Ok"
  If TB.Item.IsNil(params, "cancel") Then params.cancel = "Cancel"
  
  If TB.Item.IsNil(params, "callbackclose" ) Then params.callbackClose  = Function(msg, win) win:Free() EndFunction
  If TB.Item.IsNil(params, "callbackok"    ) Then params.callbackOk     = Function(msg) msg.Window:Free() EndFunction
  If TB.Item.IsNil(params, "callbackcancel") Then params.callbackCancel = Function(msg) msg.Window:Free() EndFunction
  
  If TB.Item.IsNil(params, "caption_tags") Then params.caption_tags = {}
  
  ; Setup the OnClose event
  If TB.Item.Exists(params, "events")
    params.events.onClose = params.callbackClose
    
  Else
    params.events = { onClose = params.callbackClose }
    
  EndIf
  
  ; Setup window's flags
  If TB.Item.Exists(params, "flags")
    params.flags.AutoClose = False
    
  Else
    params.flags = { AutoClose = False, 
                     Sizeable  = False }
    
  EndIf

  ; Transforms a caption table into a single caption string
  If GetType(params.caption) = #TABLE
    Local t = ""
    For Local ii = 0 To ListItems(params.caption)-1
      t = t .. params.caption[ii] .. "\n"
    Next
    params.caption = t
  EndIf
  
  ; Creates the window
  Local NewWin = HGui.Window:New(params)
   
  ; Setup the layout, a text box on the top and the buttons at the bottom.
  HGui.SetAutoRendering(False)
  
  ; LABEL FOR THE TEXT
  NewWin.boxLabel = HGui.Gadget:new(
    #HGUI_LABEL_GADGET, 
    { caption = { "empty" },
      margins = { top    = 10, 
                  bottom = 10, 
                  left   = 10, 
                  right  = 10 },
      look    = { ntext = 
                  { wordwrap = True, 
                    Font = { align = #HGUI_ALIGN_TOP+#HGUI_ALIGN_LEFT } } }
      })
  ; Overwrite the label look if needed
  If TB.Item.Exists(params, "labellook")
    NewWin.boxLabel:Set({ look = params.labelLook }, False)
  EndIf
  
  
  NewWin.pwGrpButtons = HGui.Gadget:New(#HGUI_BOX_GADGET)
  NewWin.pwGrpTop     = HGui.Gadget:New(#HGUI_BOX_GADGET)


  ; crea i due pulsanti
  ; devo fare in modo che i due pulsanti inviino alla funzione di callback questi campi:
  ;    Ok = True|False
  ;    Cancel = True|False
  ;    Text = <text>
  
  Local btn1 = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":tb:btn1:" .. HL.GetRndName(), Caption = params.ok,     Actions = { OnPushed = params.callbackOk } })
  Local btn2 = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":tb:btn2:" .. HL.GetRndName(), Caption = params.cancel, Actions = { OnPushed = params.callbackCancel } })
  btn1.result = { ok = True, cancel = False, window = NewWin }
  btn2.result = { ok = False, cancel = True, window = NewWin }
  
  ; Build the scrollbar
  NewWin.ScrollBar = HGui.Gadget:new(
    #HGUI_SCROLLBAR_GADGET, 
    { Range       = { 1, ListItems(NewWin.boxLabel.Caption), 1 },
      OnChange    = 
        Function(msg, value)
          NewWin.boxLabel:ScrollTo(value)
        EndFunction,
      Orientation = #HGUI_VERTICAL_LAYOUT,
      Caption     = "" })
  
  NewWin.pwGrpTop:layoutSet(
    { gadgets = { NewWin.boxLabel, NewWin.ScrollBar },
      weights = { 0.99999, 16 },
      gap = 2,
      type = #HGUI_HORIZONTAL_LAYOUT,
      borders = { top = 0, bottom = 0, left = 0, right = 0 } }, True )
  
  NewWin.pwGrpButtons:layoutSet(
    { gadgets = { btn1, btn2 },
      ; weights = { 0.75, 0.25 },
      gap = 2,
      type = #HGUI_HORIZONTAL_LAYOUT,
      borders = { top = 0, bottom = 0, left = 0, right = 0 } }, True )

  Local w2 = (btn1.Look.nText.Font.Size + 16)/NewWin.Size.h
  Local w1 = 1 - w2

  NewWin.RootGadget:layoutSet(
    { gadgets = { NewWin.pwGrpTop, NewWin.pwGrpButtons },
      weights = { w1, w2 },
      gap = 1,
      type = #HGUI_VERTICAL_LAYOUT,
      borders = { top = 1, bottom = 1, left = 1, right = 1 } }, True )

  ; Setup the label contents
  If GetType(params.caption) = #STRING
    If LeftStr(params.caption, 8) = "::file::"
      Local fileName = UnrightStr(params.caption, 8)
      If Exists(fileName)
        params.caption = FileToString(fileName)
        
      Else
        params.caption = "File Not Found : " .. fileName
        
      EndIf
      
    EndIf
    
    ; Replace placeholders
    For i, v In Pairs(params.caption_tags)
      params.caption = ReplaceStr(params.caption, v[0], v[1])
    Next
    
    NewWin._isTextBox  = True
    NewWin._sourceText = params.caption
    params.caption     = GFX.Text.WordWrap(params.caption, NewWin.boxLabel.Area.Size.w - 20 - 32)


  ElseIf GetType(params.caption) = #TABLE
    ; *** TABLES ARE CONVERTED INTO STRINGS ***
    ; Replace placeholders
    For li, lv In Pairs(params.caption)
      For i, v In Pairs(params.caption_tags)
        lv = ReplaceStr(lv, v[0], v[1])
      Next
    Next
  EndIf
  
  ; Compute visible lines and setup the label & scrollbar gadgets
  Local visibleLines = Int((NewWin.boxLabel.Area.Size.h - 20)/NewWin.boxLabel.Look.nText.Font.Size)-1
  NewWin.boxLabel:Set({ caption = params.caption }, True)
  NewWin.ScrollBar:Set({ Value = 1, Range = { 1, ListItems(params.Caption), visibleLines } }, True)
  
  ; Enable the rendering and force a whole refresh
  HGui.SetAutoRendering(True)
  NewWin:Render()
  
  
  
  ;:::::::::::::::
  ;::: METHODS ::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;:::::::::::::::
  
  ; :AppendLine()
  ; -------------
  NewWin.AppendLine = Function(win, text, refresh)
    ; Append 'text' at the bottom and scroll down the contents
    If IsNil(refresh)
      refresh = False
    EndIf
    
    win.boxLabel:AppendLine(text, refresh, refresh)
    win._sourceText = win._sourceText .. "\n" .. text
    Local visibleLines = Int((win.boxLabel.Area.Size.h - 20)/win.boxLabel.Look.nText.Font.Size)-1
    win.ScrollBar:Set({ Value = win.boxLabel.Look.nText.First_Line+1, 
                         Range = { 1, ListItems(win.boxLabel.Caption), visibleLines } }, refresh)
    win.ScrollBar:Render()
    If Not(refresh)
      win.boxLabel:Render()
    EndIf
  EndFunction

  Return(NewWin)

EndFunction

Function HGui.Window:WaiterNew(params) ; *TriDoc*
/*---------------------------------------------------------
winObj = HGui.Window:WaiterNew(params)

Shows an animated wait window with an animation as a busy state indicator.
-----------------------------------------------------------
INPUT
  params : A table with a list of parameters to customize the waiterBox
    text     : Message to show
    freq     : Amination update frequency in ms (default = 100)
    size     : A table with the window size specified in the fields w and h (default = 400x100)
    fg       : Foreground color
    bg       : Background color
    round    : Box rounding value (default = 0 )
    segments : Animated bar's number of segments (default = 16('

OUTPUT
  winObj : The waiterBox window object
---------------------------------------------------------*/
  If TB.Item.IsNil(params, "text"  ) Then params.text = "Please wait..."
  If TB.Item.IsNil(params, "freq"  ) Then params.freq = 100
  If TB.Item.IsNil(params, "segments") Then params.segments = 16
  If TB.Item.IsNil(params, "fg") Then params.fg = $FFFFFF
  If TB.Item.IsNil(params, "bg") Then params.bg = $BB888888
  If TB.Item.IsNil(params, "round") Then params.round = 0
  If TB.Item.IsNil(params, "segments") Then params.segments = 16
  If TB.Item.IsNil(params, "size"  ) Then params.size = { w = 400, h = 100 }
  
  If TB.Item.Exists(params, "flags")
    params.flags.AutoClose = False
    ;params.flags.Modal     = True
    params.flags.Borderless= True
    ;params.flags.Moveable  = False
    
  Else
    params.flags = { AutoClose  = False,
                     Modal      = True,
                     Moveable   = False,
                     Borderless = True }
  EndIf

    
  Local NewWin = HGui.Window:New(params)
  NewWin._waitLen     = params.segments
  NewWin._waitPos     = 0
  NewWin._waitInc     = 1
  NewWin._bg          = params.bg
  NewWin._fg          = params.fg
  NewWin._round       = params.round
  
  NewWin._drawAnim = 
    Function(boxGad, bLen, bPos, bg, fg, round)
      Local x = boxGad.Area.Position.x
      Local y = boxGad.Area.Position.y
      Local w = boxGad.Area.Size.w
      Local h = boxGad.Area.Size.h
      
      Local ws = w/bLen
      SetFillStyle(#FILLCOLOR)
      SetFormStyle(#ANTIALIAS)
      
      Local xx = x
      Box(x, y, w+1, h+1, bg)
      Box(x+ws*bPos, y+1, ws-1, h-2, fg, { RoundLevel = round })
      
    EndFunction
  
  NewWin._waiterUpdateId = 
    SetInterval(Nil,
                Function(msg)            
                  Local winObj = msg.userData
                  winObj:Select()
                  winObj._drawAnim(winObj._waitBox, winObj._waitLen, winObj._waitPos, winObj._bg, winObj._fg, winObj._round)                  
                  winObj._waitPos = winObj._waitPos + winObj._waitInc
                  If winObj._waitPos >= winObj._waitLen-1 Or
                     winObj._waitPos <= 0
                    winObj._waitInc = -winObj._waitInc
                  EndIf
                EndFunction,
                params.freq,
                NewWin)
  
  
  HGui.SetAutoRendering(False)

  NewWin._textGad  = HGui.Gadget:New(#HGUI_LABEL_GADGET, { Caption = params.text,
                                                           Look = { nText = { Wordwrap = True }}})
  NewWin._waitBox = HGui.Gadget:New(#HGUI_BOX_GADGET, { })

  ; Hierarachy setup
  ; ----------------
  NewWin.RootGadget:layoutSet(
    { gadgets = { NewWin._textGad, NewWin._waitBox },
      weights = { 0.75, 0.25 },
      gap     = 0,
      type    = #HGUI_VERTICAL_LAYOUT,
      borders = { top = 0, bottom = 0, left = 0, right = 0 } }, True )
  
  ; Restore autorendering
  ; ---------------------
  HGui.SetAutoRendering(True)
    
  ; Refresh the window
  ; ------------------
  NewWin:Render()

  Return(NewWin)
  
EndFunction

Function HGui.Window:WaiterUpdate(message, fg, bg) ; *TriDoc*
/*---------------------------------------------------------
HGui.Window:WaiterUpdate(message, fg, bg)

Updates a waiterBox changing its text and optionally the background and foreground colors.
-----------------------------------------------------------
INPUT
  message : The new text to display
  fg      : Optional foreground color
  bg      : Optional background color
---------------------------------------------------------*/
  self._textGad:Set({ Caption = message }, True)

  If Not(IsNil(fg))
    self._fg = fg
  EndIf
  
  If Not(IsNil(bg))
    self._bg = bg
  EndIf
  
EndFunction

Function HGui.Window:SoftKeypadNew(params) ; *TriDoc*
/*---------------------------------------------------------
HGui.Window:SoftKeypadNew(params)

Show a softkeyboard to the screen so the user can input numbers using the mouse or the touch screen, input by keyboard is supported.
-----------------------------------------------------------
INPUT
  params : A Table used to customize the soft keypad
    text       : Box description
    callbackOk : Callback function on entered number
    callbackClose : Callback function on requester close
    Decimals   : Flag to allow decimal numbers, default = False
    mathSigns  : Flag to allow maths signs, default = False
    isPassword : Flag to mask password pins, default = False
    generate   : Generate PIN button is showed? default = False
    paste      : Paste button is showed? default = True
    value      : Default value to put into the softpad
    textClear  : Text for the clear button
    textGenerate : Text for the generate button
    textOk     : Text for the ok button
    textPaste  : Text for the paste button
    maxLen     : Max number of digits allowed
    waitInput  : Determines if this is a blocking requester or not.
                - True = Blocking
                - False = Non-Blocking

OUTPUT
  This function always returns the SoftPad window object, but be aware thatin most of the cases it is completely useless because this requester is able to close the window and free the resources by itself when a number is entered
  or when the requester is cancelled.
  The callbackOk function will be called with the entered number.

NOTES

---------------------------------------------------------*/
  ;   +---------------+
  ;===| TYPE : NUMBER |================================================
  ;   +---------------+
  ; +-------------------------+ 
  ; |      value (label)      |
  ; +-------+----------+------|
  ; | Clear | Generate | Paste|
  ; +----+--+-+----+---++-----|
  ; |  / |  * |  - |  + |  <- |
  ; +----+--+-+----+---++-----|
  ; | [ 7 ] [ 8 ] [ 9 ]       |
  ; | [ 4 ] [ 5 ] [ 6 ]       |
  ; | [ 1 ] [ 2 ] [ 3 ] [ Ok] |
  ; | [ . ] [ 0 ] [ _ ]       |
  ; +-------------------------+
  ; | Description             |
  ; +-------------------------+
  If IsNil(params) Then params = {}
  
  If TB.Item.IsNil(params, "size"  ) Then params.size = { w = 400, h = 400 }
  If TB.Item.IsNil(params, "text"  ) Then params.text = "Insert a number"
  If TB.Item.IsNil(params, "callbackclose") Then params.callbackClose = Function() EndFunction
  If TB.Item.IsNil(params, "callbackok")    Then params.callbackOk = Function() EndFunction
  If TB.Item.IsNil(params, "maxlen") Then params.maxlen = 8
  If TB.Item.IsNil(params, "waitinput")     Then params.waitInput = False
  
  If TB.Item.Exists(params, "events")
    params.events.onClose = params.callbackClose
  Else
    params.events = { onClose = params.callbackClose }
  EndIf
  
  If TB.Item.Exists(params, "flags")
    params.flags.AutoClose = False
    params.flags.Modal     = True
  Else
    params.flags = { AutoClose  = False,
                     Modal      = True,
                     Moveable   = False,
                     Borderless = True }
  EndIf

  If TB.Item.IsNil(params, "decimals")   Then params.Decimals = False
  If TB.Item.IsNil(params, "mathsigns")  Then params.mathSigns = False
  If TB.Item.IsNil(params, "ispassword") Then params.isPassword = False
  If TB.Item.IsNil(params, "generate")   Then params.generate = False
  If TB.Item.IsNil(params, "paste")      Then params.paste = True
  If TB.Item.IsNil(params, "textClear")  Then params.textClear = "Clear"
  If TB.Item.IsNil(params, "textGenerate") Then params.textGenerate = "Generate"
  If TB.Item.IsNil(params, "textPaste")  Then params.textPaste = "Paste"
  If TB.Item.IsNil(params, "textOk")     Then params.textOk = "OK"
  If TB.Item.IsNil(params, "value")      Then params.value = ""

  If TB.Item.IsNil(params, "allownewline")
    params.AllowNewLine = False
  EndIf
  If TB.Item.IsNil(params, "entertoclose")
    params.EnterToClose = False
  EndIf
  If TB.Item.IsNil(params, "bgcursor") ; selected bg
    params.BGCursor = $FF00FF
  EndIf
  If TB.Item.IsNil(params, "bgcolor") ; window
    params.BGColor = $DDDDDD
  EndIf  
  If TB.Item.IsNil(params, "adjustfontsize")
    params.AdjustFontSize = True
  EndIf 
  
  Local NewWin = HGui.Window:New(params)
  NewWin._callbackOk = params.callbackOk
  NewWin._waitInput  = params.waitInput
  
  ; Funzione per la gestione dei pulsanti
  NewWin._ParseButton = 
    Function(msg)
      
      ; :: ENTER ::
      ; End input and call <callbackOk> function, then close the pad window
      If LeftStr(msg.name, 10) = ":sp:enter:"
        Local v = NewWin.Code.TextObj:GetText()
        NewWin._callbackOk(v)
        NewWin._waitInput = False
        NewWin:Close()
        NewWin:Free()
      
      ; :: CLEAR ::
      ; Clear all the current input
      ElseIf LeftStr(msg.name, 10) = ":sp:clear:"
        NewWin.Code.TextObj:Set({ text = "" })
        NewWin.Code:Render()
      
      ; :: GENERATE ::
      ; Generate a random number
      ElseIf LeftStr(msg.name, 13) = ":sp:generate:"
        Local t = PadNum(Rnd(999999), 6)
        NewWin.Code.TextObj:Set({ text = t })
        NewWin.Code:Render()
      
      ; :: PASTE ::
      ; Paste from the clipboard
      ElseIf LeftStr(msg.name, 10) = ":sp:paste:"
        Local ctype, cdata = GetClipboard()
        Local t = ""
        If ctype = #CLIPBOARD_TEXT
          ; Leave only digits
          Local n = StrLen(cdata)-1
          For Local i = 0 To n
            Local ch = MidStr(cdata, i, 1)
            If IsDigit(ch) Or ch = "." Or Ch = ","
              t = t .. ch
            EndIf
          Next
          If ToString(ToNumber(t)) = t
            NewWin.Code.TextObj:Set({ text = t })
            NewWin.Code:Render()
          EndIf
          
        EndIf
        
      ; :: DIVISION ::
      ; Add division sign
      ElseIf LeftStr(msg.name, 8) = ":sp:div:"
        Local t = NewWin.Code.TextObj:GetText()
        Local newT = t .. "/"
        NewWin.Code.TextObj:Set({ text = newT })
        NewWin.Code:Render()
        
      ; :: MULTIPLICATION ::
      ; Add multiplication sign
      ElseIf LeftStr(msg.name, 8) = ":sp:mul:"
        Local t = NewWin.Code.TextObj:GetText()
        Local newT = t .. "*"
        NewWin.Code.TextObj:Set({ text = newT })
        NewWin.Code:Render()
        
      ; :: PLUS ::
      ; Add plus sign
      ElseIf LeftStr(msg.name, 9) = ":sp:plus:"
        Local t = NewWin.Code.TextObj:GetText()
        Local newT = t .. "+"
        NewWin.Code.TextObj:Set({ text = newT })
        NewWin.Code:Render()
        
      ; :: MINUS ::
      ; Add division sign
      ElseIf LeftStr(msg.name, 10) = ":sp:minus:"
        Local t = NewWin.Code.TextObj:GetText()
        Local newT = t .. "-"
        NewWin.Code.TextObj:Set({ text = newT })
        NewWin.Code:Render()
        
      ; :: BACKSPACE ::
      ; Remove last char
      ElseIf LeftStr(msg.name, 14) = ":sp:backspace:"
        Local t = NewWin.Code.TextObj:GetText()
        Local l = StrLen(t)
        If l > 0
          t = UnleftStr(t, 1)
          NewWin.Code.TextObj:Set({ text = t })
          NewWin.Code:Render()
        EndIf
        
      Else
        ; :: NUMERIC BUTTONS & DOT ::
        Local num = MidStr(msg.name, 4, 1)

        Local t = NewWin.Code.TextObj:GetText()
        Local newT = t .. num
        NewWin.Code.TextObj:Set({ text = newT })
        NewWin.Code:Render()
        
      EndIf
      
    EndFunction
  
  HGui.SetAutoRendering(False)
  
  ; 1st Row: typed code input box
  NewWin.Code = HGui.Gadget:new(#HGUI_TEXT_GADGET, 
                      { Text = params.value,
                        Gfx = { BgCursor = params.BGCursor, 
                                BgColor  = params.BGColor, 
                                AdjustFontSize = params.AdjustFontSize },
                        AllowNewLine = params.AllowNewLine,
                        AllowedChars = "0123456789/*-+.,",
                        maxLen = params.maxLen,
                        pwdMode = params.isPassword,
                        EnterCloseInput = params.EnterToClose })
  
  ; 2nd Row: actions
  NewWin.grpActions = HGui.Gadget:new(#HGUI_BOX_GADGET)
    ; Clear, Generate & Paste buttons
    NewWin.actClear    = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:clear:" ..    HL.GetRndName(), Caption = params.textClear,    Actions = { OnPushed = NewWin._ParseButton } })
    NewWin.actGenerate = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:generate:" .. HL.GetRndName(), Caption = params.textGenerate, Actions = { OnPushed = NewWin._ParseButton } })
    NewWin.actPaste    = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:paste:" ..    HL.GetRndName(), Caption = params.textPaste,    Actions = { OnPushed = NewWin._ParseButton } })
    
    ; Verifica l'abilitazione di questi pulsanti
     If Not(params.generate) Then NewWin.actGenerate:Disable()
     If Not(params.paste)    Then NewWin.actPaste:Disable()

  ; 3rd Row: Signs
  NewWin.grpSigns = HGui.Gadget:new(#HGUI_BOX_GADGET)
    NewWin.signDiv   = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:div:" ..       HL.GetRndName(), Caption = "/",  Actions = { OnPushed = NewWin._ParseButton } })
    NewWin.signMul   = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:mul:" ..       HL.GetRndName(), Caption = "*",  Actions = { OnPushed = NewWin._ParseButton } })
    NewWin.signPlus  = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:plus:" ..      HL.GetRndName(), Caption = "+",  Actions = { OnPushed = NewWin._ParseButton } })
    NewWin.signMinus = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:minus:" ..     HL.GetRndName(), Caption = "-",  Actions = { OnPushed = NewWin._ParseButton } })
    NewWin.backspace = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:backspace:" .. HL.GetRndName(), Caption = "<-", Actions = { OnPushed = NewWin._ParseButton } })
  
    ; Verifica se disabilitare i segno matematici
    If Not(params.mathSigns)
      NewWin.signDiv:Disable()
      NewWin.signMul:Disable()
      NewWin.signPlus:Disable()
      NewWin.signMinus:Disable()
    EndIf
    
  ; 4th Row: Numbers + Ok
  NewWin.grpPad = HGui.Gadget:new(#HGUI_BOX_GADGET)
    NewWin.grpNumbers = HGui.Gadget:new(#HGUI_BOX_GADGET)
      NewWin.Seven      = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:7:" .. HL.GetRndName(), Caption = "7", Actions = { OnPushed = NewWin._ParseButton } })    
      NewWin.Eight      = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:8:" .. HL.GetRndName(), Caption = "8", Actions = { OnPushed = NewWin._ParseButton } })
      NewWin.Nine       = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:9:" .. HL.GetRndName(), Caption = "9", Actions = { OnPushed = NewWin._ParseButton } })    
      NewWin.Four       = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:4:" .. HL.GetRndName(), Caption = "4", Actions = { OnPushed = NewWin._ParseButton } })    
      NewWin.Five       = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:5:" .. HL.GetRndName(), Caption = "5", Actions = { OnPushed = NewWin._ParseButton } })
      NewWin.Six        = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:6:" .. HL.GetRndName(), Caption = "6", Actions = { OnPushed = NewWin._ParseButton } })    
      NewWin.One        = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:1:" .. HL.GetRndName(), Caption = "1", Actions = { OnPushed = NewWin._ParseButton } })    
      NewWin.Two        = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:2:" .. HL.GetRndName(), Caption = "2", Actions = { OnPushed = NewWin._ParseButton } })
      NewWin.Three      = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:3:" .. HL.GetRndName(), Caption = "3", Actions = { OnPushed = NewWin._ParseButton } })    
      NewWin.Dot        = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:.:" .. HL.GetRndName(), Caption = ".", Actions = { OnPushed = NewWin._ParseButton } })    
      NewWin.Zero       = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:0:" .. HL.GetRndName(), Caption = "0", Actions = { OnPushed = NewWin._ParseButton } })
      NewWin.Space      = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp: :" .. HL.GetRndName(), Caption = " ", Actions = { OnPushed = Function() EndFunction } })    
      
      ; Se i decimali sono zero il punto non serve
      If Not(params.Decimals) Then NewWin.Dot:Disable()
      
      ; Lo spazio per adesso non serve
      NewWin.Space:Disable()
      
    NewWin.Enter      = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:enter:" .. HL.GetRndName(), Caption = params.textOk, Actions = { OnPushed = NewWin._ParseButton } })
  
  ; 5th Row: Caption
  NewWin.Caption = HGui.Gadget:New(#HGUI_LABEL_GADGET, { Caption = params.text })
  
  ; Layout
  NewWin.RootGadget:layoutSet({ gadgets = { NewWin.Code, NewWin.grpActions, NewWin.grpSigns, NewWin.grpPad, NewWin.Caption },
                                weights = { 0.15, 0.10, 0.10, 0.54, 0.11 },
                                gap = 1,
                                type = #HGUI_VERTICAL_LAYOUT,
                                borders = { top = 1, bottom = 1, left = 1, right = 1 } }, True )
                                
  NewWin.grpActions:layoutSet({ gadgets = { NewWin.actClear, NewWin.actGenerate, NewWin.actPaste },
                                weights = { 0.25, 0.50, 0.25 },
                                gap = 2,
                                type = #HGUI_HORIZONTAL_LAYOUT,
                                borders = { top = 2, bottom = 2, left = 1, right = 1 } }, True )

  NewWin.grpSigns:layoutSet({ gadgets = { NewWin.signDiv, NewWin.signMul, NewWin.signPlus, NewWin.signMinus, NewWin.Backspace },
                                weights = { 0.20, 0.20, 0.20, 0.20, 0.20 },
                                gap = 2,
                                type = #HGUI_HORIZONTAL_LAYOUT,
                                borders = { top = 2, bottom = 2, left = 1, right = 1 } }, True )

  NewWin.grpPad:layoutSet({ gadgets = { NewWin.grpNumbers, NewWin.Enter },
                                weights = { 0.80, 0.20 },
                                gap = 0,
                                type = #HGUI_HORIZONTAL_LAYOUT,
                                borders = { top = 0, bottom = 0, left = 0, right = 0 } }, True )

  NewWin.grpNumbers:layoutSet({ gadgets = { NewWin.Seven, NewWin.Eight, NewWin.Nine,
                                            NewWin.Four, NewWin.Five, NewWin.Six,
                                            NewWin.One, NewWin.Two, NewWin.Three,
                                            NewWin.Dot, NewWin.Zero, NewWin.Space },
                                ;weights = { },
                                gap = 3,
                                columns = 3,
                                type = #HGUI_GRID_LAYOUT,
                                borders = { top = 2, bottom = 2, left = 2, right = 2 } }, True )

  ; Auto size fonts
  NewWin.Zero:adaptFontSize()
  NewWin.One:adaptFontSize()
  NewWin.Two:adaptFontSize()
  NewWin.Three:adaptFontSize()
  NewWin.Four:adaptFontSize()
  NewWin.Five:adaptFontSize()
  NewWin.Six:adaptFontSize()
  NewWin.Seven:adaptFontSize()
  NewWin.Eight:adaptFontSize()
  NewWin.Nine:adaptFontSize()
  NewWin.Dot:adaptFontSize()
  NewWin.Enter:adaptFontSize()
  NewWin.signDiv:adaptFontSize()
  NewWin.signMul:adaptFontSize()
  NewWin.signPlus:adaptFontSize()
  NewWin.signMinus:adaptFontSize()
  NewWin.backspace:adaptFontSize()

  HGui.SetAutoRendering(True)
  
  NewWin:Render()

  While NewWin._waitInput
    CheckEvent()
    Wait(1, #MILLISECONDS)
  Wend
  
  Return(NewWin)
  
EndFunction

Function HGui.Window:SoftKeyboardNew(params) ; *TriDoc*
/*---------------------------------------------------------
HGui.Window:SoftKeyboardNew(params)

Show a softkeyboard to the screen so the user can input text using the mouse or the touch screen, input by keyboard is supported.
-----------------------------------------------------------
INPUT
  params : A Table used to customize the soft keypad
    text          : Box description
    callbackOk    : Callback function on entered text
    callbackClose : Callback function on requester close
    isPassword    : Flag to mask password strings, default = False
    pasteBtn      : Paste button is available? Default = True
    copyBtn       : Copy button is available? Default = True
    value         : Default value
    textCopy      : Text for the copy button
    textPaste     : Text for the paste button
    textOk        : Text for the ok button
    textCancel    : Text for the cancel button
    textClear     : Text for the clear button
    textCountry   : Text for the country button
    maxLen        : Max string length
    waitInput     : If TRUE the requester is blocking
    configPath    : Path where to load/save the configuration file (layout, language, character set, ecc...)
    font          : Font to be used for the keyboard (needed for all the symbols and foreign characters)
    allowNewLine  : Flag to allow or not new lines
    enterToClose  : Flag to close the requester with the enter key/button
    adjustFontSize : Flag to adjust the font size to the button size automatically

OUTPUT
  This function always returns the SoftKeyboard window object, but be aware that in most of the cases it is completely useless because this requester is able to close the window and free the resources by itself when a text is entered or when the requester is cancelled.
  The callbackOk function will be called with the entered text.

NOTES

---------------------------------------------------------*/
  ; ------------------------------------------------------------------------
  ; La configurazione viene cercata nella cartella corrente oppure
  ; nella cartella indicata da configPath, con il nome softkey.config
  ; che ha il seguente formato.
  ; - Language : Country Code
  ;   >> https://russian.typeit.org <<
  ;   - Italian     √†√®√©√¨√≤√≥√π‚Ç¨            ‚Äô‚Äú‚Äù¬´¬ª‚Äì
  ;   - En
  ;   - German      √§√∂√º√ü‚Ç¨               ‚Äô‚Äû‚Äú¬´¬ª‚Äú‚Äù‚Äì‚Äî
  ;   - French      √†√¢√¶√ß√©√®√™√´√Ø√Æ√¥≈ì√π√ª√º√ø‚Ç¨   ‚Äô‚Äú‚Äù¬´  ¬ª‚Äì‚Äî
  ;   - Czech       √°ƒçƒè√©ƒõ√≠≈à√≥≈ô≈°≈•√∫≈Ø√Ω≈æ‚Ç¨    ‚Äô‚Äû‚Äú‚Äú‚Äù‚Äì‚Äî
  ;   - Danish      √•√¶√©√∏                ‚Äô‚Äû‚Äú¬ª¬´‚Äú‚Äù‚Äì‚Äî
  ;   - Dutch       √©√´√Ø√≥√∂√º‚Ç¨             ‚Äô‚Äû‚Äù‚Äú‚Äù‚Äì‚Äî
  ;   - Finnish     √§√•√∂‚Ç¨                ‚Äô‚Äù¬ª‚Äú‚Äù‚Äì‚Äî
  ;   - Greek       Œ∏œâŒµœÅœÑœàœÖŒπŒøœÄ
  ;                  Œ±œÉŒ¥œÜŒ≥Œ∑œÇŒ∫Œª
  ;                   Œ∂œáŒæœâŒ≤ŒΩŒº
  ;                 Œ¨Œ≠ŒÆŒØœäŒêœåœçœãŒ∞œé‚Ç¨        ‚Äô‚Äú‚Äù¬´¬ª‚Äì‚Äî
  ;   - Hungarian   √°√©√≠√∂√≥≈ë√º√∫≈±           ‚Äô‚Äû‚Äù‚Äú‚Äù‚Äì
  ;   - Icelandic   √°√¶√∞√©√≠√≥√∂√æ√∫√Ω          ‚Äô‚Äû‚Äú‚Äú‚Äù‚Äì‚Äî
  ;   - Maori       ƒÅƒìƒ´≈ç≈´               ‚Äô‚Äú‚Äù‚Äì‚Äî
  ;   - Norvegian   √•√¶√¢√©√®√™√∏√≥√≤√¥          ‚Äô¬´¬ª‚Äú‚Äù‚Äì‚Äî
  ;   - Polish      ƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º‚Ç¨          ‚Äô‚Äû‚Äù‚Äú‚Äù‚Äì‚Äî
  ;   - Portuguese  √£√°√†√¢√ß√©√™√≠√µ√≥√¥√∫√º‚Ç¨      ‚Äô‚Äú‚Äù¬´¬ª‚Äì‚Äî
  ;   - Romanian    ƒÉ√¢√Æ»ô≈ü»õ≈£‚Äì‚Äî           ‚Äô‚Äû‚Äù¬´¬ª‚Äú‚Äù
  ;
  ; Mappatura interna
  ;   Map
  ;     Language (Italian/English/...)
  ;       keys (R1C1/R1C2/...)
  ;         State (Normal/Shift/Symbol1/Symbol2)
  ;           Character (a/b/c/...)
  ;   MapNum  Mappa in numeric mode
  ;
  ; +---------------------------------------------------+
  ; | Description                                       |  1: Label
  ; +---------------------------------------------------+
  ; | text field                                        |  2: InputBox 
  ; +---------------------------------------------------+
  ; | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 | + | - |<==| 13: Pulsanti
  ; |---------------------------------------------------|
  ; |CAP| Q | W | E | R | T | Y | U | I | O | / | * |NUM| 13: pulsanti
  ; |---------------------------------------------------|
  ; |SHF| A | S | D | F | G | H | J | K | L |SY2| ENTER | 12: Pulsanti
  ; |---------------------------------------------------|
  ; |SY1| @ | Y | X | C | V | B | N | M | , | . |CPY|PST| 11: Pulsanti, 1: Switch
  ; +---------------------------------------------------+
  ; |CFG| # |            SPACE          | <-|-> | CLOSE |  6: Pulsanti
  ; +---------------------------------------------------+
  ;
  ; CLR : Ripulisce il text box
  ; NUM : Passa alla modalit√† numerica con tutti i simboli
  ;       relativi.
  ; SY1 : Simboli 1
  ; SY2 : Simboli 2
  ; SHIFT : Maiuscolo/Minuscolo
  ; CPY : Copy
  ; PST : Paste
  ; CFG : Configurazione
  ; <-  : Cursore a sinistra
  ; ->  : Cursore a destra
  ; CLOSE : Annulla il resquester
  ; SPACE : Spazio
  
  ; NUMERIC MODE
  ; +---------------------------------------------------+
  ; | Description                                       |  1: Label
  ; +---------------------------------------------------+
  ; | text field                                        |  2: InputBox 
  ; +---------------------------------------------------+
  ; |   | ¬£ | $ | ‚Ç¨ | ( | ) |   | 7 | 8 | 9 | + | - |<==| 13: Pulsanti
  ; |---------------------------------------------------|
  ; |CLR|   | & | ¬∞ | { | } |   | 4 | 5 | 6 | / | * |KEY| 13: pulsanti
  ; |---------------------------------------------------|
  ; |   |   |   | ! | ? | % |   | 3 | 2 | 1 | = | ENTER | 12: Pulsanti
  ; |---------------------------------------------------|
  ; |       |   |   | @ | # |   | , | 0 | . | ^ |CPY|PST| 11: Pulsanti, 1: Switch
  ; +---------------------------------------------------+
  ; |CFG| / |            SPACE          | <-|-> | CLOSE |  6: Pulsanti
  ; +---------------------------------------------------+
  
  If IsNil(params) Then params = {}
  
  If TB.Item.IsNil(params, "font") Then font = #SANS
  If TB.Item.IsNil(params, "size") Then params.size = { w = 600, h = 300 }
  If TB.Item.IsNil(params, "callbackok") Then params.callbackok = Function() EndFunction
  If TB.Item.IsNil(params, "callbackclose") Then params.callbackclose = Function() EndFunction
  If TB.Item.IsNil(params, "ispassword") Then params.isPassword = False
  If TB.Item.IsNil(params, "pastebtn") Then params.pastebtn = True
  If TB.Item.IsNil(params, "copybtn") Then params.copybtn = True
  If TB.Item.IsNil(params, "value") Then params.value = ""
  If TB.Item.IsNil(params, "textcopy") Then params.textCopy = " Cpy "
  If TB.Item.IsNil(params, "textpaste") Then params.textPaste = " Pst "
  If TB.Item.IsNil(params, "textok") Then params.textOk = "Ok"
  If TB.Item.IsNil(params, "textcancel") Then params.textCancel = "Cancel"
  If TB.Item.IsNil(params, "textclear") Then params.textClear = "Clear"
  If TB.Item.IsNil(params, "textcountry") Then params.textCountry = "Country"
  If TB.Item.IsNil(params, "text") Then params.text = "Type your text..."
  If TB.Item.IsNil(params, "maxlen") Then params.maxLen = 128
  If TB.Item.IsNil(params, "waitinput") Then params.waitInput = False
  If TB.Item.IsNil(params, "configpath") Then params.configPath = ""
  
  If TB.Item.IsNil(params, "allownewline")
    params.AllowNewLine = False
  EndIf
  If TB.Item.IsNil(params, "entertoclose")
    params.EnterToClose = False
  EndIf
  ;If TB.Item.IsNil(params, "bgcursor") ; selected bg
  ;  params.BGCursor = $FF00FF
  ;EndIf
  ;If TB.Item.IsNil(params, "bgcolor") ; window
  ;  params.BGColor = $DDDDDD
  ;EndIf  
  If TB.Item.IsNil(params, "adjustfontsize")
    params.AdjustFontSize = True
  EndIf 

  Local NewWin = HGui.Window:New(params)
  NewWin._callbackOk = params.callbackOk
  NewWin._callbackClose = params.callbackClose
  NewWin._waitInput  = params.waitInput
  NewWin._isShifted  = False
  NewWin._isAlted    = False
  NewWin._isNormal   = True
  NewWin._isConfig   = False
  
  ; In questo file per adesso c'√® una tabella con i campi
  ;   .language       Indica la tastiera da adottare (o l'ultima selezionata)
  NewWin._configFile = FullPath(params.configPath, "hgui.softkeyboard")
  If Exists(NewWin._configFile)
    ; Lo carica
    Local fid = OpenFile(Nil, NewWin._configFile, #MODE_READ)
    NewWin._configuration = ReadTable(fid)
    CloseFile(fid)
  EndIf
  
  ; Check for default configuration
  If TB.Item.IsNil(NewWin, "_configuration")
    NewWin._configuration =
      { language = "english" }
  EndIf
  
  ; Semplice funzione per scrivere la configurazione
  NewWin._saveConfig = Function()
                         Local fid = OpenFile(Nil, NewWin._configFile, #MODE_WRITE)
                         WriteTable(fid, NewWin._configuration)
                         CloseFile(fid)
                       EndFunction
                       
  Local c = "[Color=$0000FF]"
  Local textCopy  = params.textCopy
  Local textPaste = params.textPaste
  
  ; Mappe dei pulsanti
  Local configMap =         
    { R0 =
      { "IT", "EN", "DE",  "FR",  "",  "",  "",  "",  "",  "",  "",  "", c .. "‚¨Ö" },
      R1 =
      {   "",   "",  "",  "",  "",  "",  "",  "",  "",  "",  "",  "", c .. "√ó" },
      R2 =
      {   "",  "",  "",  "",  "",  "",  "",  "",  "",  "",  "",  "", c .. "‚èé" },
      R3 =
      {  "",  "",  "",  "",  "",  "",  "",  "",  "",  "",  "", c .. textCopy, c .. textPaste },
      R4 =
      { c .. "‚¨Ü", c .. "‚öôÔ∏è", " ", c .. " NRM ", c .. "‚Üê", c .. "‚Üí", c .. " CLOSE"}
      }

  
  NewWin.Keymap = 
    { italian =
      { normal =
        { R0 =
          { "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "'", "√¨", c .. "‚¨Ö" },
          R1 =
          { "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "√®", "+", c .. "√ó" },
          R2 =
          { "a", "s", "d", "f", "g", "h", "j", "k", "l", "√≤", "√†", "√π", c .. "‚èé" },
          R3 =
          { "<", "z", "x", "c", "v", "b", "n", "m", ",", ".", "-", c .. textCopy, c .. textPaste },
          R4 =
          { c .. "‚¨Ü", c .. "‚öôÔ∏è", " ", c .. "  ALT ", c .. "‚Üê", c .. "‚Üí", c .. " CLOSE"}
          },
        shifted =
        { R0 =
          { "!", "\"", "¬£", "$", "%", "&", "/", "(", ")", "=", "?", "^", c .. "‚¨Ö" },
          R1 =
          { "Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P", "√©", "*", c .. "√ó" },
          R2 =
          { "A", "S", "D", "F", "G", "H", "J", "K", "L", "√ß", "¬∞", "¬ß", c .. "‚èé" },
          R3 =
          { ">", "Z", "X", "C", "V", "B", "N", "M", ";", ":", "_", c .. textCopy, c .. textPaste },
          R4 =
          { c .. "‚¨áÔ∏è", c .. "‚öôÔ∏è", " ", c .. "  ALT ", c .. "‚Üê", c .. "‚Üí", c .. " CLOSE"}
          },
          
        alted =
        { R0 =
          { "@", "#", "‚Ç¨",  "",  "",  "",  "", "{", "}", "(", ")",  "", c .. "‚¨Ö" },
          R1 =
          {  "",  "", "√à",  "",  "",  "", "√ô", "√å", "√í",  "", "√â",  "", c .. "√ó" },
          R2 =
          { "√Ä",  "",  "",  "",  "",  "",  "",  "",  "", "√ì", "√≥",  "", c .. "‚èé" },
          R3 =
          { "Àú", "¬±", "¬¢", "¬•", "∆í", "¬§", "¬´", "¬ª", "‚Ä∞", "¬©", "¬Æ", c .. textCopy, c .. textPaste },
          R4 =
          { c .. "‚¨Ü", c .. "‚öôÔ∏è", " ", c .. " NRM ", c .. "‚Üê", c .. "‚Üí", c .. " CLOSE"}
          },        

        config = configMap
        },
      
      ;----------------------
      english =
      { normal =
        { R0 =
          { "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=", c .. "‚¨Ö" },
          R1 =
          { "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "{", "}", c .. "√ó" },
          R2 =
          { "a", "s", "d", "f", "g", "h", "j", "k", "l", "`", ";", "'", c .. "‚èé" },
          R3 =
          { "<", "z", "x", "c", "v", "b", "n", "m", ",", ".", "/", c .. textCopy, c .. textPaste },
          R4 =
          { c .. "‚¨Ü", c .. "‚öôÔ∏è", " ", c .. "  ALT ", c .. "‚Üê", c .. "‚Üí", c .. " CLOSE"}
          },
        shifted =
        { R0 =
          { "~", "!", "@", "#", "$", "%", "^", "&", "*", "(", ")", "_", c .. "‚¨Ö" },
          R1 =
          { "Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P", "+", "|", c .. "√ó" },
          R2 =
          { "A", "S", "D", "F", "G", "H", "J", "K", "L", ":", "\"", "@", c .. "‚èé" },
          R3 =
          { ">", "Z", "X", "C", "V", "B", "N", "M", "?", "-", "/", c .. c .. textCopy, c .. textPaste },
          R4 =
          { c .. "‚¨áÔ∏è", c .. "‚öôÔ∏è", " ", c .. "  ALT ", c .. "‚Üê", c .. "‚Üí", c .. " CLOSE"}
          },
          
        alted =
        { R0 =
          { "@", "#", "‚Ç¨",  "",  "",  "",  "", "{", "}", "(", ")",  "", c .. "‚¨Ö" },
          R1 =
          {  "",  "",  "",  "",  "",  "",  "",  "",  "",  "",  "",  "", c .. "√ó" },
          R2 =
          {  "",  "",  "",  "",  "",  "",  "",  "",  "",  "",  "",  "", c .. "‚èé" },
          R3 =
          { "Àú", "¬±", "¬¢", "¬•", "∆í", "¬§", "¬´", "¬ª", "‚Ä∞", "¬©", "¬Æ", c .. textCopy, c .. textPaste },
          R4 =
          { c .. "‚¨Ü", c .. "‚öôÔ∏è", " ", c .. " NRM ", c .. "‚Üê", c .. "‚Üí", c .. " CLOSE"}
          },        

        config = configMap },
        
      ;----------------------
      german =
      { normal =
        { R0 =
          { "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "√ü", "=", c .. "‚¨Ö" },
          R1 =
          { "q", "w", "e", "r", "t", "z", "u", "i", "o", "p", "√º", "+", c .. "√ó" },
          R2 =
          { "a", "s", "d", "f", "g", "h", "j", "k", "l", "√∂", "√§", "'", c .. "‚èé" },
          R3 =
          { "<", "y", "x", "c", "v", "b", "n", "m", ",", ".", "-", c .. textCopy, c .. textPaste },
          R4 =
          { c .. "‚¨Ü", c .. "‚öôÔ∏è", " ", c .. "  ALT ", c .. "‚Üê", c .. "‚Üí", c .. " CLOSE"}
          },
        shifted =
        { R0 =
          { "¬∞", "!", "\"", "¬ß", "$", "%", "&", "/", "(", ")", "=", "?", c .. "‚¨Ö" },
          R1 =
          { "Q", "W", "E", "R", "T", "Z", "U", "I", "O", "P", "√ú", "*", c .. "√ó" },
          R2 =
          { "A", "S", "D", "F", "G", "H", "J", "K", "L", "√ñ", "√Ñ", "@", c .. "‚èé" },
          R3 =
          { ">", "Y", "X", "C", "V", "B", "N", "M", ";", ":", "-", c .. textCopy, c .. textPaste },
          R4 =
          { c .. "‚¨áÔ∏è", c .. "‚öôÔ∏è", " ", c .. "  ALT ", c .. "‚Üê", c .. "‚Üí", c .. " CLOSE"}
          },
          
        alted =
        { R0 =
          { "@", "#", "‚Ç¨",  "",  "",  "",  "", "{", "}", "(", ")",  "", c .. "‚¨Ö" },
          R1 =
          { "√â", "√ö", "√ç", "√ì", "√Å", "√ù",  "",  "",  "",  "",  "", "Àú", c .. "√ó" },
          R2 =
          { "√®", "√π", "√¨", "√≥", "√°",  "",  "", "¬µ",  "",  "",  "",  "", c .. "‚èé" },
          R3 =
          { "Àú", "¬±", "¬¢", "¬•", "∆í", "¬§", "¬´", "¬ª", "‚Ä∞", "¬©", "¬Æ", c .. textCopy, c .. textPaste },
          R4 =
          { c .. "‚¨Ü", c .. "‚öôÔ∏è", " ", c .. " NRM ", c .. "‚Üê", c .. "‚Üí", c .. " CLOSE"}
          },        

        config = configMap },
        
      ;----------------------
      french =
      { normal =
        { R0 =
          { "&", "√©", "\"", "'", "(", "-", "√®", "_", "√ß", "√†", ")", "=", c .. "‚¨Ö" },
          R1 =
          { "a", "z", "e", "r", "t", "y", "u", "i", "o", "p", "^", "$", c .. "√ó" },
          R2 =
          { "q", "s", "d", "f", "g", "h", "j", "k", "l", "m", "√π", "¬≤", c .. "‚èé" },
          R3 =
          { "<", "w", "x", "c", "v", "b", "n", ",", ";", ":", "!", c .. textCopy, c .. textPaste },
          R4 =
          { c .. "‚¨Ü", c .. "‚öôÔ∏è", " ", c .. "  ALT ", c .. "‚Üê", c .. "‚Üí", c .. " CLOSE"}
          },
        shifted =
        { R0 =
          { "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "¬∞", "+", c .. "‚¨Ö" },
          R1 =
          { "A", "Z", "E", "R", "T", "Y", "U", "I", "O", "P", "¬£", "¬µ", c .. "√ó" },
          R2 =
          { "Q", "S", "D", "F", "G", "H", "J", "K", "L", "M", "%", "-", c .. "‚èé" },
          R3 =
          { ">", "W", "X", "C", "V", "B", "N", "?", ".", "/", "*", c .. textCopy, c .. textPaste },
          R4 =
          { c .. "‚¨áÔ∏è", c .. "‚öôÔ∏è", " ", c .. "  ALT ", c .. "‚Üê", c .. "‚Üí", c .. " CLOSE"}
          },
          
        alted =
        { R0 =
          { "√É", "√£", "√Ä", "√†", "√í", "√≤", "|", "{", "}", "(", ")", "@", c .. "‚¨Ö" },
          R1 =
          { "√ï", "√µ", "√à", "√®", "√Ñ", "√§", "√ú", "√º", "√∂", "√Ç", "√¢", "√é", c .. "√ó" },
          R2 =
          { "√ë", "√±", "√ô", "√π", "√ã", "√´", "√è", "√Ø", "√∂", "√ä", "√™", "√Æ", c .. "‚èé" },
          R3 =
          { "Àú", "¬±", "√å", "√¨", "√î", "√¥", "¬´", "¬ª", "‚Ä∞", "√õ", "√ª", c .. textCopy, c .. textPaste },
          R4 =
          { c .. "‚¨Ü", c .. "‚öôÔ∏è", " ", c .. " NRM ", c .. "‚Üê", c .. "‚Üí", c .. " CLOSE"}
          },        

        config = configMap }
        
        

        
      }

  ;--------------------------------------------------------
  ;--- Function per aggiornare i caption della tastiera ---
  ;--- in base allo stato corrente: normal, shifted,    ---
  ;--- alted                                            ---
  NewWin._refreshKeyboardCaptions =
    Function()
      Local map   = NewWin.Keymap[NewWin.currentMap]
      Local state = NewWin.mapState
      
      For Local i = 0 To 12
        Local caption = map[state].R0[i]
        NewWin.G1[i]:Set({ Caption = caption }, True)
      Next
      
      For Local i = 0 To 12
        Local caption = map[state].R1[i]
        NewWin.G2[i]:Set({ Caption = caption }, True)
      Next
     
      For Local i = 0 To 12
        Local caption = map[state].R2[i]
        NewWin.G3[i]:Set({ Caption = caption }, True)
      Next

      For Local i = 0 To 12
        Local caption = map[state].R3[i]
        NewWin.G4[i]:Set({ Caption = caption }, True)
      Next

      For Local i = 0 To 6
        Local caption = map[state].R4[i]
        NewWin.G5[i]:Set({ Caption = caption }, True)
      Next

    EndFunction
    
  ;-----------------------------------------------------
  ;--- Funzione per cambiare lo stato della tastiera ---
  ;--- che pu√≤ essere: normal, shifted oppure alted  ---
  ;--- i caption dei tasti saranno aggiornati con    ---
  ;--- quelli definiti.                              ---
  NewWin._changeKeyboardState = 
    Function(newState)
      ; NewState pu√≤ essere : normal, shifted oppure alted
      If newState = "normal"
        NewWin.mapState = "normal"
        NewWin._isNormal = True
        NewWin._isShifted = False
        NewWin._isAlted = False
        NewWin._isConfig = False
        
      ElseIf newState = "shifted"
        NewWin.mapState = "shifted"
        NewWin._isNormal = False
        NewWin._isShifted = True
        NewWin._isAlted = False
        NewWin._isConfig = False
        
      ElseIf newState = "alted"
        NewWin.mapState = "alted"
        NewWin._isNormal = False
        NewWin._isShifted = False
        NewWin._isAlted = True
        NewWin._isConfig = False

      ElseIf newState = "config"
        NewWin.mapState = "config"
        NewWin._isNormal = False
        NewWin._isShifted = False
        NewWin._isAlted = False
        NewWin._isConfig = True

      EndIf
      
      NewWin._refreshKeyboardCaptions()
      
    EndFunction
  
  ;-----------------------------------------
  ;--- Funzione di Gestione dei pulsanti ---
  NewWin._ParseButton =
    Function(msg)
      ;DebugPrint(msg.name)
    
      ; ----------
      ; CONFIG KEY
      ; ----------
      If LeftStr(msg.name, 9) = ":sp:r5:c1"
        If NewWin._isConfig 
          ; Torna allo stato normale
          NewWin._changeKeyboardState("normal")
          
        Else
          ; Passa allo stato Config
          NewWin._changeKeyboardState("config")
          
        EndIf
    
      ; ---------
      ; SHIFT KEY
      ; ---------
      ElseIf LeftStr(msg.name, 9) = ":sp:r5:c0"
        If NewWin._isShifted 
          ; Torna allo stato normale
          NewWin._changeKeyboardState("normal")
          
        Else
          ; Passa allo stato Shifted
          NewWin._changeKeyboardState("shifted")
          
        EndIf
      
      ; -------
      ; ALT KEY
      ; -------
      ElseIf LeftStr(msg.name, 9) = ":sp:r5:c3"
        
        If NewWin._isAlted
          ; Torna allo stato normale
          NewWin._changeKeyboardState("normal")
          
        Else
          ; Passa allo stato Shifted
          NewWin._changeKeyboardState("alted")
             
        EndIf
        
      ; -------------
      ; BACKSPACE KEY
      ; -------------
      ElseIf LeftStr(msg.name, 10) = ":sp:r1:c12"
        Local v = NewWin.Input.TextObj:GetText()
        NewWin.Input.TextObj:eBackspace()
        NewWin.Input:Render()

      ; ---------
      ; CLEAR KEY
      ; ---------
      ElseIf LeftStr(msg.name, 10) = ":sp:r2:c12"
        NewWin.Input.TextObj:Set({ text = "" })
        NewWin.Input:Render()

      
      ; -----------
      ; CURSOR LEFT
      ; -----------
      ElseIf LeftStr(msg.name, 9) = ":sp:r5:c4"
        NewWin.Input.TextObj:mCursorBackward()
        NewWin.Input:Render()
        
      ; ------------
      ; CURSOR RIGHT
      ; ------------
      ElseIf LeftStr(msg.name, 9) = ":sp:r5:c5"
        NewWin.Input.TextObj:mCursorForward()
        NewWin.Input:Render()

      ; --------
      ; COPY KEY
      ; --------
      ElseIf LeftStr(msg.name, 10) = ":sp:r4:c11"
        Local v = NewWin.Input.TextObj:GetText()
        If v <> ""
          SetClipboard(#CLIPBOARD_TEXT, v)
        EndIf

      ; ---------
      ; PASTE KEY
      ; ---------
      ElseIf LeftStr(msg.name, 10) = ":sp:r4:c12"
        Local t, v = GetClipboard()
        If t = #CLIPBOARD_TEXT
          NewWin.Input.TextObj:eWriteChar_Insert(v)
          NewWin.Input:Render()
        EndIf

      ; ---------
      ; ENTER KEY
      ; ---------
      ElseIf LeftStr(msg.name, 10) = ":sp:r3:c12"
        Local v = NewWin.Input.TextObj:GetText()
        NewWin._callbackOk(v)
        NewWin._waitInput = False
        NewWin:Close()
        NewWin:Free()
      
      ; ---------
      ; CLOSE KEY
      ; ---------
      ElseIf LeftStr(msg.name, 9) = ":sp:r5:c6"
        NewWin._callbackClose("")
        NewWin._waitInput = False
        NewWin:Close()
        NewWin:Free()
        
      ; --------------------------
      ; ANY OTHER CHARACTER BUTTON
      ; --------------------------
      Else
        If NewWin._isConfig
          ; Modalit√† configurazione
          Local v = msg.caption
          If v = "IT"
            ; Lingua italiana
            NewWin.currentMap = "italian"
            NewWin._changeKeyboardState("normal")
            NewWin._configuration.language = "italian"
            NewWin._saveConfig()
            
          ElseIf v = "EN"
            ; Lingua inglese
            NewWin.currentMap = "english"
            NewWin._changeKeyboardState("normal")
            NewWin._configuration.language = "english"
            NewWin._saveConfig()
            
          ElseIf v = "DE"
            ; Lingua tedesca
            NewWin.currentMap = "german"
            NewWin._changeKeyboardState("normal")
            NewWin._configuration.language = "german"
            NewWin._saveConfig()
            
          ElseIf v = "FR"
            ; Lingua tedesca
            NewWin.currentMap = "french"
            NewWin._changeKeyboardState("normal")
            NewWin._configuration.language = "french"
            NewWin._saveConfig()
            
          EndIf
        
        Else
          ; Modalit√† normale
          Local v = msg.caption
          NewWin.Input.TextObj:eWriteChar_Insert(v)
          NewWin.Input:Render()
        
        EndIf
        
      EndIf
      
      
      ; ----------------------------------------------------
      ; ACTIVATE THE TEXT BOX
      ; After each key press the text box will get the focus
      ; ----------------------------------------------------
      NewWin.Input.TextObj:Activate()
      
    EndFunction
  

  ; Setup iniziale
  NewWin.currentMap = NewWin._configuration.language
  NewWin.mapState   = "normal"
  
  Local map   = NewWin.Keymap[NewWin.currentMap]
  Local state = "normal"
 
  HGui.SetAutoRendering(False)
  
  ; 1st Row: Message
  NewWin.Caption = HGui.Gadget:New(#HGUI_LABEL_GADGET, { Name = "Header", Caption = params.text })
  
  ; 2nd Row: typed text input box
  NewWin.Input = HGui.Gadget:new(#HGUI_TEXT_GADGET, 
                      { Text = params.value,
                        Gfx = { AdjustFontSize = params.AdjustFontSize },
                        AllowNewLine = params.AllowNewLine,
                        ;AllowedChars = "0123456789/*-+.,",
                        maxLen = params.maxLen,
                        pwdMode = params.isPassword,
                        EnterCloseInput = params.EnterToClose })
  
  ; 3rd row: numbers
  Local btnLook = { nText = { Font = { Name = params.font } },
                    hText = { Font = { Name = params.font } },
                    pText = { Font = { Name = params.font } },
                    dText = { Font = { Name = params.font } } }
  
  NewWin.R1 = HGui.Gadget:new(#HGUI_BOX_GADGET)
    NewWin.G1 = {}
    For Local i = 0 To 12
      Local caption = map[state].R0[i]
      NewWin.G1[i] = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:r1:c" .. i .. HL.GetRndName(), 
                                                            Caption = caption,  
                                                            Look    = btnLook,
                                                            Actions = { OnPushed = NewWin._ParseButton } })
    Next
    
  ; 4th row: chars 1
  NewWin.R2 = HGui.Gadget:new(#HGUI_BOX_GADGET)
    NewWin.G2 = {}
    For Local i = 0 To 12
      Local caption = map[state].R1[i]
      NewWin.G2[i] = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:r2:c" .. i .. HL.GetRndName(), 
                                                            Caption = caption,  
                                                            Look = btnLook,
                                                            Actions = { OnPushed = NewWin._ParseButton } })
    Next
  
  ; 5th row: chars 2
  NewWin.R3 = HGui.Gadget:new(#HGUI_BOX_GADGET)
    NewWin.G3 = {}
    For Local i = 0 To 12
      Local caption = map[state].R2[i]
      NewWin.G3[i] = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:r3:c" .. i .. HL.GetRndName(), 
                                                            Caption = caption,  
                                                            Look = btnLook,
                                                            Actions = { OnPushed = NewWin._ParseButton } })
    Next
  
  ; 6th row: chars 3
  NewWin.R4 = HGui.Gadget:new(#HGUI_BOX_GADGET)
    NewWin.G4 = {}
    For Local i = 0 To 12
      Local caption = map[state].R3[i]
      NewWin.G4[i] = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:r4:c" .. i .. HL.GetRndName(), 
                                                            Caption = caption,  
                                                            Look = btnLook,
                                                            Actions = { OnPushed = NewWin._ParseButton } })
    Next
  
  ; 7th row: chars 4
  NewWin.R5 = HGui.Gadget:new(#HGUI_BOX_GADGET)
    NewWin.G5 = {}
    For Local i = 0 To 6
      Local caption = map[state].R4[i]
      NewWin.G5[i] = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = ":sp:r5:c" .. i .. HL.GetRndName(), 
                                                            Caption = caption,  
                                                            Look = btnLook,
                                                            Actions = { OnPushed = NewWin._ParseButton } })
    Next
  
    
   
  ; Layout
  NewWin.RootGadget:layoutSet({ gadgets = { NewWin.Caption, NewWin.Input, NewWin.R1, NewWin.R2, NewWin.R3, NewWin.R4, NewWin.R5 },
                                weights = { 0.14, 0.16, 0.14, 0.14, 0.14, 0.14, 0.14 },
                                gap = 1,
                                type = #HGUI_VERTICAL_LAYOUT,
                                borders = { top = 1, bottom = 1, left = 1, right = 1 } }, True )

  NewWin.R1:layoutSet({ gadgets = NewWin.G1,
                        weights = { 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.100 },
                        gap = 1,
                        type = #HGUI_HORIZONTAL_LAYOUT,
                        borders = { top = 1, bottom = 1, left = 1, right = 1 } }, True )
  NewWin.R2:layoutSet({ gadgets = NewWin.G2,
                        weights = { 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.100 },
                        gap = 1,
                        type = #HGUI_HORIZONTAL_LAYOUT,
                        borders = { top = 1, bottom = 1, left = 1, right = 1 } }, True )
  NewWin.R3:layoutSet({ gadgets = NewWin.G3,
                        weights = { 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.100 },
                        gap = 1,
                        type = #HGUI_HORIZONTAL_LAYOUT,
                        borders = { top = 1, bottom = 1, left = 1, right = 1 } }, True )
  NewWin.R4:layoutSet({ gadgets = NewWin.G4,
                        weights = { 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.075, 0.085, 0.090 },
                        gap = 1,
                        type = #HGUI_HORIZONTAL_LAYOUT,
                        borders = { top = 1, bottom = 1, left = 1, right = 1 } }, True )
  NewWin.R5:layoutSet({ gadgets = NewWin.G5,
                        weights = { 0.100, 0.075, 0.440, 0.095, 0.085, 0.085, 0.120 },
                        gap = 1,
                        type = #HGUI_HORIZONTAL_LAYOUT,
                        borders = { top = 1, bottom = 1, left = 1, right = 1 } }, True )

  For Local i = 0 To 12
    NewWin.G1[i]:adaptFontSize()
  Next
  For Local i = 0 To 12
    NewWin.G2[i]:adaptFontSize()
  Next
  For Local i = 0 To 12
    NewWin.G3[i]:adaptFontSize()
  Next
  For Local i = 0 To 12
    NewWin.G4[i]:adaptFontSize()
  Next
  For Local i = 0 To 6
    NewWin.G5[i]:adaptFontSize()
  Next
                        
  HGui.SetAutoRendering(True)
  
  NewWin:Render()

  While NewWin._waitInput
    CheckEvent()
    Wait(1, #MILLISECONDS)
  Wend
  
  Return(NewWin)
                                
EndFunction

Function HGui.Window:InputBoxNew(params) ; *TriDoc*
/*-------------------------------------------------------------------
result = HGui.Window:InputBoxNew(params)

Create an input box window to allow users to type in or edit texts.
---------------------------------------------------------------------
INPUT
  params : A table that defines the window, see :New() method for details. Also these additional tags are supported:
    text           : Optional string to preload the input box with some text
    caption        : Optional text (NEW 05/08/2020)
    ok             : Ok button text
    cancel         : Cancel button text
    callbackOk     : Callback function
    callbackCancel : Callback function
    callbackClose  : When the window is closed
    waitInput      : TRUE to make a blocking requester, default is FALSE
    isPassword     : TRUE to mask the typed text, default = FALSE
    activateInput  : TRUE to auto activate the textBox, default = FALSE
    allowNewLines  : TRUE or FALSE, to allow to press enter to add new lines
    enterToClose   : TRUE or FALSE, to allow to confirm and close hitting the enter key
    adjustFontSize : TRUE or FALSE, to automatically adjust the font size
    captionWeight  : 0-1 value to modify the caption's area weight
    Gfx            : Additional graphical tuning options

OUTPUT
  result : Window object OR if waitInput = TRUE the following table:
    | { text   = <typedtext>, 
    |   ok     = True|False, 
    |   cancel = True|False, 
    |   close  = True|False }
    
NOTE
  If waitInput = False you have to close manually the requester using the :Free() methods, otherwise the window close is managed automatically.
  
EXAMPLE

TODO
  CHECK WHEN CLOSING REQUESTER ON NON-BLOCKING REQ IF IT IS WORKING, I CHANGED THE CODE ON 24/09/2021, SEE COMMENTED LINE WITH ***
  
NOTES
  The input box must be closed manually by the callback functions, this object does not block the code flow while listening to the user's input.
  
  The callback functions will be executed and will you get the gadget object that have generated the event (the one that has been clicked) with anan additional subtable 'result' holding the following fields:
  | { text      = InputBox contents
  |    ok       = True if the OK button has been pressed
  |    cancel   = True if the CANCEL button has been pressed
  |    window   = InputBox window
  |    }
  Note that the 'result' subtable is available only one if of the two buttonshas been pressend, it is not present if the InputBox has been closed using the window's close gadget.

  NEW FEATURE
  Using 'waitInput' the requester will not return until the text is entered and cancelled or confirmed using the buttons, also if the window is closed.
  In any case the requester is closed automatically.
  In this case  the function will return the following table:
  |  { text   = 'typed_text', 
  |    ok     = True|False, 
  |    cancel = True|False, 
  |    close  = True|False }
------------------------------------------------------------------*/
  If TB.Item.IsNil(params, "size"  ) Then params.size = { w = 500, h = 300 }
  If TB.Item.IsNil(params, "text"  ) Then params.text = ""
  If TB.Item.IsNil(params, "ok"    ) Then params.ok = "Ok"
  If TB.Item.IsNil(params, "cancel") Then params.cancel = "Cancel"
  If TB.Item.IsNil(params, "waitinput") Then params.waitinput = False
  If TB.Item.IsNil(params, "ispassword") Then params.isPassword = False
  If TB.Item.IsNil(params, "activateinput") Then params.activateInput = False

  Local btnNameOk     = ":ib:btn1:" .. HL.GetRndName()
  Local btnNameCancel = ":ib:btn2:" .. HL.GetRndName()
  Local pressed       = -1
  
  Local handleButtons =
    Function(btn)
      If TB.Item.Exists(btn, "name")
        If btn.Name = btnNameOk
          ; Button OK has been pressed
          If TB.Item.Exists(params, "callbackok")
            params.callbackOk(btn)
          EndIf
          If btn.result.window._waitInput
            btn.result.window:Free()
            btn.result.window = Nil
            pressed = btn
          EndIf
          
        ElseIf btn.Name = btnNameCancel
          If TB.Item.Exists(params, "callbackcancel")
            params.callbackCancel(btn)
          EndIf
          If btn.result.window._waitInput
            btn.result.window:Free()
            btn.result.window = Nil
            pressed = btn
          EndIf
        EndIf
        
      Else
        If TB.Item.Exists(params, "callbackclose")
          Local winID  = btn.id
          Local winObj = HGui.windowFindByHWID(winID)
          If TB.Item.Exists(params, "callbackclose")
            params.callbackClose(winObj)
          EndIf
          If winObj._waitInput
            winObj:Free()
            winObj.result = { text = params.text, ok = False, cancel = False, close = True }
            pressed = winObj
          EndIf
          
        Else
          ;***If TB.Item.Exists(winObj, "_waitinput")
          ;***  If winObj._waitInput
              Local winID  = btn.id
              Local winObj = HGui.windowFindByHWID(winID)
              winObj:Free()
              winObj.result = { text = params.text, ok = False, cancel = False, close = True }
              pressed = winObj
          ;***  EndIf
          ;***EndIf
          
        EndIf  
        
      EndIf
    EndFunction
  
  If TB.Item.Exists(params, "events")
    params.events.onClose = handleButtons
  Else
    params.events = { onClose = handleButtons }
  EndIf
  
  If TB.Item.Exists(params, "flags")
    params.flags.AutoClose = False
  Else
    params.flags = { AutoClose = False }
  EndIf

  Local NewWin = HGui.Window:New(params)
  NewWin._waitInput = params.waitInput
  
  If TB.Item.IsNil(params, "allownewline")
    params.AllowNewLine = True
  EndIf
  If TB.Item.IsNil(params, "entertoclose")
    params.EnterToClose = False
  EndIf
  If TB.Item.IsNil(params, "adjustfontsize")
    params.AdjustFontSize = False
  EndIf 
  If TB.Item.IsNil(params, "captionweight")
    params.CaptionWeight = 0.5
  EndIf
  If TB.Item.IsNil(params, "gfx")
    params.gfx = {}
  EndIf
  
  params.gfx.adjustFontSize = params.adjustFontSize
  params.gfx.captionWeight  = params.captionWeight
  
  ; Setup the layout, a text input on the top and the buttons at the bottom.
  HGui.SetAutoRendering(False)
  If TB.Item.Exists(params, "caption")
    NewWin.body     = HGui.Gadget:new(#HGUI_LABEL_GADGET,
                        { Caption = params.Caption,
                          Look = { nText = { Wordwrap = True }}})
    NewWin.body:FontMargins({ left = 10, right = 10, top = 0, bottom = 0 }, False)

  EndIf
  
  NewWin.pwTInput = HGui.Gadget:new(#HGUI_TEXT_GADGET, 
                      { Text = params.text,
                        Gfx = params.Gfx,
                        AllowNewLine = params.AllowNewLine,
                        pwdMode = params.isPassword,
                        EnterCloseInput = params.EnterToClose })
  NewWin.pwGrpButtons = HGui.Gadget:New(#HGUI_BOX_GADGET)

  ; crea i due pulsanti
  ; devo fare in modo che i due pulsanti inviino alla funzione di callback questi campi:
  ;    Ok = True|False
  ;    Cancel = True|False
  ;    Text = <text>
    
  Local btn1 = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = btnNameOk, Caption = params.ok, Actions = { OnPushed = handleButtons } })
  Local btn2 = HGui.Gadget:New(#HGUI_BUTTON_GADGET, { Name = btnNameCancel, Caption = params.cancel, Actions = { OnPushed = handleButtons } })
  btn1.result = { text = params.text, ok = True, cancel = False, close = False, window = NewWin }
  btn2.result = { text = params.text, ok = False, cancel = True, close = False, window = NewWin }
  
  ; ogni volta che il controllo si disattiva il testo viene aggiornato
  NewWin.pwTInput.TextObj.Actions.OnUnactivate =
    Function(msg)
      btn1.result.text = msg.text
      btn2.result.text = msg.text
    EndFunction

  ; Ogni volta che il controllo rileva una modifica il testo viene aggiornato
  NewWin.pwTInput.TextObj.Actions.OnChange =
    Function(msg)
      btn1.result.text = msg.text
      btn2.result.text = msg.text
    EndFunction
  
  NewWin.pwGrpButtons:layoutSet({ gadgets = { btn1, btn2 },
                                  ; weights = { 0.75, 0.25 },
                                  gap = 2,
                                  type = #HGUI_HORIZONTAL_LAYOUT,
                                  borders = { top = 0, bottom = 0, left = 0, right = 0 } }, True )

  Local w2 = (btn1.Look.nText.Font.Size + 16)/NewWin.Size.h
  Local w1 = 1 - w2
  /*
DebugPrint(btn1.Look.nText.Font.Size + 8, NewWin.Size.h)
DebugPrint(w1, w2) */

  If TB.Item.Exists(params, "caption")
    NewWin.RootGadget:layoutSet({ gadgets = { NewWin.Body, NewWin.pwTInput, NewWin.pwGrpButtons },
                                  weights = { w1*params.gfx.captionWeight, w1*(1-params.gfx.captionWeight), w2 },
                                  gap = 1,
                                  type = #HGUI_VERTICAL_LAYOUT,
                                  borders = { top = 1, bottom = 1, left = 1, right = 1 } }, True )
  
  Else
    NewWin.RootGadget:layoutSet({ gadgets = { NewWin.pwTInput, NewWin.pwGrpButtons },
                                  weights = { w1, w2 },
                                  gap = 1,
                                  type = #HGUI_VERTICAL_LAYOUT,
                                  borders = { top = 1, bottom = 1, left = 1, right = 1 } }, True )
  EndIf
  
  HGui.SetAutoRendering(True)
  
  NewWin:Render()

  If params.activateInput
    NewWin.pwTInput.textObj:Activate()
  EndIf
  
  ; Wait in this loop until the window is removed or until
  ; the _waitInput flag is True
  While NewWin._waitInput And HGui.windowExists(NewWin.Name)
    CheckEvent()
    Wait(1, #MILLISECONDS)
    
  Wend
  
  ; Se la finestra √® stata chiusa, ma abbiamo il wait input, significa che √® stata
  ; la funzione di callback quindi restituisco il risultato
  If NewWin._waitInput
    NewWin = pressed.result
  EndIf
  
  Return(NewWin)
  
EndFunction

Function HGui.Window:ProgressNew(params) ; *TriDoc*
/*---------------------------------------------------------
windObject = HGui.Window:ProgressNew(params)

Create a new window with a progress bar.
-----------------------------------------------------------
INPUT
  params : A table that defines the window, see :New() method for details. Also these additional tags are supported:
    valueMin   : Minimum value for the progress bar
    valueMax   : Maximum value for the progress bar
    value      : Current value for the progress bar
    message    : Text message to show.
    cursor     : Custom cursor (optional)
    cursorText : Cursor text with support for the following tags:
      - {value}
      - {value.##}
      - {intvalue}
      - {rangestart}
      - {rangeend}
      - {perc}

OUTPUT
  windObject : The created window's object
---------------------------------------------------------*/
  If TB.Item.IsNil(params, "size") Then params.size = { w = 300, h = 100 }
  If TB.Item.IsNil(params, "message") Then params.message = ""
  If TB.Item.IsNil(params, "cursortext") Then params.cursorText = "{value}/{rangeend}"
  If TB.Item.IsNil(params, "value") Then params.value = 1
  If TB.Item.IsNil(params, "valuemin") Then params.value = 1
  If TB.Item.IsNil(params, "valuemax") Then params.value = 100
  
  Local NewWin = HGui.Window:New(params)
  NewWin.IsProgressWindow = True
  
  Local cursor = {}
  If TB.Item.Exists(params, "cursor") Then cursor = params.cursor
  
  ; Setup the layout, a label on the top and a progress bar on the bottom.
  HGui.SetAutoRendering(False)
  NewWin.pwLabel = HGui.Gadget:New(#HGUI_LABEL_GADGET, { Caption = params.message })
  NewWin.pwProgress = HGui.Gadget:New(#HGUI_PROGRESSBAR_GADGET, { Range = { params.valueMin, params.valueMax }, Value = params.value, Caption = params.cursorText, Cursor = Cursor })
  
  NewWin.RootGadget:layoutSet({ gadgets = { NewWin.pwLabel, NewWin.pwProgress },
                                weights = { 0.75, 0.25 },
                                gap = 1,
                                type = #HGUI_VERTICAL_LAYOUT,
                                borders = { top = 1, bottom = 1, left = 1, right = 1 } }, True )
  HGui.SetAutoRendering(True)
  
  NewWin:Render()

  Return(NewWin)
  
EndFunction

Function HGui.Window:ProgressUpdate(params) ; *TriDoc*
/*---------------------------------------------------------
HGui.Window:ProgressUpdate(params)

Updates an existing progress bar window
-----------------------------------------------------------
INPUT
  params : A table with all parameters we want to change
    value   : Current progress bar value
    message : Message to show in the upper label
---------------------------------------------------------*/
  If TB.Item.Exists(self, "isprogresswindow")
    If TB.Item.Exists(params, "message")
      self.pwLabel:Set({ Caption = params.Message }, True)
      
    EndIf
    
    If TB.Item.Exists(params, "value")
      ;self.pwProgress:Set({ Value = params.Value }, True)
      self.pwProgress:Set(params, True)
      
    EndIf
    
  EndIf
  
EndFunction

Function HGui.Window:MessageNew(params) ; *TriDoc*
/*---------------------------------------------------------
windObject = HGui.Window:MessageNew(params)

Create a new window for 'please wait' kind of messages.
-----------------------------------------------------------
INPUT
  params : A table that defines the window, see :New() method for details. Also these additional tags are supported:
    message : Text message to show.

OUTPUT
  windObject : The created window's object
---------------------------------------------------------*/
  If IsNil(params) Then params = { message = "" }
  If TB.Item.IsNil(params, "message") Then params.message = ""
  If TB.Item.IsNil(params, "size") Then params.size = { w = 300, h = 100 }

  Local NewWin = HGui.Window:New(params)
  NewWin.IsWaitWindow = True
  
  ; Setup the layout, a label on the top and a progress bar on the bottom.
  HGui.SetAutoRendering(False)
  NewWin.pwLabel = HGui.Gadget:New(#HGUI_LABEL_GADGET, { Caption = params.message }, Window = NewWin)
  
  NewWin.RootGadget:layoutSet({ gadgets = { NewWin.pwLabel },
                                weights = { 1 },
                                gap = 1,
                                type = #HGUI_VERTICAL_LAYOUT,
                                borders = { top = 1, bottom = 1, left = 1, right = 1 } }, True )
  HGui.SetAutoRendering(True)
  
  NewWin:Render()

  Return(NewWin)
EndFunction

Function HGui.Window:MessageUpdate(params) ; *TriDoc*
/*---------------------------------------------------------
HGui.Window:ProgressUpdate(params)

Updates an existing messageBox window
-----------------------------------------------------------
INPUT
  params : Parameters to change
    message : Message to update.
---------------------------------------------------------*/
  If TB.Item.Exists(self, "iswaitwindow")
    If TB.Item.Exists(params, "message")
      self.pwLabel:Set({ Caption = params.Message }, True)
      
    EndIf
    
  EndIf
  
EndFunction

Function HGui.Window:menuSet(menuDef, params) ; *TriDoc*
/*---------------------------------------------------------
winObject:menuSet(menuDef, params)

Attach or redefine a top menu group.
-----------------------------------------------------------
INPUT
  menuDef : A menu definition is a table with the following structure:
    menuWidth : Optional menu width in pixels
    index 0   : The menu item definition
      type      : Item's type (gadget class constant)
      params    : Item's parameters (gadget options)
      callback  : Callback function (optional)
      size      : Item height in pixels to override the default one (optional)
      submenu   : An optional submenu table with a <menuDef> structure.
    index 1 ...
    index n ...
  params : A table that allow you to override the theme settings.

NOTES
  There is no limits to the menu complexity, you can use any gadget you want inside a menu but you have to handle manually menu actions and values, for example, if you insert a switch and the user select it you have to update the value manually using a callback function so that the next time the user will open the menu he will find the switch with the updated value.
  Since the <menuDef> is used directly you can keep updated its values. The first level only accepts #HGUI_BUTTON_GADGET, these items are  the ones that goes into the top bar. The field <size> allow you to specify the item's height, if not specified the <HGui.Theme.SubMenu.Height> value will be used.
  During the creation process all created gadgets will be assigned to the 'Gadget' field of each element, gadgets will also have a circular reference to the menu table in the 'menuRoot' field, while 'menuDef' will point to the definition used to generate the gadget.

EXAMPLE
  Here is a menuDef table as example:
  | ; myWindow is a Window object already defined and created.
  |
  | Function showProgramInfos(gadget)
  |    DebugPrint("ShowProgramInfos has been selected!")
  | EndFunction
  |
  | Function AboutBox(gadget)
  |   DebugPrint("AboutBox has been selected!")
  |
  | EndFunction
  |
  | Local myMenu =
  |  { { type = #HGUI_BUTTON_GADGET, params = { Caption = "File" },
  |      submenu = { { type = #HGUI_BUTTON_GADGET, params = { Caption = "New" } },
  |                  { type = #HGUI_BUTTON_GADGET, params = { Caption = "Save As" },
  |                    submenu = { { type = #HGUI_BUTTON_GADGET, size = 20, params = { Caption = "PNG" } },
  |                                { type = #HGUI_BUTTON_GADGET, size = 25, params = { Caption = "JPG" } },
  |                                { type = #HGUI_BUTTON_GADGET, size = 30, params = { Caption = "BMP" } },
  |                                { type = #HGUI_VDIVIDER_GADGET, size = 5, params = {} },
  |                                { type = #HGUI_SWITCH_GADGET, size = 35, params = { Caption = "Compression", Value = 0 } },
  |                                { type = #HGUI_SWITCH_GADGET, size = 40, params = { Caption = "Smart Save", Value = 1 } },
  |                                { type = #HGUI_SLIDER_GADGET, size = 20, params = { Range = { 1, 100 }, value = 2,
  |                                                                                    CursorSize = 0.2,
  |                                                                                    Orientation = #HGUI_HORIZONTAL_LAYOUT } }
  |                                } },
  |                  { type = #HGUI_VDIVIDER_GADGET, params = {} },
  |                  { type = #HGUI_BUTTON_GADGET, params = { Caption = "Preferences" },
  |                    submenu = { { type = #HGUI_BUTTON_GADGET, params = { Caption = "Load" } },
  |                                { type = #HGUI_BUTTON_GADGET, params = { Caption = "Save" } },
  |                                { type = #HGUI_BUTTON_GADGET, params = { Caption = "Edit" } },
  |                                { type = #HGUI_VDIVIDER_GADGET, params = {} },
  |                                { type = #HGUI_SWITCH_GADGET, params = { Caption = "Encrypt data", Value = 0 } },
  |                                { type = #HGUI_SWITCH_GADGET, params = { Caption = "Compress data", Value = 1 } },
  |                                { type = #HGUI_BUTTON_GADGET, params = { Caption = "Set master keyword" } },
  |                                { type = #HGUI_BUTTON_GADGET, params = { Caption = "Recover master keyword" } },
  |                                { type = #HGUI_BUTTON_GADGET, params = { Caption = "Reset all" } },
  |                                { type = #HGUI_VDIVIDER_GADGET, params = {} },
  |                                { type = #HGUI_SWITCH_GADGET, params = { Caption = "Lock all files", Value = 0 } },
  |                                { type = #HGUI_SWITCH_GADGET, params = { Caption = "Reset preferences", Value = 1 } }
  |                                } },
  |                  { type = #HGUI_VDIVIDER_GADGET, params = {} },
  |                  { type = #HGUI_BUTTON_GADGET, params = { Caption = "Close" } },
  |                  { type = #HGUI_BUTTON_GADGET, params = { Caption = "Quit" } }
  |                  } },
  |      { type = #HGUI_BUTTON_GADGET, params = { Caption = "Edit (empty)" } },
  |      { type = #HGUI_BUTTON_GADGET, params = { Caption = "Search (empty)" } },
  |      { type = #HGUI_BUTTON_GADGET, params = { Caption = "Help" }, 
  |        submenu = { { type = #HGUI_BUTTON_GADGET, params = { Caption = "Version" }, callback = ShowProgramInfos },
  |                    { type = #HGUI_BUTTON_GADGET, params = { Caption = "About" }, callback = AboutBox }
  |        } }
  |      }
  |
  | myWindow:menuSet(myMenu)
  |

---------------------------------------------------------*/
  DBG.Console.Out(":menuSet() -> " .. ToString(self.Name) .. ", (" .. ToString(menuDef) .. ", " .. ToString(params) .. ")", DBG.OpenFunc, HGui.WChannel)

  HGui.SetAutoRendering(False)

  ; Distrugge gli elementi di un eventuale menu precedente
  DBG.Console.Out("Removing old menu items if any...", Nil, HGui.WChannel)
  If TB.Item.Exists(self.Menu.Childs, "gadgets")
    For k, w In Pairs(self.Menu.Childs.Gadgets)
      w:Free()
    Next
  EndIf
  self.Menu.Childs.Gadgets = Nil

  ; Crea i nuovi elementi
  DBG.Console.Out("Creating the new items...", Nil, HGui.WChannel)
  Local newCount = ListItems(menuDef)
  Local GadgetList, GadgetSizes = {}, {}
  Local ItemsGap = HGui.Theme.SubMenu.HorizontalOverlap
  For i = 0 To newCount-1
    If menuDef[i].type = #HGUI_BUTTON_GADGET
      ; Apply the menu style & Window
      menuDef[i].Params.Look = CopyTable(HGui.Theme.Menu.ItemsLook)
      menuDef[i].Params.Window = self

      ; Apply font size
      For i, v In Pairs(menuDef[i].Params.Look)
        If TB.Item.Exists(v, "font") Then v.Font.Size = HGui.Theme.Menu.Height + HGui.Theme.Menu.FontOffset
      Next

      ; Apply the callback function
      If TB.Item.Exists(menuDef[i].Params, "actions")
        menuDef[i].Params.Actions.OnPushed = HGui.Menu_Open
      Else
        menuDef[i].Params.Actions = { OnPushed = HGui.Menu_Open }
      EndIf

      Local Gadget = HGui.Gadget:new(menuDef[i].type, menuDef[i].Params)
      menuDef[i].Gadget = Gadget
      Gadget.MenuDef = menuDef[i]
      Gadget.MenuRoot = menuDef
      Gadget.IsMenu  = True

      InsertItem(GadgetList, Gadget)
      InsertItem(GadgetSizes, GFX.Text.GetWidth(Gadget.Caption) + ItemsGap)
    Else
      DBG.Console.Out("Only buttons are allowed here! Skipping...", DBG.Warning, HGui.WChannel)
    EndIf
  Next

  ; Reimposta il layout
  If ListItems(GadgetList) > 0
    self.root:layoutSet({ gadgets = { self.menu, self.rootgadget},
                          weights = { HGui.Theme.Menu.Height, 1 },
                          gap = HGui.Theme.Menu.TopBoxSpacing,
                          type =  #HGUI_VERTICAL_LAYOUT,
                          borders = { top = HGui.Theme.Menu.Borders.Top, bottom = HGui.Theme.Menu.Borders.Bottom, left = HGui.Theme.Menu.Borders.Left, right = HGui.Theme.Menu.Borders.Right }}, True)
    self.menu:layoutSet({ gadgets = GadgetList,
                          weights = GadgetSizes,
                          gap = HGui.Theme.Menu.TopItemsSpacing,
                          type =  #HGUI_HORIZONTAL_LAYOUT,
                          borders = { top = HGui.Theme.Menu.ItemsBorder.Top, bottom = HGui.Theme.Menu.ItemsBorder.Bottom, left = HGui.Theme.Menu.ItemsBorder.Left, right = HGui.Theme.Menu.ItemsBorder.Right }}, True)
  Else
    self.root:layoutSet({ gadgets = { self.menu, self.rootgadget},
                          weights = { 1.01, 1 },
                          gap = HGui.Theme.Menu.TopBoxSpacing,
                          type =  #HGUI_VERTICAL_LAYOUT,
                          borders = { top = HGui.Theme.Menu.Borders.Top, bottom = HGui.Theme.Menu.Borders.Top, left = HGui.Theme.Menu.Borders.Left, right = HGui.Theme.Menu.Borders.Right }}, True)
  EndIf

  HGui.SetAutoRendering(True)
  self:render()

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
EndFunction


Function HGui.Window:new(options) ; *TriDoc*
/*---------------------------------------------------------
winObject = HGui.Window:new(options)

Create a new HGui window.
-----------------------------------------------------------
INPUT
  options : A table used to override default values.
    title : Window's title.
    name : Unique window's name, if you omit this argument an unique name will be assigned to the window for you.
    vsync : True|False
    position : Window's position in the host screen.
      x : Horizontal position (pixels). Defaults to #CENTER.
      y : Vertical position (pixels). Defaults to #CENTER.
    size : Window's size
     w : Width in pixels. Defaults to 320.
     h : Height in pixels. Defaults to 200.
    sizemax : Maximum size the window can be resized to. Defaults to the host screen size.
      w : Width in pixels. Defaults to 320.
      h : Height in pixels. Defaults to 200.
    sizemin : Minimum size the window can be resize to. Defaults to <size>.
      w : Width in pixels. Defaults to 320.
      h : Height in pixels. Defaults to 200.
    cacheroot : Cache root gadget (True|False)
    bgcolor : Background color
    background : Image file name used to fill the background
    bgtexture : Image file used as tile to fill the background
    bggradient : Table used to define a multi-color gradient to fill the background
      type : Gradient type : #LINEAR, #RADIAL, #CONICAL
      angle : Gradient angle in degrees
      colors : Gradient colors definition, it's atable composed by pairs [color]-[position]. Color is an RBG color value and position is a number in the 0-1 range. Note that the first color must have the position 0   and the last one the position 1.
    hotkeys : A table with window's action hotkeys
      hide : A key associated to the window:hide() method
      show : A key associated to the window:show() method
      activate : A key associated to the window:activate() method
      close : A key associated to the window:close() method
      open : A key associated to the window:open() method
    customhotkeys : A table with custom hotkeys you can assign with your own function, each definition is a subtable with the following items:
      qualifier : Key qualifier (LCONTROL, RCONTROL, etc...)
      key : Assigned key
      event : Event (OnKeyDown, ...)
      callback : Callback function
    flags : Window's flags
      resizeable : Resizeable window? (True|False)
      closeable : Closeable window? (True|False)
      moveable : Moveable window? (True|False)
      borderless : Borderless window? (True|False)
      modal : Modal window? (True|False)
      hidefromtaskbar : Hide from the taskbar (True|False)
      hideable : Hideable window? (True|False)
      autoclose : <False> to receive the event but to keep the window opened, you have to close it in your  callback function.
    events : Callback functions table
      onclose : Called when the window is closed (passed params: eventMessage, windowObject)
      onmove : Called when the window is move
      onactivate : Called when the window get the focus
      ondeactivate : Called when the window lost the focus
      onhide : Called when the window is hided
      onshow : Called when the window is showed
      onsize : Called when the window is resized
      ondrop : Called when a file is dropped into the window
    dontopen : TRUE to create the window without opening
    contextual : Contextual menu (same structure as .menu field) 
    menu : Top menu definition, please have a look at :menuSet() method for detailed informations.

OUTPUT
  winObject : The window object created or FALSE if an error has occured.
---------------------------------------------------------*/
  DBG.Console.Out(":new()", DBG.OpenFunc, HGui.WChannel)

  Local NewWin = CopyTable(self)

  ;::: TITLE ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "title") Then NewWin.title = options.title
  DBG.Console.Out("Title : " .. NewWin.title, Nil, HGui.WChannel)
  
  ;::: CACHEROOT ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "cacheroot") Then NewWin.cacheroot = options.cacheroot

  ;::: NAME :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ; If <name> exists generate an error, if <name> is not specified assign a
  ; unique and random name automatically.
  If TB.Item.Exists(options, "name")
    If HGui.windowExists(options.name)
      DBG.Console.Out("Window name <" .. options.name .. "> already assigned!", DBG.Error, HGui.WChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
      Return(False)
    Else
      NewWin.name = options.name
    EndIf
  Else
    NewWin.name = "Window." .. HL.GetRndName()
    DBG.Console.Out("Auto-assigned name <" .. NewWin.name .. ">.", DBG.Warning, HGui.WChannel)
  EndIf

  ;::: HOT KEYS :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ; HotKeys = { Hide = { Qualifier = "LCONTROL", Key = "A" }, ... }
  If TB.Item.Exists(options, "hotkeys")
    If TB.Item.Exists(options.HotKeys, "hide"    ) Then NewWin.Private.HotKeys.Hide = options.HotKeys.Hide
    If TB.Item.Exists(options.HotKeys, "show"    ) Then NewWin.Private.HotKeys.Show = options.HotKeys.Show
    If TB.Item.Exists(options.HotKeys, "close"   ) Then NewWin.Private.HotKeys.Close = options.HotKeys.Close
    If TB.Item.Exists(options.HotKeys, "open"    ) Then NewWin.Private.HotKeys.Open = options.HotKeys.Open
    If TB.Item.Exists(options.HotKeys, "activate") Then NewWin.Private.HotKeys.Activate = options.HotKeys.Activate
  EndIf
  ; CustomHotKeys = { { Qualifier = "", Key = "", AltCode = "", Event = "", Callback = function } }
  If TB.Item.Exists(options, "customhotkeys")
    NewWin.Private.CustomHotKeys = options.CustomHotKeys
    For i, v In Pairs(NewWin.Private.CustomHotKeys)
      If TB.Item.IsNil(v, "altcode") Then v.AltCode = ""
    Next
  EndIf
  
  ; VSYNC
  If TB.Item.Exists(options, "vsync") Then NewWin.VSync = options.vsync
  
  ;::: POSITION :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "position")
    If TB.Item.Exists(options.position, "x") Then NewWin.position.x = options.position.x
    If TB.Item.Exists(options.position, "y") Then NewWin.position.y = options.position.y
  EndIf

  ;::: SIZE :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;: If any size is <= 0 an error will be generated.                          :
  If TB.Item.Exists(options, "size")
    If TB.Item.Exists(options.size, "w")
      If options.size.w > 0
        NewWin.size.w    = options.size.w
        NewWin.SizeMin.w = NewWin.Size.w
        NewWin.SizeMax.w = NewWin.Size.w
      Else
        DBG.Console.Out("Incorrect width : " .. options.size.w, DBG.Error, HGui.WChannel)
        DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
        Return(False)
      EndIf
    EndIf
    If TB.Item.Exists(options.size, "h")
      If options.size.h > 0
        NewWin.size.h    = options.size.h
        NewWin.SizeMin.h = NewWin.Size.h
        NewWin.SizeMax.h = NewWin.Size.h
      Else
        DBG.Console.Out("Incorrect height : " .. options.size.h, DBG.Error, HGui.WChannel)
        DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
        Return(False)
      EndIf
    EndIf
  EndIf

  ;::: SIZEMAX ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;: If any size will be <= 0 an error will be generated.                     :
  If TB.Item.Exists(options, "sizemax")
    If TB.Item.Exists(options.sizemax, "w")
      If options.sizemax.w > 0
        NewWin.sizemax.w = options.sizemax.w
      Else
        DBG.Console.Out("Incorrect max width : " .. options.sizemax.w, DBG.Error, HGui.WChannel)
        DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
        Return(False)
      EndIf
    EndIf
    If TB.Item.Exists(options.sizemax, "h")
      If options.sizemax.h > 0
        NewWin.sizemax.h = options.sizemax.h
      Else
        DBG.Console.Out("Incorrect max height : " .. options.sizemax.h, DBG.Error, HGui.WChannel)
        DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
        Return(False)
       EndIf
    EndIf
  Else
    NewWin.sizemax.w, NewWin.sizemax.h = GFX.GetHostSize()
  EndIf

  ;::: SIZEMIN ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;: If any size will be <= 0 an error will be generated.                     :
  If TB.Item.Exists(options, "sizemin")
    If TB.Item.Exists(options.sizemin, "w")
      If options.sizemin.w > 0
        NewWin.sizemin.w = options.sizemin.w
      Else
        DBG.Console.Out("Incorrect min width : " .. options.sizemin.w, DBG.Error, HGui.WChannel)
        DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
        Return(False)
      EndIf
    EndIf
    If TB.Item.Exists(options.sizemin, "h")
      If options.sizemin.h > 0
        NewWin.sizemin.h = options.sizemin.h
      Else
        DBG.Console.Out("Incorrect min height : " .. options.sizemin.h, DBG.Error, HGui.WChannel)
        DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
        Return(False)
      EndIf
    EndIf
  EndIf

  ;--| CHECK AND RECTIFY SIZES IF NEEDED |-------------------------------------
  If NewWin.SizeMax.w < NewWin.SizeMin.w Then NewWin.SizeMax.w = NewWin.SizeMin.w
  If NewWin.SizeMax.h < NewWin.SizeMin.h Then NewWin.SizeMax.h = NewWin.SizeMin.h
  If NewWin.Size.w    < NewWin.SizeMin.w Then NewWin.Size.w    = NewWin.SizeMin.w
  If NewWin.Size.h    < NewWin.SizeMin.h Then NewWin.Size.h    = NewWin.SizeMin.h
  If NewWin.Size.w    > NewWin.SizeMax.w Then NewWin.Size.w    = NewWin.SizeMax.w
  If NewWin.Size.h    > NewWin.SizeMax.h Then NewWin.Size.h    = NewWin.SizeMax.h

  NewWin.NativeSize = CopyTable(NewWin.Size) ;    <-- Used by the layout engine

  ;::: BACKGROUND :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;                                                                  BGCOLOR ::
  Local BgColor = HGui.theme.WindowBG
  If TB.Item.Exists(options, "bgcolor") Then BgColor = options.bgcolor
  ;                                                               BACKGROUND ::
  If TB.Item.Exists(options, "background")
    If Exists(options.background)
      Local r, i = IsPicture(options.background)
      If r
        Local bid  = LoadBrush(Nil, options.background, { LoadAlpha = i.Alpha })
        Local bid2 = GFX.ImageFX.Scale(bid, NewWin.size.w, NewWin.size.h, False, True, True, False)
        NewWin.private.BGId   = BrushToBGPic(bid2, Nil)
        NewWin.private.BGFile = options.background
        FreeBrush(bid2)
      Else
        DBG.Console.Out("Cannot load background <" .. options.background .. ">, image file not recognized.", DBG.Error, HGui.WChannel)
        DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
        Return(False)
      EndIf
    Else
      DBG.Console.Out("Cannot load the background <" .. options.background .. ">, image file not found.", DBG.Error, HGui.WChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
      Return(False)
    EndIf
  ;                                                                BGTEXTURE ::
  ElseIf TB.Item.Exists(options, "bgtexture")
    If Exists(options.BGTexture)
      Local r, i = IsPicture(options.BGTexture)
      If r
        Local bid = LoadBrush(Nil, options.BGTexture, { LoadAlpha = i.Alpha })
        NewWin.private.BGId   = CreateTexturedBGPic(Nil,bid, NewWin.size.w, NewWin.size.h, 0, 0)
        NewWin.private.BGFile = options.BGTexture
        FreeBrush(bid)
      Else
        DBG.Console.Out("Cannot load the background texture <" .. options.bgtexture .. ">, image file not recognized.", DBG.Error, HGui.WChannel)
        DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
        Return(False)
      EndIf
    Else
      DBG.Console.Out("Cannot load the background texture <" .. options.bgtexture .. ">, image file not found.", DBG.Error, HGui.WChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
    EndIf
  ;                                                               BGGRADIENT ::
  ElseIf TB.Item.Exists(options, "bggradient")
    Local BGGrad = options.BGGradient
    NewWin.private.BGId = CreateGradientBGPic(Nil, BGGrad.Type, #WHITE, #BLACK, NewWin.size.w, NewWin.size.h, BGGrad.Angle, { Colors = BGGrad.Colors })
  EndIf
  
  ;::: FLAGS ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "flags")
    If TB.Item.Exists(options.flags, "resizeable") Then NewWin.flags.resizeable = options.flags.resizeable
    If TB.Item.Exists(options.flags, "closeable" ) Then NewWin.flags.closeable  = options.flags.closeable
    If TB.Item.Exists(options.flags, "moveable"  ) Then NewWin.flags.moveable   = options.flags.moveable
    If TB.Item.Exists(options.flags, "borderless") Then NewWin.flags.borderless = options.flags.borderless
    If TB.Item.Exists(options.flags, "modal"     ) Then NewWin.flags.modal      = options.flags.modal
    If TB.Item.Exists(options.flags, "hideable"  ) Then NewWin.flags.hideable   = options.flags.hideable
    If TB.Item.Exists(options.flags, "autoclose" ) Then NewWin.flags.autoclose  = options.flags.autoclose
    If TB.Item.Exists(options.flags, "hidefromtaskbar" ) Then NewWin.flags.hidefromtaskbar  = options.flags.hidefromtaskbar
  EndIf

  ;--| CHECK AND RECTIFY INCOMPATIBLE FLAGS |----------------------------------
  If NewWin.flags.modal
    ;NewWin.flags.closeable = False
    NewWin.flags.hideable  = False
  EndIf

  ;::: EVENTS :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "events")
    If TB.Item.Exists(options.events, "onclose"     ) Then NewWin.events.onclose      = options.events.onclose
    If TB.Item.Exists(options.events, "onmove"      ) Then NewWin.events.onmove       = options.events.onmove
    If TB.Item.Exists(options.events, "onactivate"  ) Then NewWin.events.onactivate   = options.events.onactivate
    If TB.Item.Exists(options.events, "ondeactivate") Then NewWin.events.ondeactivate = options.events.ondeactivate
    If TB.Item.Exists(options.events, "onhide"      ) Then NewWin.events.onhide       = options.events.onhide
    If TB.Item.Exists(options.events, "onshow"      ) Then NewWin.events.onshow       = options.events.onshow
    If TB.Item.Exists(options.events, "onsize"      ) Then NewWin.events.onsize       = options.events.onsize
    If TB.Item.Exists(options.events, "ondrop"      ) Then NewWin.events.ondrop       = options.events.ondrop
  EndIf
  If NewWin.flags.modal
    ; Install event handler to make it modal!
    ; FIX: 12/06/2020 If there are more than one modal window
    ;      the interface will flicker between all modal windows.
    NewWin.events.onDeactivate =
      Function(msg)
        Local win = HGui.windowFindByHWID(msg.id)
        ; 12/06/2020
        ; Activate only the last opened window!
        HGui.Window._reactivateModalWindow(win)

      EndFunction
  EndIf

  ;===[ BUILD PROCESS ]========================================================
  ; Check if we are building the first window
  Local first_window = IIf(TB.Count(HGui.Windows) = 0, True, False)

  If first_window ;::::::::::::::::::::::::::::::::::::::::::: FIRST WINDOW :::
    NewWin.private.HWId = 1
    Local bgpic
    If TB.Item.Exists(NewWin.private, "bgid") Then bgpic = NewWin.Private.BGID
    
    SetDisplayAttributes(
      { Width        = NewWin.size.w,
        Height       = NewWin.size.h,
        Color        = BgColor,
        x            = NewWin.position.x,
        y            = NewWin.position.y,
        Title        = NewWin.title,
        Borderless   = NewWin.flags.borderless,
        Sizeable     = NewWin.flags.resizeable,
        Fixed        = Not(NewWin.flags.moveable),
        NoHide       = Not(NewWin.flags.hideable),
        NoClose      = Not(NewWin.flags.closeable),
        HideFromTaskBar = NewWin.flags.hidefromtaskbar,
        NoModeSwitch = False,            ; <--                  Not handled |
        Active       = True,             ; <--  Active for gadget rendering |
        HidePointer  = False,            ; <--                  Not handled |
        ScaleMode    = #SCALEMODE_NONE , ; <--                  Not handled |
        BGPic        = bgpic,
        VSync        = NewWin.VSync
        ; ScaleWidth,
        ; ScaleHeight,
        ; SmoothScale,
        ; FitScale,
        ; KeepProportions,
        ; DragRegion,
        ; SizeRegion,
        ; Layers
        })

  Else ;:::::::::::::::::::::::::::::::::::::::::::::::::: NOT FIRST WINDOW :::
    Local bgpic
    If TB.Item.Exists(NewWin.private, "bgid") Then bgpic = NewWin.Private.BGID
    
    NewWin.private.HWId = CreateDisplay(Nil,
      { Width        = NewWin.size.w,
        Height       = NewWin.size.h,
        Color        = BgColor,
        x            = NewWin.position.x,
        y            = NewWin.position.y,
        Title        = NewWin.title,
        Borderless   = NewWin.flags.borderless,
        Sizeable     = NewWin.flags.resizeable,
        Fixed        = Not(NewWin.flags.moveable),
        NoHide       = Not(NewWin.flags.hideable),
        NoClose      = Not(NewWin.flags.closeable),
        HideFromTaskBar = NewWin.flags.hidefromtaskbar,
        NoModeSwitch = False,            ; <--                  Not handled |
        Active       = True,             ; <--  Activa for gadget rendering |
        HidePointer  = False,            ; <--                  Not handled |
        ScaleMode    = #SCALEMODE_NONE , ; <--                  Not handled |
        BGPic        = bgpic
        ; ScaleWidth,
        ; ScaleHeight,
        ; SmoothScale,
        ; FitScale,
        ; KeepProportions,
        ; DragRegion,
        ; SizeRegion,
        ; Layers
        })
  EndIf

  ;::: ROOT GADGET & MENU :::::::::::::::::::::::::::::::::::::::::::::::::::::
  HGui.SetAutoRendering(False)
  NewWin.root = HGui.Gadget:new(#HGUI_BOX_GADGET, { window = NewWin, name = NewWin.name .. "_rootgadget", look = { nskin = HGui.theme.root.nskin }, size = { w = NewWin.size.w - 1, h = NewWin.size.h - 1 }, usecache = NewWin.CacheRoot } )
  NewWin.root.private.IsMasterRoot = True
  NewWin.menu = HGui.Gadget:new(#HGUI_BOX_GADGET, { window = NewWin, name = NewWin.name .. "_menugadget", look = { nskin = HGui.theme.menu.nskin }, usecache = NewWin.CacheRoot } )
  NewWin.menu.private.IsMenu = True
  NewWin.rootgadget = HGui.Gadget:new(#HGUI_BOX_GADGET, { window = NewWin, name = NewWin.name .. "_rootgadgetarea", look = { nskin = HGui.theme.empty.nskin }, size = { w = NewWin.size.w - 1, h = NewWin.size.h - 1 }, usecache = NewWin.CacheRoot } )
  NewWin.rootgadget.private.IsRoot = True
  HGui.SetAutoRendering(True)

  ;::: CONTEXTUAL RMB MENU ::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "contextual")
    NewWin.Contextual = options.contextual
  EndIf

  ; Check if we have to open or not the created window
  If TB.Item.Exists(options, "dontopen") Then NewWin.DontOpen = options.DontOpen
  If NewWin.DontOpen = False
    ;--| OPEN THE WINDOW |--    
    If Not(first_window) Then OpenDisplay(NewWin.private.HWId, True)
    NewWin.private.opened = True

    ; Attach the event handlers and store the window into the windows stack
    NewWin:enableEvents()
    InsertItem(HGui.WinOrder, NewWin, 0)
    HGui.ActiveWindow = NewWin

  Else
    ; --| DON'T OPEN THE WINDOW |--
    If first_window
      NewWin.private.opened = True
      NewWin.private.hidden = True
      NewWin:disableEvents()
      HideDisplay()
    Else
      NewWin.private.opened = False
      NewWin.private.hidden = False
      NewWin:disableEvents()
      CloseDisplay(NewWin.Private.HWId)
    EndIf
  EndIf

  ;::: MENU :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  Local MenuHeight = 1.01

  If TB.Item.Exists(options, "menu")
    MenuHeight = HGui.Theme.Menu.Height
    NewWin:menuSet(Options.Menu)
  Else
    NewWin.root:layoutSet({ gadgets = { NewWin.rootgadget},
                            weights = { 1 },
                            gap = 0,
                            type =  #HGUI_VERTICAL_LAYOUT,
                            borders = { top = 0, bottom = 0, left = 0, right = 0 }}, True)
  EndIf

  ; Stores the new window in the windows list
  InsertItem(HGui.Windows, NewWin)

  DBG.Console.Out("created -> " .. ToString(NewWin.Name), DBG.CloseFunc, HGui.WChannel)
  Return(NewWin)

EndFunction


Function HGui.Window:set(options) ; *TriDoc*
/*---------------------------------------------------------
HGui.Window:set(options)

Change an existing window.
-----------------------------------------------------------
INPUT
  options : Table used to configure the window

NOTES
  For available option's fields have a look at the HGui.Window:new() method.
---------------------------------------------------------*/
   DBG.Console.Out(":set() -> " .. ToString(self.Name) .. ", (" .. ToString(options) .. ")", DBG.OpenFunc, HGui.WChannel)

   SelectDisplay(self.private.HWId, True)

   Local refresh = False
   
   ;::: TITLE ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
   If TB.Item.Exists(options, "title")
      self.title = options.title
   EndIf

   ;::: POSITION :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
   If TB.Item.Exists(options, "position")
      If TB.Item.Exists(options.position, "x") Then self.position.x = options.position.x
      If TB.Item.Exists(options.position, "y") Then self.position.y = options.position.y
   EndIf

   ;::: SIZE :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
   If TB.Item.Exists(options, "size")
      If TB.Item.Exists(options.size, "w")
         If options.size.w > 0 Then self.size.w = options.size.w
      EndIf
      If TB.Item.Exists(options.size, "h")
         If options.size.h > 0 Then self.size.h = options.size.h
      EndIf

      ; Check the boundaries
      If self.size.w > self.sizemax.w
         self.size.w = self.sizemax.w
      EndIf
      If self.size.h > self.sizemax.h
         self.size.h = self.sizemax.h
      EndIf

      If self.size.w < self.sizemin.w
         self.size.w = self.sizemin.w
      EndIf
      If self.size.h < self.sizemin.h
         self.size.h = self.sizemin.h
      EndIf

      Local ScreenW = self.size.w
      Local ScreenH = self.size.h
      
      ; RootObject handling : resizing this gadget will resize all the attached gadgets
      self.root:set({ size = { w = ScreenW - 1, h = ScreenH - 1 }}, False)
      
      self.NativeSize = CopyTable(self.Size) ; <-- Used by the layout engine

      refresh = True
   EndIf

   ;::: FLAGS ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
   If TB.Item.Exists(options, "flags")
      If TB.Item.Exists(options.flags, "resizeable") Then self.flags.resizeable = options.flags.resizeable
      If TB.Item.Exists(options.flags, "closeable" ) Then self.flags.closeable  = options.flags.closeable
      If TB.Item.Exists(options.flags, "moveable"  ) Then self.flags.moveable   = options.flags.moveable
      If TB.Item.Exists(options.flags, "borderless") Then self.flags.borderless = options.flags.borderless
      If TB.Item.Exists(options.flags, "modal"     ) Then self.flags.modal      = options.flags.modal
      If TB.Item.Exists(options.flags, "hideable"  ) Then self.flags.hideable   = options.flags.hideable
      If TB.Item.Exists(options.flags, "autoclose" ) Then self.flags.autoclose  = options.flags.autoclose
      refresh = True
   EndIf

   ;::: CHECK AND RECTIFY INCOMPATIBLE FLAGS :::::::::::::::::::::::::::::::::::
   If self.flags.modal
      self.flags.closeable = False
      self.flags.hideable  = False
   EndIf

   ;::: HOT KEYS :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
   ; HotKeys = { Hide = { Qualifier = "LCONTROL", Key = "A" }, ... }
   If TB.Item.Exists(options, "hotkeys")
      If TB.Item.Exists(options.HotKeys, "hide"    ) Then self.Private.HotKeys.Hide = options.HotKeys.Hide
      If TB.Item.Exists(options.HotKeys, "show"    ) Then self.Private.HotKeys.Show = options.HotKeys.Show
      If TB.Item.Exists(options.HotKeys, "close"   ) Then self.Private.HotKeys.Close = options.HotKeys.Close
      If TB.Item.Exists(options.HotKeys, "open"    ) Then self.Private.HotKeys.Open = options.HotKeys.Open
      If TB.Item.Exists(options.HotKeys, "activate") Then self.Private.HotKeys.Activate = options.HotKeys.Activate
   EndIf
   ; CustomHotKeys = { { Qualifier = "", Key = "", Event = "", Callback = function } }
   If TB.Item.Exists(options, "customhotkeys")
     self.Private.CustomHotKeys = options.CustomHotKeys
   EndIf
   
   ;::: EVENTS :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
   ;:: To Uninstall a callback pass 0 as callback function
   If TB.Item.Exists(options, "events")
      If TB.Item.Exists(options.events, "onclose"     ) Then self.events.onclose      = options.events.onclose
      If TB.Item.Exists(options.events, "onmove"      ) Then self.events.onmove       = options.events.onmove
      If TB.Item.Exists(options.events, "onactivate"  ) Then self.events.onactivate   = options.events.onactivate
      If TB.Item.Exists(options.events, "ondeactivate") Then self.events.ondeactivate = options.events.ondeactivate
      If TB.Item.Exists(options.events, "onhide"      ) Then self.events.onhide       = options.events.onhide
      If TB.Item.Exists(options.events, "onshow"      ) Then self.events.onshow       = options.events.onshow
      If TB.Item.Exists(options.events, "onsize"      ) Then self.events.onsize       = options.events.onsize
   EndIf

   ;============================================================================

   SetDisplayAttributes(
      { ;Width        = self.size.w,
        ;Height       = self.size.h,
        Color        = BgColor,
        ;x            = self.position.x,
        ;y            = self.position.y,
        Title        = self.title,
        Borderless   = self.flags.borderless,
        Sizeable     = self.flags.resizeable,
        Fixed        = Not(self.flags.moveable),
        NoHide       = Not(self.flags.hideable),
        NoModeSwitch = False,            ; <--                  Not handled |
        Active       = True,             ; <--  Active for gadget rendering |
        HidePointer  = False,            ; <--                  Not handled |
        ScaleMode    = #SCALEMODE_NONE , ; <--                  Not handled |
        ; ScaleWidth,
        ; ScaleHeight,
        ; SmoothScale,
        ; FitScale,
        ; KeepProportions,
        ; DragRegion,
        ; SizeRegion,
        ; Layers
        })
        
   If refresh
     ChangeDisplaySize(self.size.w, self.size.h, { x = self.position.x, y = self.position.y })

     SetDisplayAttributes({ NoClose = Not(self.flags.closeable) } )

     self:disableEvents()
     self:enableEvents()
     self:Render()
   
   EndIf
   
   DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)

EndFunction

Function HGui.windowActivateByName(win_name) ; *TriDoc*
/*-------------------------------------
result = HGui.windowActivateByName(win_name)

Returns true if the window exists and was activated.

INPUT
  win_name : Name of the window to activate
---------------------------------------*/
  Local result = False
  
  Local found, idx = HGui.windowFindByName(win_name)
  If found
    Local w = HGui.Windows[idx]
    If w:isHidden()
      w:Show()
    
    ElseIf w:IsClosed()
      w:Open()
      
    EndIf
    
    w:Activate()
    result = True
    
  Else
    result = False
    
  EndIf
  
  Return(result)
  
EndFunction

Function HGui.Window:activate() ; *TriDoc*
/*---------------------------------------------------------
HGui.Window:activate()

Activate the window.
-----------------------------------------------------------
NOTES
  Locates the window position in <WinOrder> and put it to the top of the stack then activate it and make it the frontmost window.
---------------------------------------------------------*/
   DBG.Console.Out(":activate() -> " .. ToString(self.Name), DBG.OpenFunc, HGui.WChannel)

   ; Skip if already active
   ; [WARN] : ATTENZIONE
   ; non so perch√® ma questo pezzo di codice ho dovuto commentarlo
   ; perch√® mi incasina la gestione dei menu...
   /*
   If self = HGui.WinOrder[0]
      DBG.Console.Out("* Already ACTIVE *", DBG.Warning, HGui.WChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
      Return(False)
   EndIf */

   ;*** Seems there is a strange bug that does not let activate the last     ***
   ;*** created window if before the active window isn't activated again...  ***
   SelectDisplay(HGui.WinOrder[0].private.HWId)
   ;****************************************************************************

   Local i, v = NextItem(HGui.WinOrder)
   While GetType(i) <> #NIL
      If v = self
         TB.PushUp(HGui.WinOrder, i)
         Break()
      EndIf
      i, v = NextItem(HGui.WinOrder, i)
   Wend

   DBG.Console.Out("-> Activating Window : " .. HGui.WinOrder[0].Title, Nil, HGui.WChannel)   
   ActivateDisplay(HGui.WinOrder[0].private.HWId, False)
   SelectDisplay(HGui.WinOrder[0].private.HWId, False)
   HGui.ActiveWindow = HGui.WinOrder[0]

   DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
   Return(True)
EndFunction


Function HGui.Window:open() ; *TriDoc*
/*---------------------------------------------------------
result = HGui.Window:open()

Open the window if it has been previously closed.
Along with the opening all event handlers will be enabled.
-----------------------------------------------------------
OUTPUT
  result : FALSE if the window is already opened.
---------------------------------------------------------*/
   DBG.Console.Out(":open() -> " .. ToString(self.Name), DBG.OpenFunc, HGui.WChannel)

   If Not(self.private.closed)
      DBG.Console.Out("Already opened.", DBG.Warning, HGui.WChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
      Return(False)
   EndIf

   ; Install Event Handlers
   self:enableEvents()

   ; Open display
   OpenDisplay(self.private.HWId)
   self.private.closed = False
   InsertItem(HGui.WinOrder, self, 0)
   
   DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
   Return(True)
EndFunction


Function HGui.Window:isClosed() ; *TriDoc*
/*---------------------------------------------------------
result = HGui.Window:isClosed()

Returns TRUE if the window is closed, FALSE otherwise.
-----------------------------------------------------------
OUTPUT
  result : TRUE if the window is closed.
---------------------------------------------------------*/
   Return(self.private.Closed)

EndFunction


Function HGui.Window:close() ; *TriDoc*
/*---------------------------------------------------------
result = HGui.Window:close()


Close the window if it's currently opened.
-----------------------------------------------------------
OUTPUT
  result : FALSE if the window is already closed.

NOTES
  Along with the closing all event handlers will be disabled. As soon as the window is closed another one will be activated following the current window's order.
  Hidden windows cannot be closed directly.
---------------------------------------------------------*/
   DBG.Console.Out(":close() -> " .. ToString(self.Name), DBG.OpenFunc, HGui.WChannel)

   If self.private.closed
      DBG.Console.Out("Already closed.", DBG.Warning, HGui.WChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
      Return(False)
   EndIf

   If self.private.hidden
      DBG.Console.Out("Cannot close hidden windows.", DBG.Warning, HGui.WChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
      Return(False)
   EndIf

   ; Remove Events Handlers
   self:disableEvents()

   ; Check if there are opened windows to activate
   Local wc = ListItems(HGui.Windows) - 1
   Local opened = 0
   For Local i = 0 To wc
      If Not(HGui.Windows[i].private.closed) Then opened = opened + 1
   Next

   If opened > 1
      ; Find a window to activate
      self:activate_previous(True)
   Else
      If HGui.QuitOnLastWindow Then End
  EndIf

   ; Close display
   CloseDisplay(self.private.HWId)
   self.private.closed = True

   DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
   Return(True)
EndFunction


Function HGui.Window:show() ; *TriDoc*
/*---------------------------------------------------------
result = HGui.Window:show()

Show the window if it has been previously hidden.
All event handlers will be enabled.
-----------------------------------------------------------
OUTPUT
  result : Returns FALSE if the window is already visible.
---------------------------------------------------------*/
   DBG.Console.Out(":show() -> " .. ToString(self.Name), DBG.OpenFunc, HGui.WChannel)

   If Not(self.private.hidden)
      DBG.Console.Out("It's not hidden.", DBG.Warning, HGui.WChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
      Return(False)
   EndIf

   ; Install Event Handlers
   self:enableEvents()

   ; Show display
   ShowDisplay()
   self.private.closed = False
   InsertItem(HGui.WinOrder, self, 0)

   DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
   Return(True)
EndFunction


Function HGui.Window:hide() ; *TriDoc*
/*---------------------------------------------------------
result = HGui.Window:hide()

Hide/Iconify the window if it's currently opened & visible.
All event handlers will be disabled.
-----------------------------------------------------------
OUTPUT
  result : Returns FALSE if the window is closed or already hidden.
---------------------------------------------------------*/
   DBG.Console.Out(":hide() -> " .. ToString(self.Name), DBG.OpenFunc, HGui.WChannel)

   If self.private.closed
      DBG.Console.Out("Cannot hide a closed window.", DBG.Warning, HGui.WChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
      Return(False)
   EndIf

   If self.private.hidden
      DBG.Console.Out("Already hidden.", DBG.Warning, HGui.WChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
      Return(False)
   EndIf

   ; Remove Events Handlers
   self:disableEvents()

   ; Hide display
   HideDisplay()
   self.private.hidden = True

   ; Find a window to activate
   self:activate_previous(True)

   DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
   Return(True)
EndFunction


Function HGui.Window:isHidden() ; *TriDoc*
/*---------------------------------------------------------
result = HGui.Window:isHidden()

Returns TRUE if the window is hidden, FALSE otherwise.
-----------------------------------------------------------
OUTPUT
  result : TRUE if the window is hidden.
---------------------------------------------------------*/
  Return(self.private.Hidden)

EndFunction


Function HGui.Window:isActive() ; *TriDoc*
/*---------------------------------------------------------
result = HGui.Window:isActive()

Returns TRUE if the window is active, FALSE otherwise.
-----------------------------------------------------------
OUTPUT
  result : TRUE if the window is active.
---------------------------------------------------------*/
  Return(self=HGui.ActiveWindow)

EndFunction

Function HGui.gadgetEvent_RMBUp(msg) ; *TriDoc*
/*---------------------------------------------------------
HGui.gadgetEvent_RMBUp(msg)

Internal function used to handle Right mouse click on the gadget's body to open
contextual menus.
-----------------------------------------------------------
INPUT
  msg : Right mouse up event message
---------------------------------------------------------*/
   Local Gadget = msg.userdata.area.object
   DBG.Console.Out(".gadgetEvent_RMBUp() on Gadget '" .. Gadget.Name .. "'", DBG.OpenFunc, HGui.DebugChannel)

  ; Se il gadget non √® attivo significa che il click √® arrivato
  ; senza evento OnOver
  If TB.Item.IsNil(HGui, "activegadget")
    HGui.gadgetEvent_Over(msg)
  ElseIf HGui.ActiveGadget <> Gadget
    HGui.gadgetEvent_Over(msg)
  EndIf
  
  ; Verifica se esiste un menu contestuale da aprire
  Local entries = ListItems(Gadget.Contextual)
  
  If entries > 0
    ; Utilizza le routine del menu di sistema per aprire il menu contestuale
    HGui.Menu_Open({ MenuDef = { submenu = Gadget.Contextual },
                     Area = 
                      { Position = { x = MouseX(), y = MouseY() },
                        Size = { w = 0, h = 0 } },
                     Window = Gadget.Window
                     })
  
  Else
    DBG.Console.Out("No contextual menu to open...", Nil, HGui.DebugChannel)
  EndIf
  
  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)

EndFunction

Function HGui.windowEvent_RMBUp(msg) ; SDOC
/*---------------------------------------------------------
HGui.windowEvent_RMBUp(msg)

Handle Right mouse click on the window's body to open contextual menus.
-----------------------------------------------------------
INPUT
  msg : Right Mouse button up event message.
---------------------------------------------------------*/
  DBG.Console.Out("HGui.windowEvent_RMBUp()", DBG.OpenFunc, HGui.DebugChannel)

  ; Problema che per ora risolvo cos√¨
  ; - Se c'√® un menu contestuale aperto ignoro i RMBUp perch√®
  ; sembra che se ne generino pi√π di uno
  If ListItems(HGui.MenuWindows) <> 0
    DBG.Console.Out("Ignoring RMBUp: a menu is opened", DBG.Hilight, HGui.DebugChannel)
    DBG.Console.Out("", DBG.CloseFunc, HGui.DebugChannel)
    Return()
    
  EndIf
  
  ; Dal momento che la gestione di questo evento √® abbastanza complicata devo
  ; per forza descriverne il funzionamento.
  ; 
  ; Questo evento viene segnalato dalla finestra ogni qualvolta che l'utente
  ; preme il tasto destro del mouse all'interno della finestra stessa, questo
  ; evento viene generato anche quando il puntatore del mouse si trova sopra un
  ; gadget attivo ed √® per questo che in caso di eventi provenienti da gadget
  ; disabilito la registrazione degli eventi della finestra con lo switch
  ; <IgnoreRMB>.
  ; Questo switch viene gestito dagli eventi dei gadget <Over> e <Out> che attivano
  ; e disattivano lo switch.
  ;
  ; Ci sono tutta un'altra serie particolare di eventi che devono essere gestiti,
  ; in particolare quando, con il tasto destro, si passa da una finestra ad
  ; un'altra: questi eventi sono descritti pi√π in basso nel corpo del codice.

  ; Evento proveniente da una finestra, cerca l'oggetto HGui.
  Local w = HGui.windowFindByHWID(msg.id)
  
  ; Verifico se l'oggestto √® stato trovato o meno
  If Not(IsNil(w))

    ; Adesso verifico se il RMB √® stato premuto su una finestra normale o su un
    ; menu, in quest'ultimo caso non faccio altro che chiudere il menu ed ignorare
    ; l'evento dal momento che i menu non devono supportare i RMB.
    If LeftStr(w.name, 8) = "::Menu::"
      HGui.Menu_Close()
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
      Return()
    EndIf
   
    ; Adesso cominciano le grane.
    ; Non so perch√® ma capita che la finestra che ha generato il RMB non sia attiva
    ; e questo provoca casini inenarrabili con le coordinate del mouse perch√® queste
    ; vengono rilevate per la finestra che prima del RMB era attiva √ß_√ß...
    ; Per ovviare a questo forzo l'attivazione della finestra che ha generato l'evento
    ; e poi leggo le coordinate del mouse.
    ; Se il puntatore del mouse non √® sul gadget attivo significa
    ; che l'evento proviene o da un'altro gadget o dalla finestra
    w:Activate()
    ActivateDisplay(w.private.HWId)
 
    Local xm, ym = MouseX(), MouseY()
    
    ; Verifico se esiste un gadget attivo perch√® in caso affermativo il puntatore
    ; del mouse si dovrebbe trovare sopra di esso, ma devo verificarlo.
    If TB.Item.Exists(HGui, "activegadget")
      ; Gadget attivo rilevato, verifico se il mouse si trova sopra di esso
      Local cGad = HGui.gadgetFindByHWIdAndPos(w.private.HWId, xm, ym)

      If IsNil(cGad) Or cGad <> HGui.ActiveGadget
        ; Il gadget attivo non corrisponde al gadget dove si trova il mouse oppure
        ; sotto al mouse non ch'√® alcun gadget.
        ; In questo caso l'ActiveGadget √® rimasto attivo per qualche altro motivo e
        ; deve essere disattivato generando a mano un evento.
        HGui.gadgetEvent_Out({ userdata = { area = { object = HGui.ActiveGadget }}})
        
        ; Se il gadget precedentemente attivo si trova in un'altra finestra mi 
        ; mi cambier√† il focus per poterlo disegnare, ecco perch√® devo riattivare la finestra
        w:Activate()
      Else
        ; Il gadget attivo corrisponde alla posizione del mouse, tutto ok perch√®
        ; potrebbe essere un menu contestuale del pulsante
      EndIf
    Else
      ; Nessun gadget attivo, tutto ok perch√® potrebbe essere un menu contestuale della
      ; finestra.
    EndIf
    
    If Not(w.IgnoreRMBUp)
      ; Gestione menu contestuali delle finestre attivata, scarto il messaggio se
      ; il puntatore si trova sopra un gadget con area attiva.
      Local cGad = HGui.gadgetFindByHWIdAndPos(w.private.HWId, xm, ym)

      If Not(IsNil(cGad))
        If cGad.Area.Active
          ; Se il puntatore si trova sopra un gadget ad area attiva l'evento della
          ; finestra deve essere ignorato perch√® gestito dall'altra routine.
          ; Comunque chiudo eventuali menu aperti.
          HGui.Menu_Close()
          DBG.Console.Out("No contextual menu to open...", Nil, HGui.DebugChannel)
          DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
          Return()
        EndIf
        
      EndIf
      
      ; Verifica se esiste un menu contestuale da aprire
      Local entries = ListItems(w.Contextual)
      If entries > 0
        ; Utilizza le routine del menu di sistema per aprire il menu contestuale
        HGui.Menu_Open({ MenuDef = { submenu = w.Contextual },
                         Area = 
                          { Position = { x = xm, y = ym },
                            Size = { w = 0, h = 0 } },
                         Window = w
                         })
      
      Else
        DBG.Console.Out("No contextual menu to open...", Nil, HGui.DebugChannel)
      EndIf
    Else
      ; Ignoro questo evento perch√® appartiene ad un gadget
    EndIf
  Else
    ; L'oggetto window dal quale proviene questo evento non √® stato trovato,
    ; questo √® un caso al limite del possibile.
    DBG.Console.Out("There is no window for this event!", DBG.Error, HGui.DebugChannel)
  EndIf
  
  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
EndFunction

Function HGui.Window:enableEvents() ; *TriDoc*
/*---------------------------------------------------------
HGui.Window:enableEvents()

Enable the window's event handlers.
-----------------------------------------------------------
NOTES
  Enables all supported window's events
---------------------------------------------------------*/
   DBG.Console.Out(":enableEvents() -> " .. ToString(self.Name), DBG.OpenFunc, HGui.WChannel)

   SelectDisplay(self.private.hwid)
   InstallEventHandler({ SizeWindow     = HGui.windowEvent_Resize   })
   InstallEventHandler({ MoveWindow     = HGui.windowEvent_Move     })
   InstallEventHandler({ ActiveWindow   = HGui.windowEvent_Active   })
   InstallEventHandler({ InactiveWindow = HGui.windowEvent_Inactive })
   InstallEventHandler({ HideWindow     = HGui.windowEvent_Hide     })
   InstallEventHandler({ ShowWindow     = HGui.windowEvent_Show     })
   InstallEventHandler({ CloseWindow    = HGui.windowEvent_Close    })
   InstallEventHandler({ OnMouseUp      = HGui.windowEvent_LMBUp    })
   InstallEventHandler({ OnDropFile     = HGui.windowEvent_Drop     })
   InstallEventHandler({ OnKeyDown      = HGui.Keyboard_Handler,
                         OnKeyUp        = HGui.Keyboard_Handler     })
   InstallEventHandler({ OnRightMouseUp = HGui.windowEvent_RMBUp    })
   InstallEventHandler({ OnWheelUp      = HGui.WindowEvent_MouseWheel })
   InstallEventHandler({ OnWheelDown    = HGui.WindowEvent_MouseWheel })
   ;InstallEventHandler({ OnMouseMove    = HGui.WindowEvent_MouseMove })

   DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
EndFunction

Function HGui.Window:disableGUI() ; *TriDoc*
/*---------------------------------------------------------
HGui.Window:disableGUI()

Disables all the active gadgets that are in this window.
---------------------------------------------------------*/

  self.rootgadget:Disable()
  
EndFunction

Function HGui.Window:enableGUI() ; *TriDoc*
/*---------------------------------------------------------
HGui.Window:enableGUI()

Enables all the active gadgets that are in this window.
---------------------------------------------------------*/

  self.rootGadget:Enable()
  
EndFunction

Function HGui.Window:disableEvents() ; *TriDoc*
/*---------------------------------------------------------
HGui.Window:disableEvents()

Disable the window's event handlers.
-----------------------------------------------------------
NOTES
  Disables all supported window's events
---------------------------------------------------------*/
   DBG.Console.Out(":disableEvents() -> " .. ToString(self.Name), DBG.OpenFunc, HGui.WChannel)

   SelectDisplay(self.private.hwid)
   InstallEventHandler({ SizeWindow     = 0 })
   InstallEventHandler({ MoveWindow     = 0 })
   InstallEventHandler({ ActiveWindow   = 0 })
   InstallEventHandler({ InactiveWindow = 0 })
   InstallEventHandler({ HideWindow     = 0 })
   InstallEventHandler({ ShowWindow     = 0 })
   InstallEventHandler({ CloseWindow    = 0 })
   InstallEventHandler({ OnMouseUp      = 0 })
   InstallEventHandler({ OnDrop         = 0 })
   InstallEventHandler({ OnKeyDown      = 0,
                         OnKeyUp        = 0 })
   InstallEventHandler({ OnRightMouseUp = 0 })
   InstallEventHandler({ OnWheelUp      = 0 })
   InstallEventHandler({ OnWheelDown    = 0 })
   ;InstallEventHandler({ OnMouseMove    = 0 })

   DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
EndFunction


Function HGui.Window:activate_previous(remove_this) ; *TriDoc*
/*---------------------------------------------------------
result = HGui.Window:activate_previous(remove_this)

Activate the prev window in the windows sorting stack. If 'remove_this' is True the current window object will be removed from the sorting stack.
-----------------------------------------------------------
INPUT
  remove_this : True to remove from the stack the current window

OUTPUT
  result : True if completed without errors

NOTES
  Internal function used to handle the window's focus
---------------------------------------------------------*/
  DBG.Console.Out(":activate_previous() -> " .. ToString(self.Name) .. ", (" .. ToString(remove_this) .. ")", DBG.OpenFunc, HGui.WChannel)

  If HL.IsNil(remove_this)
    DBG.Console.Out("missing <remove_this>, setting FALSE as default", DBG.Warning, HGui.WChannel)
    remove_this = False
     
  EndIf

  If TB.Item.Exists(self, "ismenu")
    ; This window is a menu
    DBG.Console.Out("Detected a menu-window", Nil, HGui.WChannel)
    ; Activate the parent window (upper level one)
    self.ParentWindow:Activate()

    For Local i = 0 To ListItems(HGui.WinOrder)-1
      If self = HGui.WinOrder[i]
        RemoveItem(HGui.WinOrder, i)
        Break()
      EndIf
    Next

    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
    Return()

  EndIf

  ; Search for the previous windows
  If ListItems(HGui.WinOrder) > 1
    Local i, v = NextItem(HGui.WinOrder)
    While GetType(i) <> #NIL
      If v = self
        Local pos = i + 1
        If pos > ListItems(HGui.WinOrder)-1
          pos = 0
          
        ElseIf i <> 0 ;If ListItems(HGui.WinOrder)-1 > 2 *** aggiunto <> 0
          HGui.WinOrder[0], HGui.WinOrder[pos] = HGui.WinOrder[pos], HGui.WinOrder[0]
          
        EndIf

        If remove_this
          RemoveItem(HGui.WinOrder, i)
          
        EndIf

        DBG.Console.Out("Activating <" .. HGui.WinOrder[0].Name .. ">", Nil, HGui.WChannel)
        SelectDisplay(HGui.WinOrder[0].private.HWId)
        Break()
        
      EndIf
      i, v = NextItem(HGui.WinOrder, i)
      
    Wend
  
  EndIf
   
  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
  Return(True)
   
EndFunction


Function HGui.Window:pushToBottom() ; *TriDoc*
/*---------------------------------------------------------
  HGui.Window:pushToBottom()
  
  Push the window to the bottom of the stack
----------------------------------------------------------*/
  Local i, v
  For i, v In Pairs(HGui.WinOrder)
    If v = self
      ; Found at position <i>, swap with the position [0]
      HGui.WinOrder[0], HGui.WinOrder[i] = HGui.WinOrder[i], HGui.WinOrder[0]
      For Local k = 1 To ListItems(HGui.WinOrder)-1
        ActivateDisplay(HGui.WinOrder[k].private.HWId)
      Next
      Break()
    EndIf
  Next
  
EndFunction

Function HGui.Window:activate_next(remove_this) ; *TriDoc*
/*---------------------------------------------------------
result = HGui.Window:activate_next(remove_this)

Activate the next window in the windows sorting stack. If 'remove_this' is True the current window object will be removed from the sorting stack.
-----------------------------------------------------------
INPUT
  remove_this : True to remove from the stack the current window

OUTPUT
  result : True if completed without errors

NOTES
  Internal function used to handle the window's focus
---------------------------------------------------------*/
  DBG.Console.Out(":activate_next() -> " .. ToString(self.Name) .. ", (" .. ToString(remove_this) .. ")", DBG.OpenFunc, HGui.WChannel)

  If HL.IsNil(remove_this)
    DBG.Console.Out("missing <remove_this>, setting FALSE as default", DBG.Warning, HGui.WChannel)
    remove_this = False
  
  EndIf

  ; Search for the next window
  Local i, v
  For i = 0 To ListItems(HGui.WinOrder)
    v = HGui.WinOrder[i]
    If v = self
      Local pos = i - 1
      If pos < 0 Then pos = ListItems(HGui.WinOrder)-1 ; TB.Count(HGui.WinOrder)-1
      HGui.WinOrder[0], HGui.WinOrder[pos] = HGui.WinOrder[pos], HGui.WinOrder[0]
      If remove_this Then RemoveItem(HGui.WinOrder, i)
      SelectDisplay(HGui.WinOrder[0].private.HWId)
      Break()
  
    EndIf

  Next

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
  Return(True)

EndFunction


Function HGui.Window:render() ; *TriDoc*
/*---------------------------------------------------------
HGui.Window:render()

Renders the window's root gadget and all its childs.
-----------------------------------------------------------
NOTES
  Using this methods will force a window refresh.
---------------------------------------------------------*/
   DBG.Console.Out(":render() -> " .. ToString(self.Name), DBG.OpenFunc, HGui.WChannel)

   If TB.Item.IsNil(self, "root")
      DBG.Console.Out("Root gadget not found!", DBG.Warning, HGui.WChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
      Return(False)
   EndIf

   GFX.OutputDevice.Select(#DISPLAY, self.private.HWId)
      Cls
      self.Root:render()
   GFX.OutputDevice.EndSelect()

   DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
EndFunction

Function HGui.Window:select() ; *TriDoc*
/*---------------------------------------------------------
HGui.Window:select()

Select the window as the current output device
Returns the previously active device
---------------------------------------------------------*/
   Local current, id = GetAttribute(#DISPLAY, self.private.HWId, #ATTROUTPUTDEVICE)
   GFX.OutputDevice.Select(#DISPLAY, self.private.HWId)
   GFX.OutputDevice.EndSelect()
   Return(current, id)

EndFunction

Function HGui.Window:free() ; *TriDoc*
/*---------------------------------------------------------
result = HGui.Window:free()

Free the current window and, if available, activate the previous window from the sorted stack.
-----------------------------------------------------------
OUTPUT
  result : True if the operation is completed without errors
---------------------------------------------------------*/
   DBG.Console.Out(":free() -> " .. ToString(self.Name), DBG.OpenFunc, HGui.WChannel)
   
   ; Check if it's a waiter window
   If TB.Item.Exists(self, "_waiterupdateid")
     ClearInterval(self._waiterUpdateId)
   EndIf
   
   If Not(self.private.closed) Then self:Close()

   ; Free all window's gadgets
   self.Root:free()
   self.Root = Nil
   
   self.menu:Free()
   self.menu = Nil
   
   self.RootGadget:Free()  
   self.Rootgadget = Nil

   ; Free window's from resources list
   Local s, i = HGui.windowFindByName(self.name)
   If GetType(s) = #TABLE
      RemoveItem(HGui.Windows, i)

      ; Find a window to activate
      ; *** NON POTREI UTILIZZARE ACTIVATE_PREVIOUS? ***
      ;DebugPrint("*** CHECK THIS !! ***")

      ; Se sto liberando un menu agisco in maniera diversa
      If TB.Item.IsNil(self, "ismenu")
        Local ActID = -1
        For Local i = TB.Count(HGui.Windows)-1 To 0 Step -1
           If HGui.Windows[i].private.Closed = False
              If HGui.Windows[i].private.Hidden = False
                 ActID = i
                 Break()
              EndIf
           EndIf
        Next

        If ActID <> -1
           SelectDisplay(HGui.Windows[ActID].private.HWId)
        Else
           DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
           Return(False)
        EndIf

        ;self:activate_previous(True)
        ; se esiste in WinOrder la elimina
        For Local k = 0 To ListItems(HGui.WinOrder)-1
           If HGui.WinOrder[k] = self
              RemoveItem(HGui.WinOrder, k)
              Break()
           EndIf
        Next
        
      Else
        self.ParentWindow:Activate()

        For Local i = 0 To ListItems(HGui.WinOrder)-1
           If self = HGui.WinOrder[i]
              RemoveItem(HGui.WinOrder, i)
              Break()
           EndIf
        Next

        DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
        Return()
      
      EndIf
      
      
      FreeDisplay(self.private.HWId)
      
      ; Free window's background
      If TB.Item.Exists(self.private, "bgid")
         FreeBGPic(self.private.BGId)
         self.private.BGId = Nil
      EndIf

      
      self = Nil
   Else
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
      Return(False)
   EndIf

   DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
   Return(True)

EndFunction

Function HGui.windowEvent_Drop(msg) ; *TriDoc*
/*---------------------------------------------------------
HGui.windowEvent_Drop(msg)

Internal function used to handle the drop event on a window.
---------------------------------------------------------*/
   Local win = HGui.windowFindByHWID(msg.id)
   DBG.Console.Out("Window Event from <" .. win.name .. "> --> Drop event", DBG.OpenFunc, HGui.WChannel)

   If TB.Item.Exists(win.events, "ondrop")
     win.events.OnDrop(msg)
   EndIf
   
   DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
   Return(True)

EndFunction

Function HGui.windowEvent_LMBUp(msg) ; *TriDoc*
/*---------------------------------------------------------
result = HGui.windowEvent_LMBUp(msg)


Callback function used to detect Left Mouse Button release to prevent some gadgets misfunctions.
-----------------------------------------------------------
INPUT
  msg : Event message, it must have the following fields
    id : Window id (numeric or LightUserData)
    action : Mouse action, it must be "OnMouseUp"

OUTPUT
  result : TRUE if there was no errors
---------------------------------------------------------*/
  ; #WINDOW, #MOUSE, #LMB
  
  ; Retrieve the sender window
  Local win = HGui.windowFindByHWID(msg.id)
  DBG.Console.Out("Window Event from '" .. win.name .. "' --> LMB Up", DBG.OpenFunc, HGui.WChannel)

  ; #DROPDOWNMENU
  ; If the event doesn't come from a menu I have to close all opened menus.
  If TB.Item.IsNil(win, "ismenu")
    HGui.Menu_Close()
  EndIf

  ; #LISTVIEW, #TREEVIEW
  ; Are we resizing a ListView or a TreeView column?
  If HGui.LVResizeColumnMode
    ; Released mouse, disable dragging routines
    HGui.LVResizeColumnMode = False
    InstallEventHandler({ OnMouseMove = 0 })
    HGui.LVResizeGadget.Status = #HGUI_HILIGHTED_STATE

    FreeSprite(HGui.LVSprite)
    HGui.LVResizeGadget.Father:Set({ data = { columnSizes = HGui.LVResizeSizes }}, True)
    
    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
    Return()
  EndIf 
  
  ; #SCROLLBAR
  ; SCROLLBAR CURSOR DRAGGING
  ; Check if we are dragging a scrollbar's cursor, if so terminate the drag
  ; operation.
  If HGui.ScrollBarDragging
    HGui.ScrollBarDragging = False
    InstallEventHandler({ OnMouseMove = 0 })
    ; If the drag has been already terminated skip it.
    If TB.Item.Exists(HGui, "scrollbarobject")
      If HGui.MouseInsideCursor
        HGui.ScrollBarObject.Status = #HGUI_HILIGHTED_STATE
      Else
        HGui.ScrollBarObject.Status = #HGUI_NORMAL_STATE
      EndIf
      HGui.ScrollBarObject:Render()
      HGui.ScrollBarObject = Nil
    EndIf
  EndIf

  HGui.PushedOut_Gadget = Nil

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
  Return(True)

EndFunction


Function HGui.windowEvent_Resize(msg) ; *TriDoc*
/*---------------------------------------------------------
result = HGui.windowEvent_Resize(msg)

Callback used to handle the GUI resize and the callback function attached to this event.
-----------------------------------------------------------
INPUT
  msg : Event message, it must have the following fields:
    id     : Window id (numeric or LightUserData)
    action : It must be "SizeWindow"
    height : The new window's size
    width  : The new window's size
  
OUTPUT
  result : TRUE if the resize has been handled
---------------------------------------------------------*/
  ; #WINDOW, #RESIZE
  ; DebugPrint("****************** RESIZE *************")
  ; DBG.DumpTable(msg)
  ; Retrieve the sender window
  Local win = HGui.windowFindByHWID(msg.id)
  DBG.Console.Out("Window Event from <" .. win.name .. "> --> Resize", DBG.OpenFunc, HGui.WChannel)

  ; #DROPDOWNMENU
  ; If the event doesn't come from a menu I have to close all opened menus.
  If TB.Item.IsNil(win, "ismenu")
    HGui.Menu_Close()
  EndIf

  ; Trick used to ignore some double resize event generated automatically
  ; SEMBRA CHE NON SERVA PIU' (25/06/2019)
  ; E INVECE SERVE ANCHE ANCORA! (29/07/2020)
  If win.private.IgnoreNxRes
    ;DebugPrint("Ignoring this resize!")
    win.private.IgnoreNxRes = False
    ;DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
    ;Return(False)
  EndIf 

  SelectDisplay(msg.id, True)

  ; #TODO
  ; #KEYBOARD
  ; Finalize any input active on string gadgets
  ; --- old code below ---
  ; If scui.Keyboard[w.Name].Mode = #KEYBOARD_INPUTMODE
  ;   scui.Keyboard_Handler( { key = Chr(10), action = "OnKeyDown", id = msg.id } )
  ; EndIf

  Local ScreenW = msg.width
  Local ScreenH = msg.height
  Local Force   = False

  /* COMMENTED BECAUSE IF THE EVENT COMES FROM A REAL
     RESIZE EVENT THE CONTENT IS CLEARED AND NOT REFRESHED
  ; Check if the resize is really needed
  If win.size.w = msg.Width
    If win.size.h = msg.Height
      ; No need to resize
      DebugPrint("* no need to resize")
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
      Return(False)
    EndIf
  EndIf */

  ; Check the boundaries, this is needed because on some systems the
  ; window borders can go out of screen boundaries.
  If ScreenW > win.sizemax.w
    DBG.Console.Out("Rectifing maximum width, from: " .. ScreenW .. " to " .. win.sizemax.w, DBG.Warning, HGui.WChannel)
    ScreenW = win.sizemax.w
    Force = True
  EndIf
  If ScreenH > win.sizemax.h
    DBG.Console.Out("Rectifing maximum height, from: " .. ScreenH .. " to " .. win.sizemax.h, DBG.Warning, HGui.WChannel)
    ScreenH = win.sizemax.h
    Force = True
  EndIf
  If ScreenW < win.sizemin.w
    DBG.Console.Out("Rectifing minimum width, from: " .. ScreenW .. " to " .. win.sizemin.w, DBG.Warning, HGui.WChannel)
    ScreenW = win.sizemin.w
    Force = True
  EndIf
  If ScreenH < win.sizemin.h
    DBG.Console.Out("Rectifing minimum height, from: " .. ScreenH .. " to " .. win.sizemin.h, DBG.Warning, HGui.WChannel)
    ScreenH = win.sizemin.h
    Force = True
  EndIf

  If Force
    DBG.Console.Out("Forcing display resize: " .. ScreenW .. "x" .. ScreenH, DBG.Warning, HGui.WChannel)
    ; The 'ChangeDisplaySize()' command will raise a resize event, but we already are
    ; in a resize event, so next event must be ignored!
    win.private.IgnoreNxRes = True
    ChangeDisplaySize(ScreenW, ScreenH, { x = #KEEPPOSITION, y = #KEEPPOSITION })
  EndIf
  
  ; RootObject handling : resizing this gadget will resize all the attached gadgets
  Local rw = win.root.area.size.w + 1
  Local rh = win.root.area.size.h + 1

  If (ScreenW <> rw) Or (ScreenH <> rh)
    ; Resize the entire window
    ;DebugPrint("* resizing from the root")
    win.root:set({ size = { w = ScreenW - 1, h = ScreenH - 1 }}, False)
    
    ; Check if it is a textbox widget
    If TB.Item.Exists(win, "_istextbox")
      ; Yes it is, recalc the label
      Local visibleLines = Int((win.boxLabel.Area.Size.h - 20)/win.boxLabel.Look.nText.Font.Size)-1
      Local wrapped = GFX.Text.WordWrap(win._sourceText, win.boxLabel.Area.Size.w - 20 - 32)
      win.boxLabel:Set({ Caption = wrapped }, False)
      win.ScrollBar:Set({ Value = win.ScrollBar.Private.Value, 
                          Range = { 1, ListItems(wrapped), visibleLines } }, False)
    EndIf
    
    win.root:render()
  Else ;If Force
    ; Commented Force flag because with real resize events the display
    ; is cleared but not redrawn
    ;DebugPrint("* resize, just render")
    win.root:render()
  EndIf
  
  ; Update the window structure
  win.size.w = ScreenW
  win.size.h = ScreenH

  ; Call the user function (if defined)
  msg.width = win.size.w
  msg.height = win.size.h
  win.events.onsize(msg, win)

  ; At the end of the rendering, that could be long, the window's size could
  ; be changed again, to prevent this situation I will force another size check
  /*
  Local CurrW, CurrH = GetAttribute(#DISPLAY, msg.id, #ATTRWIDTH), GetAttribute(#DISPLAY, msg.id, #ATTRHEIGHT)
  If (CurrW <> msg.Width) Or (CurrH <> msg.Height)
    msg.Width  = CurrW
    msg.Height = CurrH
    HGui.windowEvent_Resize(msg)
  EndIf */

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
  Return(True)

EndFunction


Function HGui.windowEvent_Move(msg) ; *TriDoc*
/*---------------------------------------------------------
result = HGui.windowEvent_Move(msg)

Callback used to handle the window move event and the callback function attached to this event.
-----------------------------------------------------------
INPUT
  msg : Event message, it must have the following fields:
    id     : Window id (numeric or LightUserData)
    action : It must be "MoveWindow"
    x      : The new window's horizontal position
    y      : The new window's vertical position
OUTPUT
  result : TRUE if the move has been handled
---------------------------------------------------------*/
  ; #WINDOW, #MOVE
  
  ; Retrieve the sender window
  Local win = HGui.windowFindByHWID(msg.id)
  
  ; #WARNING
  ; I don't remember why I've cheked the <msg> type...
  ; I'll leave it and put a message to check if it is raised somewhere
  If GetType(win) <> #TABLE
    DBG.Console.Out("HGui.windowEvent_Move() => msg is not a table!", DBG.Error, HGui.WChannel)
    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
    Return(False)
  EndIf

  DBG.Console.Out("Window Event from <" .. win.name .. "> --> Move", DBG.OpenFunc, HGui.WChannel)

  ; #DROPDOWNMENU
  ; If the event doesn't come from a menu I have to close all opened menus.
  If TB.Item.IsNil(win, "ismenu")
    HGui.Menu_Close()
  EndIf

  ; Update the coordinates
  Local oldx = win.position.x
  Local oldy = win.position.y
  win.position.x = msg.x
  win.position.y = msg.y

  ; Call the user function (if defined)
  msg.previousX = oldx
  msg.previousY = oldy
  win.events.onmove(msg, win)

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
  Return(True)

EndFunction


Function HGui.windowEvent_Active(msg) ; *TriDoc*
/*---------------------------------------------------------
result = HGui.windowEvent_Active(msg)

Callback used to handles the window activation event and the callback function attached to this event.
-----------------------------------------------------------
INPUT
  msg : Event message, it must have the following fields:
    id     : Window id (numeric or LightUserData)
    action : It must be "ActiveWindow"

OUTPUT
  result : TRUE if the activation has been handled
---------------------------------------------------------*/
  ; #WINDOW, #ACTIVATE
  If HGui.ignoreNextWindowAEvents = True
    HGui.ignoreNextWindowAEvents = False
    Return()
  EndIf
  
  ; Retrieve the sender window
  Local win = HGui.windowFindByHWID(msg.id)
  
  ; #WARNING
  ; I don't remember why I've cheked the <msg> type...
  ; I'll leave it and put a message to check if it is raised somewhere
  If GetType(win) <> #TABLE
    DBG.Console.Out("HGui.windowEvent_Active() => msg is not a table!", DBG.Error, HGui.WChannel)
    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
    Return(False)
  EndIf

  DBG.Console.Out("Window Event from <" .. win.name .. "> --> Active", DBG.OpenFunc, HGui.WChannel)
  
  ; #DROPDOWNMENU
  ; If the event doesn't come from a menu I have to close all opened menus.
  If TB.Count(HGui.MenuWindows) > 0
    If TB.Item.IsNil(win, "ismenu")
      ; I have to close the menu only if the activated window isn't
      ; a floating tip!
      
      ; 14/02/2023 : After several tries to handle the activate/deactivate window events
      ;      to correctly activate the right window I come with the solution below which
      ;      skip the next activate and unactivate window's events and to avoid an
      ;      infinite event loop.
      If TB.Item.IsNil(win, "istip")
        HGui.Menu_Close()
        HGui.ignoreNextWindowAEvents = True
        HGui.ignoreNextWindowDEvents = True
        win:activate()

      ElseIf win.IsTip = False
        HGui.Menu_Close()
        HGui.ignoreNextWindowAEvents = True
        HGui.ignoreNextWindowDEvents = True
        win:activate()

      EndIf
      
    EndIf
  EndIf
  
  ; Store this window as the currently active
  HGui.ActiveWindow = win
  
  ; Callback function
  win.events.onactivate(msg, win)

  ; Update the windows sorting stack
  Local i, v
  For i, v In IPairs(HGui.WinOrder)
    If v = win
      ; Put this window on the top of the stack
      TB.PushUp(HGui.WinOrder, i)
      Break()
    EndIf
  Next
  
  /* OLD IMPLEMENTATION REPLACED ON 17/07/2017
    ------------------------------------------
  Local i, v = NextItem(HGui.WinOrder)
  While GetType(i) <> #NIL
    If v = win
      TB.PushUp(HGui.WinOrder, i)
      Break()
    EndIf
    i, v = NextItem(HGui.WinOrder, i)
  Wend */

  
  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
  Return(True)

EndFunction


Function HGui.windowEvent_Inactive(msg) ; *TriDoc*
/*---------------------------------------------------------
result = HGui.windowEvent_Inactive(msg)

Callback used to handles the window inactive event and the callback function attached to this event.
-----------------------------------------------------------
INPUT
  msg : Event message, it must have the following fields:
    id     : Window id (numeric or LightUserData)
    action : It must be "InactiveWindow"
OUTPUT
  result : TRUE if the deactivation has been handled
---------------------------------------------------------*/
  ; #WINDOW, #DEACTIVATE
  If HGui.ignoreNextWindowDEvents = True
    HGui.ignoreNextWindowDEvents = False
    Return()
  EndIf
  
  ; #WARNING
  ; When a window loose its focus the active gadget status must be return to
  ; its normal state (if it was in a over state).

  ; Retrieve the sender window
  Local win = HGui.windowFindByHWID(msg.id)

  ; #WARNING
  ; I don't remember why I've cheked the <msg> type...
  ; I'll leave it and put a message to check if it is raised somewhere
  If GetType(win) <> #TABLE
    DBG.Console.Out("HGui.windowEvent_Active() => msg is not a table!", DBG.Error, HGui.WChannel)
    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
    Return(False)
  EndIf

  DBG.Console.Out("Window Event from <" .. win.name .. "> --> Inactive", DBG.OpenFunc, HGui.WChannel)
  
  ; #SCROLLBAR
  ; Are we dragging a scrollbar's cursor?
  If HGui.ScrollBarDragging = True
    ; If YES we have to turn off the dragging
    HGui.ScrollBarDragging = False
    InstallEventHandler({ OnMouseMove = 0 })
    If TB.Item.Exists(HGui, "scrollbarobject")
      HGui.ScrollBarObject.Status = #HGUI_NORMAL_STATE
      HGui.ScrollBarObject:Render()
      HGui.ScrollBarObject = Nil
    EndIf
  EndIf

  ; Callback function
  win.events.ondeactivate(msg, win)

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
  Return(True)

EndFunction


Function HGui.windowEvent_Hide(msg) ; *TriDoc*
/*---------------------------------------------------------
result = HGui.windowEvent_Hide(msg)

Callback used to handles the window hide event and the callback function attached to this event.
-----------------------------------------------------------
INPUT
  msg : Event message, it must have the following fields:
    id     : Window id (numeric or LightUserData)
    action : It must be "HideWindow"

OUTPUT
  result : TRUE if the hide event has been handled
---------------------------------------------------------*/
  ; #WINDOW, #HIDE

  ; Retrieve the sender window
  Local win = HGui.windowFindByHWID(msg.id)

  DBG.Console.Out("Window Event from <" .. win.name .. "> --> Hide", DBG.OpenFunc, HGui.WChannel)

  ; Mark this window as hidden
  win.private.hidden = True

  ; #DROPDOWNMENU
  ; If the event doesn't come from a menu I have to close all opened menus.
  If TB.Item.IsNil(win, "ismenu")
    HGui.Menu_Close()
  EndIf

  ; Callback function
  win.events.onhide(msg, win)

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
  Return(True)
  
EndFunction

Function HGui.windowEvent_MouseMove(msg) ; *TriDoc*
/*---------------------------------------------------------
HGui.windowEvent_MouseMove(msg)

Callback used to handle the mouse movement and also manage Canvas active gadget.
-----------------------------------------------------------
INPUT
  msg : Event message, it must have the following fields:
    id     : Window id (numeric or LightUserData)
    action : It must be "OnMouseMove"
    x      : Horizontal mouse coordinate
    y      : Vertical mouse coordinate
---------------------------------------------------------*/
  ; #WINDOW, #MOUSE
  
  ; Check for an hilighted gadget
  If TB.Item.Exists(HGui, "activegadget")
    ; Check if it's a CANVAS Gadget
    ; #CANVAS
    If HGui.ActiveGadget.Type = #HGUI_CANVAS_GADGET
      ; Check if there is a callback associated
      If TB.Item.Exists(HGui.ActiveGadget.Actions, "onmove")
        ; Calculate coordinates
        Local absX, absY = msg.X, msg.Y
        Local offsetGad = HGui.ActiveGadget.OutputBox.Area.Position
        ;Local offsetVirt = HGui.ActiveGadget.Virtual.VBox.VirtualOffset
        HGui.ActiveGadget.Actions.OnMove(HGui.ActiveGadget, absX-offsetGad.x, absY-offsetGad.y)
      EndIf
    EndIf
  EndIf
  
EndFunction

Function HGui.windowEvent_MouseWheel(msg) ; *TriDoc*
/*---------------------------------------------------------
result = HGui.windowEvent_MouseWheel(msg)

Callback to handle the mouse wheel event and manage ListViews and TreeView 
active gadgets.
-----------------------------------------------------------
INPUT
  msg : Event message, it must have the following fields:
    action : It must be "OnWheelUp" or "OnWheelDown"

OUTPUT
  result : TRUE if the activation has been handled
---------------------------------------------------------*/
  ; #WINDOW, #MOUSE
  
  ; Retrieve the sender window
  Local win = HGui.windowFindByHWID(msg.id)
  DBG.Console.Out("Window Event from <" .. win.name .. "> --> MouseWheel", DBG.OpenFunc, HGui.WChannel)

  ; Check for an hilighted gadget
  If TB.Item.Exists(HGui, "activegadget")
    ; #LISTVIEW, #TREEVIEW
    ; Check if it's a ListView or a TreeView
    If HGui.ActiveGadget.Type = #HGUI_LISTVIEW_GADGET Or
       HGui.ActiveGadget.Type = #HGUI_TREEVIEW_GADGET

      ; Check if no mouse buttons are pressed
      If Not(IsLeftMouse()) And Not(IsRightMouse()) And Not(IsMidMouse())
        ; Handle the event
        Local incLine = 1
        Local vScroller = HGui.ActiveGadget.VScroller
        If IsKeyDown(HGui.ActiveGadget.WheelPageQualifier) Then incLine = vScroller.Range[2]
        If msg.Action = "OnWheelUp"
          ;-- MOUSE WHEEL UP (Scroll Up) --
          If IsKeyDown(HGui.ActiveGadget.WheelSEQualifier)
            vScroller:Set({ value = vScroller.Range[0] }, True)
          Else
            vScroller:Set({ value = vScroller.private.value-incLine }, True)
          EndIf
          
        ElseIf msg.Action = "OnWheelDown"
          ; MOUSE WHEEL DOWN (Scroll Down)
          If IsKeyDown(HGui.ActiveGadget.WheelSEQualifier)
            vScroller:Set({ value = vScroller.Range[1] }, True)
          Else
            vScroller:Set({ value = vScroller.private.value+incLine }, True)
          EndIf

        EndIf
        
      EndIf
      
    EndIf
    
  EndIf
  
  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
  
EndFunction

Function HGui.windowEvent_Show(msg) ; *TriDoc*
/*---------------------------------------------------------
result = HGui.windowEvent_Show(msg)

Callback used to handle the window show event and the callback function attached to this event.
-----------------------------------------------------------
INPUT
  msg : Event message, it must have the following fields:
    id     : Window id (numeric or LightUserData)
    action : It must be "ShowWindow"

OUTPUT
  result : TRUE if the show event has been handled
---------------------------------------------------------*/
  ; #WINDOW, #SHOW
  
  ; Retrieve the sender window
  Local win = HGui.windowFindByHWID(msg.id)

  DBG.Console.Out("Window Event from <" .. win.name .. "> --> Show", DBG.OpenFunc, HGui.WChannel)

  ; Mark this window as visible
  win.private.hidden = False

  ; Callback function
  win.events.onshow(msg, win)

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
  Return(True)

EndFunction


Function HGui.windowEvent_Close(msg) ; *TriDoc*
/*---------------------------------------------------------
result = HGui.windowEvent_Close(msg)

Callback used to handle the window close event and the callback function attached to this event.
-----------------------------------------------------------
INPUT
  msg : Event message, it must have the following fields:
    id     : Window id (numeric or LightUserData)
    action : It must be "CloseWindow"

OUTPUT
  result : TRUE if the close event has been handled
---------------------------------------------------------*/
  ; #WINDOW, #CLOSE
  
  ; Retrieve the sender window
  Local win = HGui.windowFindByHWID(msg.id)
  
  DBG.Console.Out("Window Event from <" .. win.name .. "> --> Close", DBG.OpenFunc, HGui.WChannel)

  ; #DROPDOWNMENU
  ; If the event doesn't come from a menu I have to close all opened menus.
  If TB.Item.IsNil(win, "ismenu")
    HGui.Menu_Close()
  EndIf

  ; #WARNING
   /*  *** P E R C H E '   S E R V E   S T A   R O B A ???
       * Io credo che non serva a una ceppa, infatti adesso quando viene chiusa|
       * anche l'ultima finestra il programma rimane attivo (come deve essere) |
       * sta al programmatore gestire gli eventi di chiusura delle finestre e  |
       * relativo shutdown del programma. eccheccazzo!                         |
       * Anche perch√® ci potrebbero essere delle finestre nascoster o chiuse in|
       * attesa di essere riattivate.                                          |
       * ********************************************************************* |
   Local wc = TB.Count(HGui.Windows) - 1
   Local opened = 0
   For Local i = 0 To wc
      If Not(HGui.Windows[i].private.closed) Then opened = opened + 1
   Next

   If opened = 1
      DBG.Console.Out("[-ERROR-] Cannot close the last opened window (you can instead hide it)", DBG.CloseFunc)
      Return(False)
   EndIf
   */
   
  ; Check if this window has an auto-close flag set
  If win.flags.autoclose Then win:close()

  ; Callback function
  win.events.onclose(msg, win)
   
  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
  Return(True)

EndFunction


Function HGui.windowExists(window_name) ; *TriDoc*
/*-------------------------------------------------------------------
result = HGui.windowExists(window_name)

Return TRUE if the window identified by <window_name> exists.
---------------------------------------------------------------------
INPUT
  window_name : The window's name we want to check

OUTPUT
  result : TRUE if the window exists otherwise FALSE

EXAMPLE
  | ; Check if the window named 'mainWindow' exists
  | If HGui.windowExists("mainWindow")
  |   DebugPrint("YES, Exists!")
  | Else
  |   DebugPrint("Window not found!")
  | EndIf
------------------------------------------------------------------*/
  ; #WINDOW
  
  Local w = HGui.windowFindByName(window_name)
   
  If GetType(w) = #TABLE
    Return(True)
  Else
    Return(False)
  EndIf

EndFunction


Function HGui.windowFindByName(window_name) ; *TriDoc*
/*-------------------------------------------------------------------
winObject, index = HGui.windowFindByName(window_name)

Search the window named <window_name> and return its object and the index position in the HGui.Windows table, or returns FALSE if the window has not been found.
---------------------------------------------------------------------
INPUT
  window_name : Window name to search for

OUTPUT
  result : Found windows object or FALSE
  index  : Window's index in HGui.Windows table or Nil 

EXAMPLE
  | ; Get the window object of the window named 'mainWindow'
  | Local winObj = HGui.windowFindByName("mainWindow")
  | If GetType(winObj) <> #TABLE
  |   DebugPrint("Window does not exists!")
  | EndIf
------------------------------------------------------------------*/
  ; #WINDOW
  
  Local i, v = NextItem(HGui.Windows)
  While GetType(i) <> #NIL
    If v.name = window_name
      Return(v, i)
    EndIf
    i, v = NextItem(HGui.Windows, i)
  Wend

  Return(False)

EndFunction


Function HGui.windowFindByHWID(HWId) ; *TriDoc*
/*-------------------------------------------------------------------
winObject, index = HGui.windowFindByHWID(HWId)

Search the window with the id <HWID> and return its object and the index position in the HGui.Windows table, or returns <False> if the window has not been found.
---------------------------------------------------------------------
INPUT
  HWId : Hollywood Window's ID

OUTPUT
  result : Found windows object or FALSE
  index  : Window's index in HGui.Windows table or Nil 
------------------------------------------------------------------*/
  ; #WINDOW
  
  Local i, v = NextItem(HGui.Windows)
  While GetType(i) <> #NIL
    If GetType(v.private.HWId) = GetType(HWId)
      If v.private.HWId = HWId
        Return(v, i)
      EndIf
    EndIf
    i, v = NextItem(HGui.Windows, i)
  Wend

  Return(False)

EndFunction


/* ****************************************************************************
   END CLASS
   ****************************************************************************/


   
Function HGui.Keyboard_Handler(msg) ; SDOC, NOT YET COMPLETED
/*---------------------------------------------------------
HGui.Keyboard_Handler(msg)

Callback used to handle any incoming keyboard input.
-----------------------------------------------------------
INPUT
  msg : Message table returned by the event handler.

NOTE
  This function is NOT YET COMPLETED.
---------------------------------------------------------*/
  ; #KEYBOARD
  
  DBG.Console.Out("************************************************", DBG.Warning, HGui.DebugChannel)
  DBG.Console.Out("*** [HGui.Keyboard_Handler] **** INCOMPLETE ****", DBG.Warning, HGui.DebugChannel)
  DBG.Console.Out("************************************************", DBG.Warning, HGui.DebugChannel)

  Local qualifiers = {}
  qualifiers["lcontrol"] = IsKeyDown("LCONTROL")
  qualifiers["rcontrol"] = IsKeyDown("RCONTROL")
  qualifiers["lalt"    ] = IsKeyDown("LALT")
  qualifiers["ralt"    ] = IsKeyDown("RALT")
  qualifiers["lcommand"] = IsKeyDown("LCOMMAND")
  qualifiers["rcommand"] = IsKeyDown("RCOMMAND")
  qualifiers[""        ] = IIf(qualifiers["lcontrol"]=False And 
                               qualifiers["rcontrol"]=False And
                               qualifiers["lalt"    ]=False And
                               qualifiers["ralt"    ]=False And
                               qualifiers["lcommand"]=False And
                               qualifiers["rcommand"]=False, True, False)
  If msg.Action = "OnKeyDown"
    ; Window's shortcuts
    For i, v In Pairs(HGui.Windows)
      ;--- Window's HotKeys ---
      Local wHotKeys = v.Private.HotKeys
      If TB.Item.Exists(wHotKeys, "hide")
        If (qualifiers[wHotKeys.Hide.Qualifier] And wHotKeys.Hide.Key = msg.key) Or wHotKeys.Hide.AltCode = msg.Key  Then v:Hide()
      EndIf
      If TB.Item.Exists(wHotKeys, "show")
        If (qualifiers[wHotKeys.Show.Qualifier] And wHotKeys.Show.Key = msg.key) Or wHotKeys.Show.AltCode = msg.Key  Then v:Show()
      EndIf
      If TB.Item.Exists(wHotKeys, "close")
        If (qualifiers[wHotKeys.Close.Qualifier] And wHotKeys.Close.Key = msg.key) Or wHotKeys.Close.AltCode = msg.Key  Then v:Close()
      EndIf
      If TB.Item.Exists(wHotKeys, "open")
        If (qualifiers[wHotKeys.Open.Qualifier] And wHotKeys.Open.Key = msg.key) Or wHotKeys.Open.AltCode = msg.Key  Then v:Open()
      EndIf
      If TB.Item.Exists(wHotKeys, "activate")
        If (qualifiers[wHotKeys.Activate.Qualifier] And wHotKeys.Activate.Key = msg.Key) Or wHotKeys.Activate.AltCode = msg.Key Then v:Activate()
      EndIf
      
      ;--- Custom HotKeys ---
      Local cHotKeys = v.Private.CustomHotKeys
      For ci, cv In Pairs(cHotKeys)
        If GetType(msg.id) = GetType(v.private.HWId)
          If qualifiers[cv.Qualifier] And cv.Key = msg.key And msg.Id = v.Private.HWId And msg.action = cv.Event
            cv.Callback(v, msg)
          ElseIf qualifiers[cv.Qualifier] And cv.AltCode = msg.key And msg.Id = v.Private.HWId And msg.action = cv.Event
            cv.Callback(v, msg)
          EndIf
        EndIf
      Next
    Next
    
    ; Gadget's HotKeys
    For i, v In Pairs(HGui.Shortcuts)
      ; Filtra solo i tasti della finestra dal quale proviene l'evento
      If GetType(msg.id) = GetType(v.object.window.private.HWId)
        If msg.id = v.object.window.private.HWId
          If (qualifiers[v.qualifier] And v.key = msg.key) Or v.AltCode = msg.Key
            ; Simula un evento di pressione del pulsante (ignora se il pulsante √® down)
            If v.object.status <> #HGUI_PUSHED_STATE
              HGui.gadgetEvent_Over({ userdata = { area = { object = v.object } } })
              HGui.gadgetEvent_LMBDown({ userdata = { area = { object = v.object } } })
            EndIf
          EndIf
        EndIf
      EndIf 
    Next

  ElseIf msg.action = "OnKeyUp"
    ; Window's shortcuts
    For i, v In Pairs(HGui.Windows)
      ;--- Window's HotKeys ---
      Local wHotKeys = v.Private.HotKeys
      If TB.Item.Exists(wHotKeys, "hide")
        If (qualifiers[wHotKeys.Hide.Qualifier] And wHotKeys.Hide.Key = msg.key) Or wHotKeys.Hide.AltCode = msg.Key  Then v:Hide()
      EndIf
      If TB.Item.Exists(wHotKeys, "show")
        If (qualifiers[wHotKeys.Show.Qualifier] And wHotKeys.Show.Key = msg.key) Or wHotKeys.Show.AltCode = msg.Key  Then v:Show()
      EndIf
      If TB.Item.Exists(wHotKeys, "close")
        If (qualifiers[wHotKeys.Close.Qualifier] And wHotKeys.Close.Key = msg.key) Or wHotKeys.Close.AltCode = msg.Key  Then v:Close()
      EndIf
      If TB.Item.Exists(wHotKeys, "open")
        If (qualifiers[wHotKeys.Open.Qualifier] And wHotKeys.Open.Key = msg.key) Or wHotKeys.Open.AltCode = msg.Key  Then v:Open()
      EndIf
      If TB.Item.Exists(wHotKeys, "activate")
        If (qualifiers[wHotKeys.Activate.Qualifier] And wHotKeys.Activate.Key = msg.Key) Or wHotKeys.Activate.AltCode = msg.Key Then v:Activate()
      EndIf
      
      ;--- Custom HotKeys ---
      Local cHotKeys = v.Private.CustomHotKeys
      For ci, cv In Pairs(cHotKeys)
        If GetType(msg.id) = GetType(v.private.HWId)
          If qualifiers[cv.Qualifier] And cv.Key = msg.key And msg.Id = v.Private.HWId And msg.action = cv.Event
            cv.Callback(v, msg)
          ElseIf qualifiers[cv.Qualifier] And cv.AltCode = msg.key And msg.Id = v.Private.HWId And msg.action = cv.Event
            cv.Callback(v, msg)
          EndIf
        EndIf
      Next
    Next
    
    ; Gadget's HotKeys
    For i, v In Pairs(HGui.Shortcuts)    
      ; Filtra solo i tasti della finestra dal quale proviene l'evento
      If GetType(msg.id) = GetType(v.object.window.private.HWId)
        If msg.id = v.object.window.private.HWId
          If (qualifiers[v.qualifier] And v.key = msg.key) Or v.AltCode = msg.Key
            ; Simula un evento di rilascio del mouse (ignora se il pulsante √® up)
            If v.object.status <> #HGUI_NORMAL_STATE
              HGui.gadgetEvent_LMBUp({ userdata = { area = { object = v.object } } })
              HGui.gadgetEvent_Out({ userdata = { area = { object = v.object } } }) 
            EndIf
          EndIf
        EndIf
      EndIf 
    Next

  
    ; ALTRI EVENTI (come onKeyUp)
    /*
    For i, v In Pairs(HGui.Windows)
      ;--- Custom HotKeys ---
      Local cHotKeys = v.Private.CustomHotKeys
      For ci, cv In Pairs(cHotKeys)
        If GetType(msg.id) = GetType(v.private.HWId)
          If qualifiers[cv.Qualifier] And cv.Key = msg.key And msg.Id = v.Private.HWId And msg.action = cv.Event Then cv.Callback(v, msg)
        EndIf
      Next
    Next
    */
  EndIf
  
EndFunction


Function HGui.RMB_Handler(msg) ; NOT YET IMPLEMENETED
/*---------------------------------------------------------
HGui.RMB_Handler(msg)

Handles any incoming right-mouse-button click.
-----------------------------------------------------------
INPUT
  msg : Message table returned by the event handler.

NOTES
  This function is NOT YET AVAILABLE
---------------------------------------------------------*/
   DBG.Console.Out("********************************************")
   DBG.Console.Out("*** [HGui.RMBd_Handler] *** MISSING FUNC ***")
   DBG.Console.Out("********************************************")
EndFunction


Function HGui.GadgetEvent_GotFocus(msg) ; SDOC, NOT YET IMPLEMENTED
/*---------------------------------------------------------
HGui.GadgetEvent_GotFocus(msg)

Every time a gadget get the focus this function will be called.
-----------------------------------------------------------
INPUT
  msg: Message table returned by the event handler.

NOTES
  This function is NOT YET AVAILABLE
---------------------------------------------------------*/
   DBG.Console.Out("****************************************************")
   DBG.Console.Out("*** [HGui.GadgetEvent_GotFocus] *** MISSING FUNC ***")
   DBG.Console.Out("****************************************************")
EndFunction


Function HGui.GadgetEvent_LostFocus(msg) ; SDOC, NOT YET IMPLEMENTED
/*---------------------------------------------------------
HGui.GadgetEvent_LostFocus(msg)

Every time a gadget lost the focus this function will be called.
-----------------------------------------------------------
INPUT
  msg => Message table returned by the event handler.
NOTES
  This function is NOT YET AVAILABLE.
---------------------------------------------------------*/
   DBG.Console.Out("*****************************************************")
   DBG.Console.Out("*** [HGui.GadgetEvent_LostFocus] *** MISSING FUNC ***")
   DBG.Console.Out("*****************************************************")
EndFunction


/******************************************************************************
  CLASS HGui.Area                                                      *TriDoc*
 *****************************************************************************/
HGui.Area = { }               ; Area Class
HGui.Area.Position = { }      ; Area position
HGui.Area.Position.x = 0      ;   Area horizontal position
HGui.Area.Position.y = 0      ;   Area vertical position
HGui.Area.Size = { }          ; Area size
HGui.Area.Size.w = 64         ;   Area width
HGui.Area.Size.h = 64         ;   Area height
HGui.Area.Skin = { }          ; Area skin
HGui.Area.Active = False      ; Active area?
HGui.Area.Window = Nil        ; Linked window
HGui.Area.Events = { }        ; Area events (callback functions)
HGui.Area.Events.OnMouseOver = Function() EndFunction
HGui.Area.Events.OnMouseDown = Function() EndFunction
HGui.Area.Events.OnMouseUp   = Function() EndFunction
HGui.Area.Events.OnMouseOut  = Function() EndFunction
HGui.Area.Events.OnRightMouseUp = Function() EndFunction
HGui.Area.Userdata = { }      ; Userdata for callback functions
HGui.Area.Object = Nil        ; Linked object
HGui.Area.Private = { }       ; Privata data
HGui.Area.Private.Button = Nil  ; Hollywood button id
HGui.Area.Private.Name = Nil    ; Button name


Function HGui.Area:new(options, object, userdata) ; *TriDoc* *
/*-------------------------------------
areaObject = HGui.Area:new(options, object, userdata)

Build a new graphic area. A graphic area is an area associated with the given
window (or, if not specified, the currently active one) that can be skinned
and can react to the mouse events.
All parameters are optional, default values are defined in the object model.

INPUT
  options : Options used to define the graphic area
  position : Area position with the following fields
    x : Horizontal coordinate
    y : Vertical coordinate
  size : Area size
    w : Area width
    h : Area height
  skin : Multilayer skin table
  active : TRUE if the area is an active (reacting) area
  window : The window this area belongs to, can be a Window name or a Window object. If not specified the area will be linked to the currently active window.
  events : A table with all supported callback functions:
    onmouseover : Callback attached to the OnMouseOver event
    onmouseout : Callback attached to the OnMouseOut event
    onmousedown : Callback attached to the OnMouseDown (left) event
    onmouseup : Callback attached to the OnMouseUp (left) event
    onrightmouseup : Callback attached to the OnRightMouseUp event
  object : HGui gadget attached to this area
  userdata : UserData to pass to the callback functions when raised

OUTPUT
  areaObject : A new area object or FALSE if there was an error.

NOTES
  This is a core HGui function used heavily to build gadgets.
  Active Area are attached to an Hollywood button with the same size and
  position.
---------------------------------------*/
  DBG.Console.Out(".Area:New()", DBG.OpenFunc, HGui.AreaChannel)

  ; Clone the area object
  Local NewArea = CopyTable(self)
  
  ; Assign a random name to the new area
  NewArea.private.name = HL.GetRndName()

  ; Setup Area position
  If TB.Item.Exists(options, "position")
    If TB.Item.Exists(options.position, "x") Then NewArea.position.x = options.position.x
    If TB.Item.Exists(options.position, "y") Then NewArea.position.y = options.position.y
    
  EndIf

  ; Setup Area size
  If TB.Item.Exists(options, "size")
    If TB.Item.Exists(options.size, "w")
      If options.size.w > 0
        NewArea.size.w = options.size.w
        
      Else
        DBG.Console.Out("Invalid area width : " .. ToString(options.size.w) .. ", creation failed.", DBG.Error, HGui.AreaChannel)
        DBG.Console.Out(Nil, DBG.CloseFunc, HGui.AreaChannel)
        Return(False)
        
      EndIf
      
    EndIf
    
    If TB.Item.Exists(options.size, "h")
      If options.size.h > 0
        NewArea.size.h = options.size.h
        
      Else
        DBG.Console.Out("Invalid area height : " .. ToString(options.size.h) .. ", creation failed.", DBG.Error, HGui.AreaChannel)
        DBG.Console.Out(Nil, DBG.CloseFunc, HGui.AreaChannel)
        Return(False)
        
      EndIf
      
    EndIf
    
  EndIf

  ; Setup Multilayer skin (byRef)
  If TB.Item.Exists(options, "skin") Then NewArea.skin = options.skin

  ; Setup Active flag
  If TB.Item.Exists(options, "active") Then NewArea.active = options.active

  ; Setup linked window
  If TB.Item.Exists(options, "window")
    Switch GetType(options.window)
      Case #STRING
        ;--- WINDOW NAME ---
        Local win = HGui.windowFindByName(options.window)
        If GetType(win) = #TABLE
          SelectDisplay(win.private.HWId, True)
          NewArea.window = win
          
        Else
          DBG.Console.Out("Invalid window's name : " .. ToString(options.window) .. ", creation failed.", DBG.Error, HGui.AreaChannel)
          DBG.Console.Out(Nil, DBG.CloseFunc, HGui.AreaChannel)
          Return(False)
          
        EndIf

      Case #TABLE
        ;--- WINDOW OBJECT ---
        If TB.Item.Exists(options.window, "private")
          If TB.Item.Exists(options.window.private, "hwid")
            SelectDisplay(options.window.private.HWId, True)
            NewArea.window = options.window
            
          Else
            DBG.Console.Out("Invalid window's object, field <HWid> was not found, creation failed.", DBG.Error, HGui.AreaChannel)
            DBG.Console.Out(Nil, DBG.CloseFunc, HGui.AreaChannel)
            Return(False)
            
          EndIf
          
        Else
          DBG.Console.Out("Invalid window's object, field <private> was not found, creation failed.", DBG.Error, HGui.AreaChannel)
          DBG.Console.Out(Nil, DBG.CloseFunc, HGui.AreaChannel)
          Return(False)
          
        EndIf

      Default
        ;--- UNRECOGNIZED WINDOW PARAMETER ---
        DBG.Console.Out("Unrecognized 'window' parameter, creation failed.", DBG.Error, HGui.AreaChannel)
        DBG.Console.Out(Nil, DBG.CloseFunc, HGui.AreaChannel)
        Return(False)

    EndSwitch

  Else
    ;--- NO WINDOW IDENTIFIER SPECIFIED ---
    DBG.Console.Out("Using the currently active window.", DBG.Warning, HGui.AreaChannel)
    SelectDisplay(HGui.ActiveWindow.private.HWId)
    NewArea.window = HGui.ActiveWindow

  EndIf

  ; Setup Events and callback functions
  If TB.Item.Exists(options, "events")
    If TB.Item.Exists(options.events, "onmouseover")    Then NewArea.events.onmouseover    = options.events.onmouseover
    If TB.Item.Exists(options.events, "onmouseout" )    Then NewArea.events.onmouseout     = options.events.onmouseout
    If TB.Item.Exists(options.events, "onmousedown")    Then NewArea.events.onmousedown    = options.events.onmousedown
    If TB.Item.Exists(options.events, "onmouseup"  )    Then NewArea.events.onmouseup      = options.events.onmouseup
    If TB.Item.Exists(options.events, "onrightmouseup") Then NewArea.events.onrightmouseup = options.events.onrightmouseup
    
  EndIf

  ; Setup linked Object
  NewArea.object   = object

  ; Setup userdata for callback functions
  NewArea.userdata = userdata

  ; Process Active area using an HW button
  If NewArea.active
    NewArea.private.button = MakeButton(
      Nil,
      #SIMPLEBUTTON,
      NewArea.position.x,
      NewArea.position.y,
      NewArea.size.w,
      NewArea.size.h,
      NewArea.events,
      { ObjType  = #HGUI_AREA,
        Object   = object,
        Area     = NewArea })
  EndIf

  ; Store the Area object
  HGui.Areas[NewArea] = NewArea

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.AreaChannel)
  Return(NewArea)

EndFunction


Function HGui.Area:set(options, object, offset) ; *TriDoc* *
/*-------------------------------------
result = AreaObject:set(options, object, offset)

Set the area object with the specified 'options'.

INPUT
  options : Options used to define the graphic area
    recurse : TRUE to recursively adjust all child objects
    position : Area position with the following fields
      x : Horizontal coordinate
      y : Vertical coordinate
    size : Area size
      w : Area width
      h : Area height
    skin : Multiskin table
    active : TRUE if the area is an active (reacting) area
    window : The window this area belongs to, can be a Window name or a Window object. If not specified the area will be linked to the currently active window.
    events : A table with all callback functions:
      onmouseover : Callback attached to the OnMouseOver event
      onmouseout : Callback attached to the OnMouseOut event
      onmousedown : Callback attached to the OnMouseDown (left) event
      onmouseup : Callback attached to the OnMouseUp (left) event
      onrightmouseup : Callback attached to the OnRightMouseUp event
  object : Linked object
  offset : Position offset with the following fields:
    x : Horizontal offset
    y : Vertical offset
  
OUTPUT
  result : TRUE if there was no error otherwise FALSE
---------------------------------------*/
  DBG.Console.Out(".Area:set() -> " .. self.private.name, DBG.OpenFunc, HGui.AreaChannel)
  
  If IsNil(offset)
    offset = { x = 0, y = 0 }
    
  Else
    If TB.Item.IsNil(offset, "x") Then offset.x = 0
    If TB.Item.IsNil(offset, "y") Then offset.y = 0
    
  EndIf

  ; Area position
  If TB.Item.Exists(options, "position")
    If TB.Item.Exists(options.position, "x") Then self.position.x = options.position.x
    If TB.Item.Exists(options.position, "y") Then self.position.y = options.position.y
    
  EndIf

  ; Area size
  If TB.Item.Exists(options, "size")
    If TB.Item.Exists(options.size, "w")
      If Int(options.size.w) => 1
        self.size.w = options.size.w
        
      Else
        self.size.w = 1
        DBG.Console.Out("Invalid width : " .. options.size.w, DBG.Warning, HGui.AreaChannel)
        
      EndIf
      
    EndIf
    
    If TB.Item.Exists(options.size, "h")
      If Int(options.size.h) => 1
        self.size.h = options.size.h
        
      Else
        self.size.h = 1
        DBG.Console.Out("Invalid height : " .. options.size.h, DBG.Warning, HGui.AreaChannel)
        
      EndIf
      
    EndIf
    
  EndIf

  ; Area skin
  If TB.Item.Exists(options, "skin") Then self.skin = options.skin

  ; Active flag
  If TB.Item.Exists(options, "active")
    If (self.active = True) And (Options.active = False) Then DeleteButton(self.private.button)

    self.active = options.active
    
  EndIf

  SelectDisplay(self.window.private.HWId, True)

  ; Active area events
  If TB.Item.Exists(options, "events")
    If TB.Item.Exists(options.events, "onmouseover")    Then self.events.onmouseover = options.events.onmouseover
    If TB.Item.Exists(options.events, "onmouseout" )    Then self.events.onmouseout  = options.events.onmouseout
    If TB.Item.Exists(options.events, "onmousedown")    Then self.events.onmousedown = options.events.onmousedown
    If TB.Item.Exists(options.events, "onmouseup"  )    Then self.events.onmouseup   = options.events.onmouseup
    If TB.Item.Exists(options.events, "onrightmouseup") Then self.events.onrightmouseup = options.events.onrightmouseup
  EndIf

  ; Linked object
  If HL.IsNotNil(object) Then self.object = object

  ; Callback UserData
  If TB.Item.Exists(options, "userdata") Then self.userdata = options.userdata

  If self.active
    /* This code below necessary to trim the active area (button area) and limit
     * its activity only to the visible part.
     * For example ListView column headers could fall out of the ListView area
     * because of the horizontal scroller and the active area (as well as the
     * column header) must be cutted to the visible 'father' gadget area.
     *
     * This is valid also for all gadget inside virtual areas.
     */

    Local ox, oy, ow, oh, create = offset.x, 0, 0, 0, True
    
    If TB.Item.Exists(self.Object, "islistviewheader")    
      ; This object is a LISTVIEW (column) HEADER
      Local TopBoxArea = self.Object.Father.TopBox.Area
      ; Managing the illustrated possiblities:
      ;         +---------+
      ; [header]| FATHER  |[header]
      ;         +---------+
      ; We do not have to recreate the button because it falls outside the father
      ; area, instead we only need to remove the old one.
      If Int(self.position.x + self.size.w + offset.x) < Int(TopBoxArea.position.x) Or
         Int(self.position.x + offset.x) > Int(TopBoxArea.position.x + TopBoxArea.size.w)
        create = False
      EndIf

      ; #WARNING => Why I'm not using an Else statement instead of several If // EndIf ?
      
      ;      +--------+
      ; [head|er]     |
      ;      +--------+
      ; We have to recreate the button but it must be moved and resized.
      If Int(self.position.x + offset.x) < Int(TopBoxArea.position.x) And Int(self.position.x + offset.x + self.size.w) < Int(TopBoxArea.position.x + TopBoxArea.size.w)
        ox = TopBoxArea.position.x - self.position.x
        ow = self.size.w - (TopBoxArea.position.x - (self.position.x + offset.x))
      EndIf

      ;   +-------+
      ;   |  [head|er]
      ;   +-------+
      ; We have to recreate the button but in this case we only have to resize it
      If Int(self.position.x + self.size.w + offset.x) > Int(TopBoxArea.position.x + TopBoxArea.size.w)
        ;ox = offset.x
        ow = (TopBoxArea.position.x+TopBoxArea.size.w) - (self.position.x+self.size.w+offset.x)
      EndIf
    
    ElseIf TB.Item.Exists(self.Object, "isvirtualized")
      ; This object is a VIRTUALIZED OBJECT
      If self.Object.IsVirtualized
        Local TopBoxArea = self.Object.VirtualRoot.Area
        ; Managing the illustrated possiblities:
        ;           [Header]
        ;         +---------+
        ; [header]| FATHER  |[header]
        ;         +---------+
        ;           [Header]
        ; We do not have to recreate the button because it falls outside the father
        ; area, instead we only need to remove the old one.
        If Int(self.position.x + self.size.w + offset.x) < Int(TopBoxArea.position.x) Or
           Int(self.position.x + offset.x) > Int(TopBoxArea.position.x + TopBoxArea.size.w) Or
           Int(self.position.y + self.size.h + offset.y) < Int(TopBoxArea.position.y) Or
           Int(self.position.y + offset.y) > Int(TopBoxArea.position.y + TopBoxArea.size.h)
          create = False
        Else
            
          ;      +--------+
          ; [head|er]     |
          ;      +--------+
          ; Move and resize the button to recreate
          If Int(self.position.x + offset.x) < Int(TopBoxArea.position.x) And Int(self.position.x + offset.x + self.size.w) < Int(TopBoxArea.position.x + TopBoxArea.size.w)
            ox = TopBoxArea.position.x - self.position.x
            ow = self.size.w - self.size.w - (TopBoxArea.position.x - (self.position.x + offset.x))
          EndIf
                
          ;      +[header]-+
          ;      |         |
          ;      +---------+
          ; Move and resize the button to recreate
          If Int(self.position.y + offset.y) < Int(TopBoxArea.position.y) And Int(self.position.y + offset.y + self.size.h) < Int(TopBoxArea.position.y + TopBoxArea.size.h)
            oy = TopBoxArea.position.y - self.position.y
            oh = self.size.h - self.size.h - (TopBoxArea.position.y - (self.position.y + offset.y))
          EndIf

          ;   +-------+
          ;   |  [head|er]
          ;   +-------+
          ; Move and resize the button to recreate
          If Int(self.position.x + self.size.w + offset.x) > Int(TopBoxArea.position.x + TopBoxArea.size.w)
            ;ox = offset.x
            ow = (TopBoxArea.position.x+TopBoxArea.size.w) - (self.position.x+self.size.w+offset.x)
          EndIf

          ;      +---------+
          ;      |         |
          ;      +[header]-+
          ; Move and resize the button to recreate
          If Int(self.position.y + self.size.h + offset.y) > Int(TopBoxArea.position.y + TopBoxArea.size.h)
            ;ox = offset.x
            oh = (TopBoxArea.position.y+TopBoxArea.size.h) - (self.position.y+self.size.h+offset.y)
          EndIf
              
        EndIf
        
      EndIf

    EndIf

    ; If exists a button field on this area object and if it have a valid id
    ; remove it.
    If TB.Item.Exists(self.private, "button")
      If GetType(self.private.button) <> #NUMBER Then DeleteButton(self.private.button)
    EndIf

    ; Check if we have to recreate the button otherwise set the button id to -1
    If create And Int(self.size.w+ow) > 0 And Int(self.size.h+oh) > 0
      self.private.button = MakeButton(
                              Nil,
                              #SIMPLEBUTTON,
                              self.position.x+ox,
                              self.position.y+oy,
                              self.size.w+ow,
                              self.size.h+oh,
                              self.events,
                              { ObjType = #HGUI_AREA,
                                Object  = self.object,
                                Area    = self })
    Else
      self.private.button = -1
    EndIf

  EndIf
  
  ; Check if we need to recursively adjust all child objects
  If TB.Item.Exists(options, "recurse")
    If options.recurse
      If TB.Item.Exists(self, "object")
        If TB.Item.Exists(self.object, "childs")
          If TB.Item.Exists(self.object.childs, "gadgets")
            Local i, v
            For i, v In Pairs(self.object.childs.gadgets)
              v.Area:set({ recurse = True })
            Next
            
          EndIf
          
        EndIf
        
      EndIf
      
    EndIf
    
  EndIf

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.AreaChannel)
  Return(True)

EndFunction


Function HGui.Area:render() ; *TriDoc* *
/*-------------------------------------
result = AreaObject:render()

Renders the area object with its skin if defined.

OUTPUT
  result : TRUE if the area was rendered without errors
---------------------------------------*/

  ; Create a temporary area object to use its :skinMulti() method directly
  Local area = G2D.Area:new(self.position.x, self.position.y, self.size.w, self.size.h)
  
  ; Select the linked window for the output
  GFX.OutputDevice.Select(#DISPLAY, self.window.private.HWId, True)
    area:skinMulti(self.skin)
  GFX.OutputDevice.EndSelect()

  Return(True)

EndFunction


Function HGui.Area:free() ; *TriDoc* *
/*-------------------------------------
result = AreaObject:free()

Free the area object.

OUTPUT
  result : TRUE if the area was successfully released.
---------------------------------------*/
  DBG.Console.Out(".Area:free() : " .. self.private.name, DBG.OpenFunc, HGui.AreaChannel)
  
  ; Check if we have to remove the attached button
  If self.active And GetType(self.private.button) <> #NUMBER
    ; Select the window where the button was created
    GFX.OutputDevice.Select(#DISPLAY, self.Window.Private.HWId)
      DeleteButton(self.private.button)
      self.private.button = -1
    GFX.OutputDevice.EndSelect()
    
  EndIf
  
  ; Remove the area object
  HGui.Areas[self] = Nil

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.AreaChannel)
  Return(True)

EndFunction


Function HGui.Area_FindByName(area_name) ; *TriDoc* *
/*-------------------------------------
areaObj, index = HGui.Area_FindByName(area_name)

Search the area named 'area_name' and returns the found object and the index in
the HGui.Areas table, otherwise returns FALSE in areaObj.

INPUT
  area_name : Name of the area to search

OUTPUT
  areaObject : The found areaObject or FALSE if no area was found
  index : If the area was found return the object index in HGui.Areas table
---------------------------------------*/
  DBG.Console.Out(".Area_FindByName() : " .. ToString(area_name), DBG.OpenFunc, HGui.AreaChannel)

  Local i, v
  For i, v In Pairs(HGui.Areas)
    If v.private.name = area_name
      ; Found
      Return(v, i)

    EndIf

  Next

  DBG.Console.Out("Not found!", DBG.CloseFunc, HGui.AreaChannel)
  Return(False)

EndFunction

/* ****************************************************************************
   END CLASS
   ****************************************************************************/


/* ****************************************************************************
   CLASS HGui.Gadget
   ****************************************************************************/
HGui.Gadget = { }                       ; Gadget object root
HGui.Gadget.name = Nil                  ; Name
HGui.Gadget.type = Nil                  ; Type (see #HGUI_..._GADGET constants)
HGui.Gadget.area = Nil                  ; Attached Area object
HGui.Gadget.status = Nil                ; Current status (see #HGUI_..._STATE constants)
HGui.Gadget.Look = { }                  ; Subtable that defines the look for every possible status
HGui.Gadget.Look.Borders = { }          ;   Subtable that defined the gadget borders
HGui.Gadget.Look.Borders.top = 0        ;     Top border
HGui.Gadget.Look.Borders.bottom = 0     ;     Bottom border
HGui.Gadget.Look.Borders.left = 0       ;     Left border
HGui.Gadget.Look.Borders.right = 0      ;     Right border
HGui.Gadget.Look.Offset = { }           ;   Subtable that defines the global skin offset
HGui.Gadget.Look.Offset.x = 0           ;     Horizontal offset
HGui.Gadget.Look.Offset.y = 0           ;     Vertical offset
HGui.Gadget.Look.isCustom = False       ;   Is it a customized skin?
HGui.Gadget.Look.nSkin = Nil            ;   Normal state multiSkin table
HGui.Gadget.Look.hSkin = Nil            ;   Hilighted state multiSkin table
HGui.Gadget.Look.pSkin = Nil            ;   Pushed state multiSkin table
HGui.Gadget.Look.dSkin = Nil            ;   Disabled state multiSkin table
HGui.Gadget.Look.npSkin = Nil           ;   Normal-Pushed state multiSkin table
HGui.Gadget.Look.hpSkin = Nil           ;   Hilighted-Pushed state multiSkin table
HGui.Gadget.Look.dpSkin = Nil           ;   Disabled-Pushed state multiSkin table
HGui.Gadget.Look.nText = Nil            ;   Normal state cText object
HGui.Gadget.Look.hText = Nil            ;   Hilighted state cText object
HGui.Gadget.Look.pText = Nil            ;   Pushed state cText object
HGui.Gadget.Look.dText = Nil            ;   Disabled state cText object
HGui.Gadget.Look.npText = Nil           ;   Normal-Pushed state cText object
HGui.Gadget.Look.hpText = Nil           ;   Hilighted-Pushed state cText object
HGui.Gadget.Look.dpText = Nil           ;   Disabled-Pushed state cText object
HGui.Gadget.Look.Icons = { }            ;   Subtable that defines the icons to use with the gadget
HGui.Gadget.Look.Icons.iName = Nil      ;     Global state Icon's name (to set all icons in one go)
HGui.Gadget.Look.Icons.nName = Nil      ;     Normal state Icon's name
HGui.Gadget.Look.Icons.hName = Nil      ;     Hilighted state Icon's name
HGui.Gadget.look.Icons.pName = Nil      ;     Pushed state Icon's name
HGui.Gadget.Look.Icons.dName = Nil      ;     Disabled state Icon's name
HGui.Gadget.Look.Icons.npName = Nil     ;     Normal-Pushed state Icon's name
HGui.Gadget.Look.Icons.hpName = Nil     ;     Hilighted-Pushed state Icon's name
HGui.Gadget.Look.Icons.dpName = Nil     ;     Disabled-Pushed
                                        ;     Icon's alignment
HGui.Gadget.Look.Icons.alignment = #HGUI_ALIGN_TOP+#HGUI_ALIGN_HCENTER
HGui.Gadget.Look.Icons.gap = 8          ;     Distance between the icon and the text
HGui.Gadget.Look.Icons.adjText = True   ;     Enable automatic cText adjustment
HGui.Gadget.caption = Nil               ; Gadget caption text, a string or a table of strings
HGui.Gadget.tip = Nil                   ; Floating text tip, a string or a table of strings
HGui.Gadget.Contextual = {}             ; Contextual Menu (a menu table)
HGui.Gadget.Flags = { }                 ; Gadget's flags
HGui.Gadget.Flags.visible = True        ;   Is it visible?
HGui.Gadget.Flags.enabled = True        ;   Is it enabled?
HGui.Gadget.Flags.draggable = True      ;   Is it draggable?
HGui.Gadget.Shortcut = { }              ; Gadget's shortcut's
HGui.Gadget.Shortcut.qualifier = Nil    ;   Shortcut qualifier
HGui.Gadget.Shortcut.key = Nil          ;   Shortcut key
HGui.Gadget.Shortcut.altCode = Nil      ;   Shortcut Alt-Code
HGui.Gadget.useCache = True             ; Enable graphic cache?
HGui.Gadget.Sounds = { }                ; Table used to store sound associated with events
HGui.Gadget.Sounds.onOver = Nil         ;   OnOver event sound
HGui.Gadget.Sounds.onOut = Nil          ;   OnOut event sound
HGui.Gadget.Sounds.onPushed = Nil       ;   OnPushed event sound
HGui.Gadget.Sounds.onDown = Nil         ;   OnDown event sound
HGui.Gadget.Actions = { }               ; Table used to store all event callbacks
HGui.Gadget.Actions.onGotFocus = Function() EndFunction   ;   The gadget has got the focus
HGui.Gadget.Actions.onLostFocus = Function() EndFunction  ;   The gadget has lost the focus
HGui.Gadget.Actions.onPushed = Function() EndFunction     ;   The gadget has been pushed (released)
HGui.Gadget.Actions.onDown = Function() EndFunction       ;   The gadget has been pushed down
HGui.Gadget.Actions.onOver = Function() EndFunction       ;   The mouse is over the gadget
HGui.Gadget.Actions.onOut = Function() EndFunction        ;   The mouse is exited from the gadget
HGui.Gadget.Actions.onDrop = Function() EndFunction       ;   Something dropped on the gadget
HGui.Gadget.Actions.onDropOut = Function() EndFunction    ;   The gadget has been dropped
HGui.Gadget.window = Nil                ; Window object linked to the gadget
HGui.Gadget.background = False          ; Gadget background
HGui.Gadget.userData = Nil              ; Callback userdata
HGui.Gadget.childs = { }                ; Children gadget list
HGui.Gadget.parent = Nil                ; Parent object
HGui.Gadget.VirtualSize = { }           ; If this gadget is virtual stores the virtual area size
HGui.Gadget.VirtualSize.w = -1          ;   Virtual area width
HGui.Gadget.VirtualSize.h = -1          ;   Virtual area height
HGui.Gadget.VirtualOffset = { }         ; If this gadget is virtual stores the virtual area offset
HGui.Gadget.VirtualOffset.x = -1        ;   Horizontal offset
HGui.Gadget.VirtualOffset.y = -1        ;   Vertical offset
HGui.Gadget.isVirtualized = False       ; TRUE if this gadget is virtual
HGui.Gadget.VirtualRoot = Nil           ; Virtual gadget root
HGui.Gadget.IsKilled = False            ; TRUE if this gadget has been killed
HGui.Gadget.Private = { }               ; Table used to store private data
HGui.Gadget.Private.Cache = { }         ;   Table used to store cached informations
HGui.Gadget.Private.Cache.normal = Nil  ;     Normal state brush
HGui.Gadget.Private.Cache.hilight = Nil ;     Hilighted state brush
HGui.Gadget.Private.Cache.pushed = Nil  ;     Pushed state brush
HGui.Gadget.Private.Cache.disabled = Nil;     Disabled state brush
HGui.Gadget.Private.Cache.nPushed = Nil ;     Normal-Pushed state brush
HGui.Gadget.Private.Cache.hPushed = Nil ;     Hilighted-Pushed state brush
HGui.Gadget.Private.Cache.dPushed = Nil ;     Disabled-Pushed state brush
HGui.Gadget.Private.Links = {}          ;   Table used to link gadgets between each others
;--- GROUP GADGET ---
HGui.Gadget.Private.group_labelSide = Nil; If this gadget is a group stores the label side
HGui.Gadget.Private.group_LabelGap = Nil ; If this gadget is a group stores the label gap
HGui.Gadget.Private.group_initMode = Nil ; Internal flag to setup the group gagdte
;--- GROUPED OBJECTS ---
HGui.Gadget.Private.grouped = False      ; TRUE if the gadget is a group
HGui.Gadget.Private.subType = Nil        ; Gadget sub-type : CHECK or RADIO
;--- SCROLLBAR/SLIDERS ---
HGui.Gadget.Private.isCursor = False     ; TRUE if this gadget is a slider/scrollbal cursor

HGui.Gadget.Private.isRoot = False       ; TRUE if this gadget is a root gadget
HGui.Gadget.Private.isVirtual = False    ; TRUE if this gadget is a virtual gadget
HGui.Gadget.Private.isVirtualRoot = False; Root gadget of a virtual gadget
HGui.Gadget.Private.IsMenu = False       ; TRUE if this gadget belongs to a menu
HGui.Gadget.Private.IsMasterRoot = False ; TRUE if this gadget is a master root

Function HGui.gadgetSetSkinCache(value) ; *TriDoc*
/*---------------------------------------------------------
HGui.gadgetSetCache(value)

Set the global gadget cache on or off, all new gadgets created will respect the new setting.
-----------------------------------------------------------
INPUT
  value : TRUE to activate the cache system, FALSE to deactivate it.

EXAMPLE
  | ; Enable the cache system
  | HGui.gadgetSetSkinCache(True)

NOTE
  If you want to switch the cache for all existing gadgets just re-apply the theme.
  The cache system consumes more memory but the rendering is faster.
  Only the gadget graphics (not the text) is affected by this setting.
---------------------------------------------------------*/
  HGui.Gadget.useCache = value

EndFunction

Function HGui.gadgetSetTextCache(value) ; *TriDoc*
/*---------------------------------------------------------
HGui.gadgetSetTextCache(value)

Set the gadget text cache on or off, all new gadgets created will respect the new setting.
-----------------------------------------------------------
INPUT
  value : TRUE to activate the cache system, FALSE to deactivate it.

EXAMPLE
  | ; Disables the text cache system
  | HGui.gadgetSetTextCache(False)

NOTE
  If you want to switch the cache for all existing gadgets just re-apply the theme.
  With gadgets that need frequently text updates you should disable the text cache because, if enabled, each time a text is changed the full skin cache will be rebuilt (for all states).
  The cache system consumes more memory but the rendering is faster.
  Only the gadget text (not the graphics) is affected by this setting.  
---------------------------------------------------------*/
  HGui.CacheGadtext = value

EndFunction

Function HGui.gadgetExistsByName(gadget_name) ; *TriDoc*
/*---------------------------------------------------------
result, gadget = HGui.gadgetExistsByName(gadget_name)

Returns TRUE if a gadget with the specified name exists, otherwise returns
FALSE.
As second argument returns the gadget object if it was found.
-----------------------------------------------------------
INPUT
  gadget_name : Gadget name to check

OUTPUT
  result : TRUE if exists or FALSE if not.
  gadget : If result is TRUE returns the gadget object.

EXAMPLE
  | ; Check if a gadget named 'myButton' exists
  | If HGui.gadgetExistsByName("myButton")
  |   DebugPrint("FOUND!")
  | EndIf
---------------------------------------------------------*/
  For i, v In Pairs(HGui.Gadgets)
    If v.name = gadget_name Then Return(True, v)
  Next
  
  Return(False)

EndFunction

Function HGui.gadgetFindByHWIdAndPos(HWId, x, y) ; *TriDoc*
/*---------------------------------------------------------
gadget = HGui.gadgetFindByHWIdAndPos(HWId, x, y)

Check for a gadget into the window specified by the Hollywood ID (HWId) at the given position.
Returns the gadget if was found or FALSE.
-----------------------------------------------------------
INPUT
  HWId : Hollywood ID of the window we are looking for the gadget
  x    : Horizontal position
  y    : Vertical position

OUTPUT
  gadget : The found gadget object or FALSE if there is no gadgets at the given position.
EXAMPLE
  | ; Check if there is gadget at (100, 100) on window 1
  | Local result, g = HGui.gadgetFindByHWIdAndPos(1, 100, 100)
  | If result
  |   DebugPrint("FOUND -> Gadget name is : " .. g.name)
  | EndIf
---------------------------------------------------------*/
  Local count = ListItems(HGui.Gadgets)-1
  
  ; Check all defined gadgets
  For i = count To 0 Step -1
    Local v = HGui.Gadgets[i]
    ; Check if the gadget belongs to the specified window
    If GetType(v.window.private.hwid) = GetType(Hwid)
      If v.window.private.HWid = HWid
        ; Check if the given position falls into the gadget area
        If x>v.area.position.x And x<v.area.position.x+v.area.size.w
          If y>v.area.position.y And y<v.area.position.y+v.area.size.h
            ; Returns the found gadget and exit.
            Return(v)
          EndIf
        EndIf
      EndIf
    EndIf
  Next

EndFunction

Function HGui.gadgetFindByName(gadget_name) ; *TriDoc*
/*---------------------------------------------------------
result = HGui.gadgetFindByName(gadget_name)

Search the gadget object using its <gadget_name>, if found this function will return the gadget object and the position index in the <HGui.Gadgets> table. 
If the gadget isn't founded <False> will be  returned.
-----------------------------------------------------------
INPUT
  gadget_name : Gadget name to search for

OUTPUT
  result : Gadget object and its index or FALSE.

EXAMPLE
  | ; Search for a gadget named 'myButton'
  | Local result = HGui.gadgetFindByName("myButton")
  |
  | ; Check the result type because it can return FALSE or a gadget object
  | If GetType(result) = #TABLE
  |   DebugPrint("FOUND -> Gadget Name is : " .. result.Name)
  | EndIf
---------------------------------------------------------*/
  Local i, v = NextItem(HGui.Gadgets)
  While GetType(i) <> #NIL
    If v.name = gadget_name Then Return(v, i)
    i, v = NextItem(HGui.Gadgets, i)
  Wend

  Return(False)

EndFunction

Function HGui.Gadget:unlink(target) ; *TriDoc*
/*-------------------------------------------------------------------
HGui.Gadget:unlink(target)

Removes a previously created link.
---------------------------------------------------------------------
INPUT
  target : Gadget object to remove

NOTE
  This method is experimental and unfinished
------------------------------------------------------------------*/
  For i, v In Pairs(self.Private.Links)
    If v.target = target
      RemoveItem(self.Private.Links, i)
      Return()
    EndIf
  Next
EndFunction

Function HGui.Gadget:link(target, action, params) ; *TriDoc*
/*-------------------------------------------------------------------
HGui.Gadget:link(target, action, params)

Links this gadget to another one identified by 'target', 'action' determines the
link behaviour (always attached to the OnPushed event) while params is used
to configure the action.
---------------------------------------------------------------------
INPUT
  target : Gadget object to target
  action : A string representing the action, actually the following are supported:
    - "+/-" : Increase/Decrease Current Value (TEXT Class)
  params : Table used to configure the action, it depends on the action:
    - "+/-" : You have to provide the following items:
      - range : { min_value, max_value }
      - value : Indrease or decrease value
NOTES
  Available links:
    Button -> Text
      "+", "-"
  This is an experimental and incomplete method to try to automatize links between interface's objects
------------------------------------------------------------------*/
  If IsNil(params) Then params = {}
  
  Switch self.Type
    Case #HGUI_BUTTON_GADGET
      Switch target.Type
        Case #HGUI_TEXT_GADGET
          Switch action
            Case "+/-"
              ; BUTTON -> TEXT ( + / - )
              If TB.Item.IsNil(params, "range") Then params.range = {}
              If TB.Item.IsNil(params.Range, 0) Then params.range[0] = -9999999
              If TB.Item.IsNil(params.Range, 1) Then params.range[1] =  9999999
              If TB.Item.IsNil(params, "value") Then params.value = 1
              InsertItem(self.Private.Links, 
                { target = target,
                  action = action,
                  params = params })
          EndSwitch

      EndSwitch
      
  EndSwitch
  
EndFunction

Function HGui.Gadget:drawScrollbarHandle(status) ; *TriDoc*
/*---------------------------------------------------------
HGui.Gadget:drawScrollbarHandle(status)

This method is used internally to render the scrollbar's cursor handle.
Status indicates which state we need to render. 
Please note that the handle will be rendered only if there is no 'caption' defined.
-----------------------------------------------------------
INPUT
  status : Status we need to render, it can be one of the following : #HGUI_NORMAL_STATE, #HGUI_HILIGHTED_STATE, #HGUI_PUSHED_STATE, #HGUI_DISABLED_STATE

NOTES
  The method will exit silently if the gadget field .IsCursor is set to FALSE.
  Recognized handle types are : 'lines', 'dots', 'box'
---------------------------------------------------------*/
  ; Continue only if .IsCursor is TRUE and ...
  If self.private.IsCursor
    ; ... only if there is no 'caption' to render
    If self.caption <> "" Then Return()
    
    Local handle = self.CursorHandle ; HGui.Theme.scrollbar.handle ; --> self.cursorhandle
    
    ; Select the color set of the state we need to render
    Local colors
    Switch status
      Case #HGUI_NORMAL_STATE
        colors = handle.normal
      Case #HGUI_HILIGHTED_STATE
        colors = handle.hilighted
      Case #HGUI_PUSHED_STATE
        colors = handle.pushed
      Case #HGUI_DISABLED_STATE
        colors = handle.disabled
    EndSwitch

    ; Vertical layout ?
    If self.private.father.orientation = #HGUI_VERTICAL_LAYOUT
      Switch handle.type
        Case "lines"
          Local middle = self.area.size.h / 2
          Local area   = handle.size * handle.quantity * 2 + handle.gap * (handle.quantity-1)
          Local start  = middle - area/2 + handle.size
          Local hsize  = handle.size
          Local offset = self.area.size.w/4
          For Local i = 1 To handle.quantity
            Line(offset, start-hsize, self.area.size.w-offset, start-hsize, colors.color1, { Thickness = handle.size })
            Line(offset, start      , self.area.size.w-offset, start      , colors.color2, { Thickness = handle.size })
            start = start + handle.size * 2 + handle.gap
          Next

        Case "dots"
          Local middle = self.area.size.h / 2
          Local area   = handle.size * handle.quantity * 2 + handle.gap * (handle.quantity-1)
          Local start  = middle - area/2 + handle.size/2
          Local halfh  = self.area.size.w/2
          Local hsize  = handle.size
          SetFillStyle(#FILLCOLOR)
          For Local i = 1 To handle.quantity
            If hsize < 1 Then hsize = 1
            Box(halfh - hsize, start, hsize, hsize, colors.color2)
            Box(halfh - hsize - 1, start-1, hsize, hsize, colors.color1)
            Box(halfh + hsize, start, hsize, hsize, colors.color2)
            Box(halfh + hsize - 1, start-1, hsize, hsize, colors.color1)
            start = start + hsize * 2 + handle.gap
          Next

        Case "box"
          Local middlex = self.area.size.w / 2
          Local middley = self.area.size.h / 2
          Local w = handle.size
          Local h = w
          SetFillStyle(#FILLNONE)
          ; Uses a temporary area object to render a bevel skin
          Local area = G2D.Area:new(middlex-h/2, middley-w/2, h, h)
          area:skinBevel({ light = colors.color1, middle = colors.color3, dark = colors.color2 },
                         { fx = GFX.BevelFx_Raised, height = handle.gap, type = GFX.BevelType_Standard })
      EndSwitch

    ; Horizontal layout ?
    ElseIf self.private.father.orientation = #HGUI_HORIZONTAL_LAYOUT
      Switch handle.type
        Case "lines"
          Local middle = self.area.size.w / 2
          Local area   = handle.size * handle.quantity * 2 + handle.gap * (handle.quantity-1)
          Local start  = middle - area/2 + handle.size
          Local hsize  = handle.size
          Local offset = self.area.size.h/4
          For Local i = 1 To handle.quantity
            Line(start-hsize, offset, start-hsize, self.area.size.h-offset, colors.color1, { Thickness = handle.size })
            Line(start      , offset, start      , self.area.size.h-offset, colors.color2, { Thickness = handle.size })
            start = start + handle.size * 2 + handle.gap
          Next

        Case "dots"
          Local middle = self.area.size.w / 2
          Local area   = handle.size * handle.quantity * 2 + handle.gap * (handle.quantity-1)
          Local start  = middle - area/2 + handle.size/2
          Local halfh  = self.area.size.h/2
          Local hsize  = handle.size
          SetFillStyle(#FILLCOLOR)
          For Local i = 1 To handle.quantity
            Box(start, halfh - hsize, hsize, hsize, colors.color2)
            Box(start-1, halfh - hsize - 1, hsize, hsize, colors.color1)
            Box(start, halfh + hsize, hsize, hsize, colors.color2)
            Box(start-1, halfh + hsize - 1, hsize, hsize, colors.color1)
            start = start + hsize * 2 + handle.gap
          Next

        Case "box"
          Local middlex = self.area.size.w / 2
          Local middley = self.area.size.h / 2
          Local w = handle.size
          Local h = w
          SetFillStyle(#FILLNONE)
          ; Uses a temporary area object to render a bevel skin
          ;Local area = G2D.Area:new(middlex-h/2, middley-w/2, h, w)
          Local area = G2D.Area:new(middlex-h/2, middley-w/2, h, h)
          area:skinBevel({ light = colors.color1, middle = colors.color3, dark = colors.color2 },
                         { fx = GFX.BevelFx_Raised, height = handle.gap, type = GFX.BevelType_Standard })
      EndSwitch

    EndIf

  EndIf

EndFunction

Function HGui.Gadget:layoutUpdate(force) ; *TriDoc*
/*---------------------------------------------------------
result = HGui.Gadget:layoutUpdate(force)

This method is used internally to force a refresh of the interface layout, it also used by :layoutSet() method.
-----------------------------------------------------------
INPUT
  force : Was defined for some reason but now seems useless.

OUTPUT
  result : TRUE if the operation was completed.

NOTE
  This function needs some love.
---------------------------------------------------------*/
  DBG.Console.Out("HGui.Gadget:layoutUpdate() -> Update <" .. self.name .. "> layout...", DBG.OpenFunc, HGui.DebugChannel)
  
  If TB.Item.IsNil(self.childs, "gadgets")
    ; Exit if no children was found
    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
    Return(False)
  EndIf

  Local childs = self.childs
  Local gadcount = TB.Count(childs.gadgets)

  If gadcount = 0
    ; Exit if children count is 0
    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
    Return(False)
  EndIf
  
  /*
  If self.Type <> #HGUI_VIRTUAL_GADGET
    If self.area.size.w = childs.last_parent_size.w And self.area.size.h = childs.last_parent_size.h
      If self.area.position.x = childs.last_parent_pos.x And self.area.position.y = childs.last_parent_pos.y
        DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
        Return(False)
      EndIf
    EndIf
  EndIf
  */
  
  Local startpos = { x = self.area.position.x + childs.borders.left,
                     y = self.area.position.y + childs.borders.top  }

  Switch childs.type
    Case #HGUI_VERTICAL_LAYOUT
      Local worksize = { w = self.area.size.w - childs.borders.left - childs.borders.right,
                         h = self.area.size.h - childs.borders.top - childs.borders.bottom - (GadCount-1)*(childs.gap+1) - childs.Fixed_Size }
      
      ;=== VIRTUAL GADGET HANDLING ===
      If self.Private.IsVirtualRoot
        startpos = { x = self.VirtualOffset.x + childs.borders.left + self.area.position.x,
                     y = self.VirtualOffset.y  + childs.borders.top + self.area.position.y }
        worksize = { w = self.VirtualSize.w - childs.borders.left - childs.borders.right,
                     h = self.VirtualSize.h - childs.borders.top - childs.borders.bottom - (GadCount-1)*(childs.gap+1) - childs.Fixed_Size }
      EndIf  
      
      If self.Type = #HGUI_VIRTUAL_GADGET
      /*
        ; Ho incontrato un VIRTUAL GADGET aggiorno la visualizzazione
        ; dei child, ma non devo aggiornare le posizioni dei child di
        ; .VBox (lo posso verificare con il flag IsVirtualRoot)
        DebugPrint("UPDATE VIRTUAL INITIAL POS & WORKSIZE")
        startpos = { x = self.VirtualOffset.x + childs.borders.left,
                     y = self.VirtualOffset.y  + childs.borders.top  }
        worksize = { w = self.VirtualSize.w - childs.borders.left - childs.borders.right,
                     h = self.VirtualSize.h - childs.borders.top - childs.borders.bottom - (GadCount-1)*(childs.gap+1) - childs.Fixed_Size }
        DebugPrint(self.Name)
        DBG.DumpTable(startpos)
        DBG.DumpTable(worksize)
        */
      EndIf  
      
      For Local i = 0 To gadcount - 1
        If childs.weights[i] > 0 And childs.weights[i] <= 1
          Local w = worksize.w
          Local h = worksize.h * childs.weights[i]
          childs.gadgets[i]:set({ position = { x = startpos.x, y = startpos.y },
                                  size = { w = w, h = h } }, False)
          startpos.y = startpos.y + childs.gap + Round(h) + 1
        ElseIf childs.weights[i] < 0 And childs.weights[i] >= -1
          Local w = worksize.w
          Local h = self.window.nativesize.h * (-childs.weights[i])
          childs.gadgets[i]:set({ position = { x = startpos.x, y = startpos.y },
                                  size = { w = worksize.w, h = h } }, False)
          startpos.y = startpos.y + childs.gap + childs.gadgets[i].area.size.h + 1
        ElseIf childs.weights[i] > 1
          Local w = worksize.w
          Local h = Round(childs.weights[i])
          childs.gadgets[i]:set({ position = { x = startpos.x, y = startpos.y },
                                  size = { w = worksize.w, h = h } }, False)
          startpos.y = startpos.y + childs.gap + h + 1
        ElseIf childs.weights[i] = 0
          ; qua c'era un bug che impostava a 1 l'altezza e poi incrementava ulteriormente
          ; di uno
          Local w = worksize.w
          Local h = 0
          childs.gadgets[i]:set({ position = { x = startpos.x, y = startpos.y },
                                  size = { w = worksize.w, h = h } }, False)
          startpos.y = startpos.y + childs.gap + h; + 1

        EndIf
      Next

    Case #HGUI_HORIZONTAL_LAYOUT
      Local worksize = { w = self.area.size.w - childs.borders.left - childs.borders.right - (GadCount-1)*(childs.gap+1) - childs.Fixed_Size ,
                         h = self.area.size.h - childs.borders.top - childs.borders.bottom}
      ;=== VIRTUAL GADGET HANDLING ===
      If self.Private.IsVirtualRoot
        startpos = { x = self.VirtualOffset.x + childs.borders.left + self.area.position.x,
                     y = self.VirtualOffset.y  + childs.borders.top + self.area.position.y }
        worksize = { w = self.VirtualSize.w - childs.borders.left - childs.borders.right,
                     h = self.VirtualSize.h - childs.borders.top - childs.borders.bottom - (GadCount-1)*(childs.gap+1) - childs.Fixed_Size }
      EndIf
      
      For Local i = 0 To gadcount - 1
        If childs.weights[i] > 0 And childs.weights[i] <= 1
          Local w = worksize.w * childs.weights[i]
          Local h = worksize.h
          childs.gadgets[i]:set({ position = { x = startpos.x, y = startpos.y },
                                  size = { w = w, h = h } }, False)
          startpos.x = startpos.x + childs.gap + Round(w) + 1
        ElseIf childs.weights[i] < 0 And childs.weights[i] >= -1
          Local w = self.window.nativesize.w * (-childs.weights[i])
          Local h = worksize.h
          childs.gadgets[i]:set({ position = { x = startpos.x, y = startpos.y },
                                  size = { w = w, h = worksize.h } }, False)
          startpos.x = startpos.x + childs.gap + childs.gadgets[i].area.size.x + 1
        ElseIf childs.weights[i] > 1
          Local w = Round(childs.weights[i])
          Local h = worksize.h
          childs.gadgets[i]:set({ position = { x = startpos.x, y = startpos.y },
                                  size = { w = w, h = worksize.h } }, False)
          startpos.x = startpos.x + childs.gap + w + 1
        ElseIf childs.weights[i] = 0
          Local w = 0
          Local h = worksize.h
          childs.gadgets[i]:set({ position = { x = startpos.x, y = startpos.y },
                                  size = { w = w, h = worksize.h } }, False)
          startpos.x = startpos.x + childs.gap + w; + 1
        EndIf
      Next

    Case #HGUI_GRID_LAYOUT
      Local worksize = { w = self.area.size.w - self.childs.borders.left - self.childs.borders.right - (childs.columns-1)*self.childs.gap,
                         h = self.area.size.h - self.childs.borders.top - self.childs.borders.bottom - (childs.rows-1)*self.childs.gap }
      ;=== VIRTUAL GADGET HANDLING ===
      /*
      If self.Type = #HGUI_VIRTUAL_GADGET
        DebugPrint("UPDATE VIRTUAL INITIAL POS & WORKSIZE")
        startpos = { x = self.VirtualOffset.x + childs.borders.left,
                     y = self.VirtualOffset.y  + childs.borders.top  }
        worksize = { w = self.VirtualSize.w - childs.borders.left - childs.borders.right,
                     h = self.VirtualSize.h - childs.borders.top - childs.borders.bottom - (GadCount-1)*(childs.gap+1) - childs.Fixed_Size }
        DBG.DumpTable(startpos)
        DBG.DumpTable(worksize)
      EndIf  
*/
      Local columns = childs.columns
      Local rows    = childs.rows

      childs.item_width = Worksize.w / columns
      childs.item_height = Worksize.h / rows

      Local i = 0
      For Local r = 1 To rows
        Local spx = startpos.x
        For Local c = 1 To columns
          Local xpos = spx + childs.item_width * (c-1)
          Local ypos = startpos.y + childs.item_height * (r-1)
          childs.gadgets[i]:set({ position = { x = xpos, y = ypos },
                                  size = { w = childs.item_width, h = childs.item_height } }, False)
          i = i + 1
          spx = spx + childs.gap + 1
          If i > gadcount - 1 Then Break(2)
        Next
        startpos.y = startpos.y + childs.gap
      Next

    Default
      DBG.Console.Out("Unknown Layout <" .. childs.type .. ">.", DBG.Error, HGui.DebugChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)

  EndSwitch

  childs.last_parent_size = { w = self.area.size.w, h = self.area.size.h }
  childs.last_parent_pos  = { x = self.area.position.x, y = self.area.position.y }

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
  Return(True)

EndFunction

Function HGui.Gadget:layoutSet(options, update) ; *TriDoc*
/*---------------------------------------------------------
HGui.Gadget:layoutSet(options, update)

This method is used to build the interface layout, here you can define which gadget must be placed inside the current one and in which way. 
<update> is a switch : if set to TRUE the involved gadgets will be updated at the end of the elaboration.
All definitions must be specified inside the <options> table.
-----------------------------------------------------------
INPUT
  options : A table used to specify the gadgets layout:
    gadgets : A table holding all the gadget objects you want to place inside the current one.
    type : Used to define the arrangement type, you can choice from : #HGUI_VERTICAL_LAYOUT (default), #HGUI_HORIZONTAL_LAYOUT, #HGUI_GRID_LAYOUT
    weights : This table is used to define the gadget weights (sizes) and it isn't needed for the GRID layout. If you do not specify this table the available space will be divided equaly by all gadgets. Each value is interpreted as follow:
      - value < 0 : percentual fixed size
      - 0 < value < 1 : percentual variable size
      - value > 1 : fixed pixel size
    gap : This value is the space between each gadget expressed in pixels. Default is 1.
    borders : It's a table used to define the blank space between the gadgets and it's father, each value is expressed in pixels, default is 0. Note that using 0 means that the gadgets will be renderd over the father's border, if it have one. It must have these fields: 
      Top
      Bottom
      Left
      Right
    columns : Only used with GRID layout: sets how many columns the grid must have. Needed rows will be computed by the system.
    rows : Only used with GRID layout: sets how many rows the grid must have. Columns will be computed by the system.

OUTPUT
  result : TRUE if the operation completed without errors.

NOTE
  With the GRID layout you have to specify the <columns> parameter OR the <rows> parameter, if you define both then <columns> will get the precedence and <rows> will be ignored.

EXAMPLE
  | ; Defines a box gadget
  | Local boxGadget = HGui.Gadget:New(#HGUI_BOX_GADGET)
  |
  | ; Now defines two more boxes that will be adjusted in a vertical
  | ; layout in the 'boxGadget'
  |
  | Local smallerBox1 = HGui.Gadget:New(#HGUI_BOX_GADGET)
  | Local smallerBox2 = HGui.Gadget:New(#HGUI_BOX_GADGET)
  | ; Arranges the two smaller box inside the first one
  | boxGadget:SetLayout(
  |   { gadgets = { smallerBox1, smallerBox2 },
  |     weights = { 0.30, 0.70 },
  |     type = #HGUI_VERTICAL_LAYOUT,
  |     gap = 1,
  |     borders = { Top = 2, Bottom = 2, Right = 1, Left = 1 }
  |     }, True)
---------------------------------------------------------*/
  DBG.Console.Out("[ HGui.Gadget:layoutSet ] : Set <" .. self.name .. "> layout...", DBG.OpenFunc, HGui.DebugChannel)

  Local Gadget = self
  Local RootGadget = self
  
  If TB.Item.IsNil(Gadget, "init_mode")
    If Gadget.Type = #HGUI_GROUP_GADGET
      If Gadget.Group_LabelSide = #HGUI_ALIGN_TOP Or Gadget.Group_LabelSide = #HGUI_ALIGN_LEFT
        Gadget = self.childs.gadgets[0].childs.gadgets[1]
      Else
        Gadget = self.childs.gadgets[0].childs.gadgets[0]
      EndIf
    EndIf
  EndIf

  If HL.IsNil(update) Then Update = False

  If TB.Item.IsNil(options, "gadgets")
    DBG.Console.Out("Missing gadget list, operation failed.", DBG.Error, HGui.DebugChannel)
    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
    Return(False)
  EndIf

  Local GadCount = TB.Count(options.gadgets)

  If GadCount = 0
    DBG.Console.Out("Gadget list is empty, operation failed.", DBG.Error, HGui.DebugChannel)
    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
    Return(False)
  EndIf

  If TB.Item.IsNil(options, "weights")   
    DBG.Console.Out("Applying automatic weights (" .. 1/GadCount .. ")", DBG.Warning, HGui.DebugChannel)
    options.weights = {}
    Local w = 1/GadCount
    For Local i = 1 To GadCount Do options.weights[i-1] = w
  Else
    If TB.Count(options.weights) <> GadCount
      DBG.Console.Out("Gadget list & weight list does not match, operation failed.", DBG.Error, HGui.DebugChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
      Return(False)
    EndIf
  EndIf

  If TB.Item.IsNil(options, "type") Then options.type = #HGUI_VERTICAL_LAYOUT
  If TB.Item.IsNil(options, "gap") Then options.gap = 1
  If TB.Item.IsNil(options, "borders")
    options.borders = { top = 0, bottom = 0, left = 0, right = 0 }
  Else
    If TB.Item.IsNil(options, "top") Then options.top = 0
    If TB.Item.IsNil(options, "bottom") Then options.bottom = 0
    If TB.Item.IsNil(options, "left") Then options.left = 0
    If TB.Item.IsNil(options, "right") Then options.right = 0
  EndIf

  ;---| GROUP GADGET : Setup childs |---
  If self.Type = #HGUI_GROUP_GADGET
    If TB.Item.IsNil(options, "subtype")
      options.SubType = #HGUI_GTYPE_GENERIC
    EndIf

    For Local i = 0 To ListItems(options.gadgets) - 1
      options.gadgets[i].private.Grouped = True
      options.gadgets[i].private.SubType = RootGadget.SubType
      options.gadgets[i].private.Brothers = {}
      Local ic = 0
      For Local ii = 0 To ListItems(options.gadgets) - 1
        If i <> ii
          options.gadgets[i].private.Brothers[ic] = options.gadgets[ii]
          ic = ic + 1
        EndIf
      Next
    Next

  EndIf
  ;--------------------------------------
  Gadget.childs = { gadgets = options.gadgets,
                    weights = options.weights,
                    type    = options.type,
                    gap     = options.gap,
                    borders = options.borders,
                    fixed_size = 0,
                    last_parent_size = { w = -1, h = -1 },
                    last_parent_pos  = { x = -1, y = -1 },
                    options = options }
              
   If options.type = #HGUI_GRID_LAYOUT
      If TB.Item.Exists(options, "columns")
         options.rows = Int(GadCount / options.columns)
         If options.columns * options.rows <> GadCount Then options.rows = options.rows + 1
      ElseIf TB.Item.Exists(options, "rows")
         options.columns = Int(GadCount / options.rows)
         If options.rows * options.columns <> GadCount Then options.columns = options.columns + 1
      Else
         DBG.Console.Out("Grid layout needs <columns> or <rows> specification, operation failed.", DBG.Error, HGui.DebugChannel)
         DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
         Return(False)
      EndIf

      Gadget.childs.rows = options.rows
      Gadget.childs.columns = options.columns
   EndIf

   Local fixed_size   = 0
   Local fixed_count  = 0
   Local perc         = 0
   Local worksize = { w = Gadget.area.size.w - Gadget.childs.borders.left - Gadget.childs.borders.right - (GadCount-1)*Gadget.childs.gap,
                      h = Gadget.area.size.h - Gadget.childs.borders.top - Gadget.childs.borders.bottom - (GadCount-1)*Gadget.childs.gap }
;=== VIRTUAL ===
   If Gadget.Private.IsVirtualRoot
     worksize = { w = Gadget.VirtualSize.w - Gadget.childs.borders.left - Gadget.childs.borders.right - (GadCount-1)*Gadget.childs.gap,
                  h = Gadget.VirtualSize.h - Gadget.childs.borders.top - Gadget.childs.borders.bottom - (GadCount-1)*Gadget.childs.gap }
     ; Marca tutti i gadget come virtualizzati e memorizza il padre
     For i, g In Pairs(options.gadgets)
      g.isVirtualized = True
      g.VirtualRoot = Gadget
     Next
   ElseIf Gadget.IsVirtualized
      For i, g In Pairs(options.gadgets)
        g.isVirtualized = True
        g.VirtualRoot = Gadget.VirtualRoot
      Next
   EndIf

   Switch Gadget.childs.type
      ;:::::::::::::::::::::::::::::::::::::::::::::::::::::: VERTICAL LAYOUT ::
      Case #HGUI_VERTICAL_LAYOUT
         For Local i = 0 To GadCount - 1
            If Gadget.childs.weights[i] < 0 And Gadget.childs.weights[i] >= -1
               ; -1 <= w < 0      
               Fixed_Size         = Fixed_Size + (-options.weights[i])
               fixed_count        = fixed_count + 1
               options.weights[i] = worksize.h * (-options.weights[i])

            ElseIf Gadget.childs.weights[i] > 1
               ; w > 1
               Fixed_Size         = Fixed_Size + (options.weights[i]/worksize.h)
               fixed_count        = fixed_count + 1
               
            Else
               ; w < -1 or 0 < w <= 1
               Perc               = Perc + options.weights[i]

            EndIf
         Next
         Local check = perc + fixed_size
         Local delta = 0
         If check > 1
            ; Riduzione in parti uguali dei valori variabili
            If (GadCount-Fixed_Count) <> 0 Then delta = (check-1)/(GadCount-Fixed_Count)
         EndIf

         If (GadCount - fixed_count) <> 0
            Local fixed_add = fixed_size / (GadCount - fixed_count)
            For Local i = 0 To GadCount - 1
               Gadget.Childs.Gadgets[i].Parent = self
               If Gadget.childs.weights[i] > 0 And Gadget.childs.weights[i] <= 1
                  Gadget.childs.weights[i] = Gadget.childs.weights[i] + fixed_add - delta
               EndIf
            Next
         EndIf

         Gadget.childs.fixed_size = Fixed_Size * worksize.h

      ;:::::::::::::::::::::::::::::::::::::::::::::::::::: HORIZONTAL LAYOUT ::
      Case #HGUI_HORIZONTAL_LAYOUT
         For Local i = 0 To GadCount - 1
            If Gadget.childs.weights[i] < 0 And Gadget.childs.weights[i] >= -1
               ; -1 <= w < 0
               Fixed_Size         = Fixed_Size + (-options.weights[i])
               fixed_count        = fixed_count + 1
               options.weights[i] = worksize.w * (-options.weights[i])

            ElseIf Gadget.childs.weights[i] > 1    
               ; w > 1
               Fixed_Size         = Fixed_Size + (options.weights[i]/worksize.w)
               fixed_count        = fixed_count + 1
  
            Else            
               ; w < -1 or 0 < w <= 1
               Perc               = Perc + options.weights[i]

            EndIf
         Next

         Local check = perc + fixed_size
         Local delta = 0
         If check > 1
            ; Riduzione in parti uguali dei valori variabili
            If (GadCount-Fixed_Count) <> 0 Then delta = (check-1)/(GadCount-Fixed_Count)
         EndIf

         If (GadCount - fixed_count) <> 0
            Local fixed_add = fixed_size / (GadCount - fixed_count)
            For Local i = 0 To GadCount - 1
               Gadget.Childs.Gadgets[i].Parent = self
               If Gadget.childs.weights[i] > 0 And Gadget.childs.weights[i] <= 1
                  Gadget.childs.weights[i] = Gadget.childs.weights[i] + fixed_add - delta
               EndIf
            Next
         EndIf

         Gadget.childs.fixed_size = Fixed_Size * worksize.w

      ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: GRID LAYOUT ::
      ;:: Questo layout si aspetta che il parametro <columns> indichi il      ::
      ;:: numero di colonne che costituiranno la griglia, le  righe saranno   ::
      ;:: ricavate di conseguenza.                                            ::

      Case #HGUI_GRID_LAYOUT
         ;Gadget.childs.columns = 2
         ;Gadget.childs.rows = Int(GadCount / Gadget.childs.columns)
         ;If Gadget.childs.columns * Gadget.childs.rows <> GadCount Then Gadget.childs.rows = Gadget.childs.rows + 1

         Local worksize = { w = Gadget.area.size.w - Gadget.childs.borders.left - Gadget.childs.borders.right - (Gadget.childs.columns-1)*Gadget.childs.gap,
                            h = Gadget.area.size.h - Gadget.childs.borders.top - Gadget.childs.borders.bottom - (Gadget.childs.rows-1)*Gadget.childs.gap }

         Gadget.childs.item_width = Worksize.w / Gadget.childs.columns
         Gadget.childs.item_height = Worksize.h / Gadget.childs.rows

         For Local i = 0 To GadCount - 1
            Gadget.Childs.Gadgets[i].Parent = self
         Next


      ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Default
         DBG.Console.Out("Unrecognized layout type, operation failed.", DBG.Error, HGui.DebugChannel)
         DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
         Return(False)

   EndSwitch


   If update Then Gadget:layoutUpdate(True)

   DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)

   Return(True)

EndFunction

Function HGui.Gadget:Hide(refresh) ; *TriDoc*
/*-------------------------------------------------------------------
HGui.Gadget:Hide()

Disables and hides this gadget from the current window
-------------------------------------------------------------------*/
  
  self:set({ flags = { visible = False } }, False)
  
  ; Recursive hiding
  If TB.Item.Exists(self.childs, "gadgets") And SkipChilds = False
    Local CCount = TB.Count(self.Childs.gadgets)
    For Local i = 0 To CCount - 1
      self.childs.gadgets[i]:Hide(refresh)
    Next
  EndIf
  
  If refresh Then self.window:Render()
  
EndFunction

Function HGui.Gadget:Show(refresh) ; *TriDoc*
/*-------------------------------------------------------------------
HGui.Gadget:Show()

Enables and shows this previously hidden gadget
-------------------------------------------------------------------*/
  
  self:set({ flags = { visible = True } }, False)
  self:enable()
  
  ; Recursive enabling
  If TB.Item.Exists(self.childs, "gadgets") And SkipChilds = False
    Local CCount = TB.Count(self.Childs.gadgets)
    For Local i = 0 To CCount - 1
      self.childs.gadgets[i]:Show(refresh)
    Next
  EndIf
  
  If refresh Then self.window:Render()
  
EndFunction

Function HGui.Gadget:Enable() ; *TriDoc*
/*-------------------------------------------------------------------
HGui.Gadget:Enable()

Put the gadget in the Enabled / Normal state
---------------------------------------------------------------------
NOTE
  This function is recursive, all children gadget will be enabled as well.
-------------------------------------------------------------------*/

  If self.type = #HGUI_SWITCH_GADGET
    If self.private.value = 1
      ; Switch ON
      self:set({ status = #HGUI_NPUSHED_STATE }, False)
    Else
      ; Switch OFF
      self:set({ status = #HGUI_NORMAL_STATE }, False)
    EndIf
  Else
    self:set({ status = #HGUI_NORMAL_STATE }, False)
  EndIf
  
  ; Recursive enabling
  If TB.Item.Exists(self.childs, "gadgets") And SkipChilds = False
    Local CCount = TB.Count(self.Childs.gadgets)
    For Local i = 0 To CCount - 1
      self.childs.gadgets[i]:Enable()
    Next
  EndIf
  
  self:Render()

EndFunction

Function HGui.Gadget:Disable() ; *TriDoc*
/*--------------------------------------
HGui.Gadget:Disable()

Put the gadget in the disabled state
---------------------------------------------------------------------
NOTE
  This function is recursive, all children gadget will be disabled as well.
-------------------------------------------------------------------*/
  If self.type = #HGUI_SWITCH_GADGET
    If self.private.value = 1
      ; Switch On
      self:set({ status = #HGUI_DPUSHED_STATE }, False)
    Else
      ; Switch Off
      self:set({ status = #HGUI_DISABLED_STATE }, False)
    EndIf
  Else
    self:set({ status = #HGUI_DISABLED_STATE }, False)
  EndIf
  
  ; Recursive disabling
  If TB.Item.Exists(self.childs, "gadgets") And SkipChilds = False
    Local CCount = TB.Count(self.Childs.gadgets)
    For Local i = 0 To CCount - 1
      self.childs.gadgets[i]:Disable()
    Next
  EndIf
  
  self:Render()
EndFunction

Function HGui.Gadget:Render(partial, skipChilds, Quiet) ; *TriDoc*
/*-------------------------------------------------------------------
result = HGui.Gadget:Render(partial, skipChilds, Quiet)

Render the gadget and its children depending on its current state.
---------------------------------------------------------------------
INPUT
  partial    : Switch used with text gadgets for the final rendering. Default = False
  skipChilds : Switch used to avoid the rendering of children gadgets. Default = False
  Quiet      : TRUE to do not activate the rendering target window.

OUTPUT
  result : TRUE if the rendering has been completed.

NOTES
  Note that if AutoRendering is switched off with HGui.SetAutoRendering(), the rendering will be skipped completely. Also Hidden gadgets will be skipped completely.
  This function is fully recursive, children gadgets will be rendered as well.
  09/10/2021 : Removed all DebugOutput but error messages.
------------------------------------------------------------------*/
  ; DBG.Console.Out(".Gadget:Render() -> " .. self.name, DBG.OpenFunc, HGui.DebugChannel)

  If IsNil(partial) Then partial = False
  If IsNil(skipChilds) Then skipChilds = False
  
  ; Skip the render if auto-rendering is switched off
  If HGui.AutoRendering = False
    ; DBG.Console.Out("Cannot render gadget <" .. self.name .. "> and its childs, <AutoRendering> is OFF...", DBG.Warning, HGui.DebugChannel)
    ; DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
    Return(False)
  EndIf

  If self.IsKilled
    DBG.Console.Out("Cannot render gadget '" .. self.name .. "' and its childs, IT'S KILLED!", DBG.Warning, HGui.DebugChannel)
    Return(False)
  EndIf
 
  If Not(self.Flags.Visible)
    DBG.Console.Out("Cannot render gadget '" .. self.name .. "' and its childs, IT'S INVISIBLE!", DBG.Warning, HGui.DebugChannel)
    ;DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
    Return(False)
  EndIf

  GFX.OutputDevice.Select(#DISPLAY, self.window.private.HWId, Quiet)
  
  Local clipArea = -1
  Local vRoot = {}

  ; Create a clip region if this one is a virtualized gadget
  If self.isVirtualized
    vRoot    = self.VirtualRoot
    clipArea = CreateClipRegion(Nil, #BOX, vRoot.Area.Position.x, vRoot.Area.Position.y, vRoot.Area.Size.w, vRoot.Area.Size.h)
    SetClipRegion(clipArea)
  EndIf
   
  Switch self.type
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: RENDER BOX :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_BOX_GADGET
      If self.usecache
        ; TEST AREA ON 26/10/2018 -----------------
        If TB.Item.Exists(self.private, "father")
          If self.private.Father.Type = #HGUI_IMAGE_GADGET
            If self.fadein = True
              self.asynchID = DisplayBrushFX(
                                self.private.cache.normal, 
                                self.area.position.x, 
                                self.area.position.y,
                                { Type = #CROSSFADE,
                                  Speed = #NORMALSPEED,
                                  Async = True })
              self.asynchUpdater = SetInterval(Nil, 
                Function(msg)
                  SelectDisplay(msg.userdata, True)
                  If AsyncDrawFrame(self.asynchID)
                    ClearInterval(self.asynchUpdater)
                    self.asynchUpdater = Nil
                    self.asynchID = Nil
                  EndIf
                  SelectDisplay(HGui.ActiveWindow.Private.HWId, True)
                EndFunction,
              50,
              self.Window.Private.HWId)
            Else
              DisplayBrush(self.private.cache.normal, self.area.position.x, self.area.position.y)
            EndIf
          Else
            DisplayBrush(self.private.cache.normal, self.area.position.x, self.area.position.y)
          EndIf
        Else
          ; -----------------------------------------
          ; Render the canvas contents
          DisplayBrush(self.private.cache.normal, self.area.position.x, self.area.position.y)
        EndIf
        
      Else
        Local tArea = G2D.Area:new(self.Area.position.x, self.Area.position.y, self.Area.size.w, self.Area.size.h)
        self:draw(tArea)
      EndIf

      ; Check if this one is a ListView/TreeView contents container
      If TB.Item.Exists(self, "islistviewcontents")
        If self.private.Father.Type = #HGUI_LISTVIEW_GADGET
          HGui.ListView_ContentsUpdate(self.private.Father)

        ElseIf self.private.Father.Type = #HGUI_TREEVIEW_GADGET
          HGui.treeView_ContentsUpdate(self.private.Father)
        EndIf
      EndIf

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: RENDER VDIVIDER ::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_VDIVIDER_GADGET
        If self.usecache
          DisplayBrush(self.private.cache.normal, self.area.position.x, self.area.position.y)

        Else
          Local tArea = G2D.Area:new(self.Area.position.x, self.Area.position.y, self.Area.size.w, self.Area.size.h)
          self:draw(tArea)
        EndIf

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: RENDER HDIVIDER ::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_HDIVIDER_GADGET
        If self.usecache

          DisplayBrush(self.private.cache.normal, self.area.position.x, self.area.position.y)
        Else
          Local tArea = G2D.Area:new(self.Area.position.x, self.Area.position.y, self.Area.size.w, self.Area.size.h)
          self:draw(tArea)
        EndIf

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: RENDER LABEL :::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_LABEL_GADGET
        If self.usecache
          DisplayBrush(self.Private.Cache.Normal, self.Area.Position.x, self.Area.Position.y)
          If Not(HGui.CacheGadText) Then self.Look.nText:Render(Nil, { x = self.Area.Position.x, y = self.Area.Position.y, w = self.Area.Size.w, h = self.Area.Size.h })
          
        Else
          Local tArea = G2D.Area:new(self.Area.position.x, self.Area.position.y, self.Area.size.w, self.Area.size.h)
          self:draw(tArea)
        EndIf

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;:::  RENDER GROUP ::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_GROUP_GADGET
        ; NOT NEEDED BECAUSE IT'S A COMPOSITE GADGET

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: RENDER VIRTUAL :::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_VIRTUAL_GADGET
        ; NOT NEEDED BECAUSE IT'S A COMPOSITE GADGET

      ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: RENDER BUTTON :::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_BUTTON_GADGET
        If self.usecache
          Local br = 0
          Switch self.Status
            Case #HGUI_NORMAL_STATE
              br = self.private.cache.normal

            Case #HGUI_HILIGHTED_STATE
              br = self.private.cache.hilight

            Case #HGUI_PUSHED_STATE
              br = self.private.cache.pushed

            Case #HGUI_DISABLED_STATE
              br = self.private.cache.disabled

            Default
              DBG.Console.Out("Unrecognized button state <" .. self.status .. ">", DBG.Error, HGui.DebugChannel)

          EndSwitch

          Local px, py, args = self.area.position.x, self.area.position.y, {}

          If TB.Item.Exists(self, "islistviewheader")
            ; Check if it's a ListView header, if so try to clip its content and render it
            ; with the current offset.
            Local TBArea = self.Father.TopBox.Area
            Local cid = CreateClipRegion(Nil, #BOX, TBArea.position.x, TBArea.position.y, TBArea.size.w+1, TBArea.size.h+1)
            SetClipRegion(cid)
            DisplayBrush(br, px+self.Look.Offset.x, py)
            FreeClipRegion(cid)
          Else
            ; Otherwise renders the cache
            DisplayBrush(br, px, py)
          EndIf

          If Not(HGui.CacheGadText)
            Switch self.Status
              Case #HGUI_NORMAL_STATE
                br = self.look.ntext

              Case #HGUI_HILIGHTED_STATE
                br = self.look.htext

              Case #HGUI_PUSHED_STATE
                br = self.look.ptext

              Case #HGUI_DISABLED_STATE
                br = self.look.dtext

              Default
                DBG.Console.Out("Unrecognized button state <" .. self.status .. ">", DBG.Error, HGui.DebugChannel)

            EndSwitch

            br:Render(Nil, { x = self.area.position.x, y = self.area.position.y, w = self.area.size.w, h = self.area.size.h })
          EndIf

        Else
          Local bg = {}
          If TB.Item.Exists(self, "background") Then bg = self.background
          If self.flags.visible = #HGUI_VISIBLE
            GFX.OutputDevice.Select(#DISPLAY, self.window.private.HWId)
            Local Area = { x = self.area.position.x, y = self.area.position.y, w = self.area.size.w, h = self.area.size.h }
            Local tArea  = G2D.Area:new(Area.x, Area.y, Area.w, Area.h)
            Local sk, br, ic = {}, {}, ""
            Local iconAlign = self.look.icons.alignment
               
            Switch self.Status
              Case #HGUI_NORMAL_STATE
                sk = self.look.nskin
                br = self.look.ntext
                ic = "nname"

              Case #HGUI_HILIGHTED_STATE
                sk = self.look.hskin
                br = self.look.htext
                ic = "hname"

              Case #HGUI_PUSHED_STATE
                sk = self.look.pskin
                br = self.look.ptext
                ic = "pname"

              Case #HGUI_DISABLED_STATE
                sk = self.look.dskin
                br = self.look.dtext
                ic = "dname"

              Default
                DBG.Console.Out("Unrecognized button state <" .. self.status .. ">", DBG.Error, HGui.DebugChannel)

            EndSwitch

            tArea:skinMulti(sk)

            If TB.Item.Exists(self.look.icons, ic)
              Local iname = self.look.icons[ic]
              Local iptr  = GFX.Image.get(iname)
              Local x, y  = 0, 0
              If iconAlign & #HGUI_ALIGN_LEFT    = #HGUI_ALIGN_LEFT    Then x = self.look.icons.gap / 2
              If iconAlign & #HGUI_ALIGN_RIGHT   = #HGUI_ALIGN_RIGHT   Then x = area.w - self.look.icons.gap / 2 - iptr.size.w
              If iconAlign & #HGUI_ALIGN_TOP     = #HGUI_ALIGN_TOP     Then y = self.look.icons.gap / 2
              If iconAlign & #HGUI_ALIGN_BOTTOM  = #HGUI_ALIGN_BOTTOM  Then y = area.h - self.look.icons.gap / 2 - iptr.size.h
              If iconAlign & #HGUI_ALIGN_HCENTER = #HGUI_ALIGN_HCENTER Then x = (area.w - iptr.size.w)/2
              If iconAlign & #HGUI_ALIGN_VCENTER = #HGUI_ALIGN_VCENTER Then y = (area.h - iptr.size.h)/2
              iptr:draw({ x = x + self.area.position.x, y = y + self.area.position.y })
            EndIf
            br:render(Nil, { x = self.area.position.x, y = self.area.position.y, w = self.area.size.w, h = self.area.size.h })
            GFX.OutputDevice.EndSelect()
          EndIf
        EndIf

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: RENDER SWITCH ::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_SWITCH_GADGET
        If self.usecache
          Local br = 0
          Switch self.Status
            Case #HGUI_NORMAL_STATE
              br = self.private.cache.normal

            Case #HGUI_HILIGHTED_STATE
              br = self.private.cache.hilight

            Case #HGUI_PUSHED_STATE
              br = self.private.cache.pushed

            Case #HGUI_DISABLED_STATE
              br = self.private.cache.disabled

            Case #HGUI_NPUSHED_STATE
              br = self.private.cache.npushed

            Case #HGUI_HPUSHED_STATE
              br = self.private.cache.hpushed

            Case #HGUI_DPUSHED_STATE
              br = self.private.cache.dpushed

            Default
              DBG.Console.Out("Unrecognized switch state <" .. self.status .. ">", DBG.Error, HGui.DebugChannel)

          EndSwitch

          DisplayBrush(br, self.area.position.x, self.area.position.y)

          If Not(HGui.CacheGadText)
            Switch self.Status
              Case #HGUI_NORMAL_STATE
                br = self.look.ntext

              Case #HGUI_HILIGHTED_STATE
                br = self.look.htext

              Case #HGUI_PUSHED_STATE
                br = self.look.ptext

              Case #HGUI_DISABLED_STATE
                br = self.look.dtext

              Case #HGUI_NPUSHED_STATE
                br = self.look.nptext
                     
              Case #HGUI_HPUSHED_STATE
                br = self.look.hptext
                     
              Case #HGUI_DPUSHED_STATE
                br = self.look.dpstate
                     
              Default
                DBG.Console.Out("Unrecognized switch state <" .. self.status .. ">", DBG.Error, HGui.DebugChannel)

            EndSwitch

            br:Render(Nil, { x = self.area.position.x, y = self.area.position.y, w = self.area.size.w, h = self.area.size.h })
          EndIf

        Else
          Local bg = {}
          If TB.Item.Exists(self, "background") Then bg = self.background
          If self.flags.visible = #HGUI_VISIBLE
            GFX.OutputDevice.Select(#DISPLAY, self.window.private.HWId)
            Local Area = { x = self.area.position.x, y = self.area.position.y, w = self.area.size.w, h = self.area.size.h }
            Local tArea = G2D.Area:new(Area.x, Area.y, Area.w, Area.h)
            Local sk, br, ic = {}, {}, ""
            Local iconAlign = self.look.icons.alignment
               
            Switch self.Status
              Case #HGUI_NORMAL_STATE
                sk = self.look.nskin
                br = self.look.ntext
                ic = "nname"

              Case #HGUI_HILIGHTED_STATE
                sk = self.look.hskin
                br = self.look.htext
                ic = "hname"

              Case #HGUI_PUSHED_STATE
                sk = self.look.pskin
                br = self.look.ptext
                ic = "pname"

              Case #HGUI_DISABLED_STATE
                sk = self.look.dskin
                br = self.look.dtext
                ic = "dname"
                  
              Case #HGUI_NPUSHED_STATE
                sk = self.look.npskin
                br = self.look.nptext
                ic = "npname"
                     
              Case #HGUI_HPUSHED_STATE
                sk = self.look.hpskin
                br = self.look.hptext
                ic = "hpname"
                     
              Case #HGUI_DPUSHED_STATE
                sk = self.look.dpskin
                br = self.look.dptext
                ic = "dpname"

              Default
                DBG.Console.Out("Unrecognized button state <" .. self.status .. ">", DBG.Error, HGui.DebugChannel)

            EndSwitch

            tArea:skinMulti(sk)
  
            If TB.Item.Exists(self.look.icons, ic)
              Local iname = self.look.icons[ic]
              Local iptr  = GFX.Image.Get(iname)
              Local x, y  = 0, 0
              If iconAlign & #HGUI_ALIGN_LEFT    = #HGUI_ALIGN_LEFT    Then x = self.look.icons.gap / 2
              If iconAlign & #HGUI_ALIGN_RIGHT   = #HGUI_ALIGN_RIGHT   Then x = area.w - self.look.icons.gap / 2 - iptr.size.w
              If iconAlign & #HGUI_ALIGN_TOP     = #HGUI_ALIGN_TOP     Then y = self.look.icons.gap / 2
              If iconAlign & #HGUI_ALIGN_BOTTOM  = #HGUI_ALIGN_BOTTOM  Then y = area.h - self.look.icons.gap / 2 - iptr.size.h
              If iconAlign & #HGUI_ALIGN_HCENTER = #HGUI_ALIGN_HCENTER Then x = (area.w - iptr.size.w)/2
              If iconAlign & #HGUI_ALIGN_VCENTER = #HGUI_ALIGN_VCENTER Then y = (area.h - iptr.size.h)/2
              iptr:draw({ x = x + self.area.position.x, y = y + self.area.position.y })
            EndIf
            br:render(Nil, { x = self.area.position.x, y = self.area.position.y, w = self.area.size.w, h = self.area.size.h })
            GFX.OutputDevice.EndSelect()
          EndIf
        EndIf

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: RENDER SCROLLBAR :::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_SCROLLBAR_GADGET
        ; NOT NEEDED BECAUSE IT'S A COMPOSITE GADGET

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: RENDER PROGRESSBAR :::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_PROGRESSBAR_GADGET
        ; NOT NEEDED BECAUSE IT'S A COMPOSITE GADGET

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: RENDER LISTVIEW ::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_LISTVIEW_GADGET
        ; NOT NEEDED BECAUSE IT'S A COMPOSITE GADGET
        ; E' necessario fare un refresh degli headers perch√® quando la finestra
        ; viene ridimensionata (allargata), gli header che vengono 'scoperti'
        ; non sono attivi.
         Local count = ListItems(self.Headers)-1
         For Local i = 0 To count
            Local Header = self.Headers[i]
            Header.Look.Offset = { x = Header.Look.Offset.x, y = 0 }
            Header.Area:set({ position = Header.Area.Position }, Header, Header.Look.Offset)
         Next

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: RENDER TREEVIEW ::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_TREEVIEW_GADGET
        ; NOT NEEDED BECAUSE IT'S A COMPOSITE GADGET

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: RENDER DROPDOWN ::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_DROPDOWN_GADGET
        ; NOT NEEDED BECAUSE IT'S A COMPOSITE GADGET

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: RENDER IMAGE :::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_IMAGE_GADGET
        ; NOT NEEDED BECAUSE IT'S A COMPOSITE GADGET

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: RENDER SLIDER ::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_SLIDER_GADGET
        ; NOT NEEDED BECAUSE IT'S A COMPOSITE GADGET

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: RENDER CANVAS ::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_CANVAS_GADGET
        ; Update the Output box with the layer contents
        GFX.OutputDevice.Select(#BRUSH, self.OutputBox.Private.Cache.Normal, #SELMODE_COMBO, 2)
        For i, v In IPairs(self.Layers)
          DisplayBrush(v, 0, 0)
        Next
        GFX.OutputDevice.EndSelect()

        
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: RENDER KNOB ::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_KNOB_GADGET
        If self.usecache
          DisplayBrush(self.private.cache.normal, self.area.position.x, self.area.position.y)

        Else
          Local bg = {}
          If TB.Item.Exists(self, "background") Then bg = self.background
          If self.flags.visible = #HGUI_VISIBLE
            GFX.OutputDevice.Select(#DISPLAY, self.window.private.HWId)
              Local Area = { x = self.area.position.x, y = self.area.position.y, w = self.area.size.w, h = self.area.size.h }
              GFX.Skin.Area(Area, self.Look.nSkin, bg)
              ;Local tArea = G2D.Area:new(0, 0, self.area.size.w, self.area.size.h)
              ;tArea:skinMulti(self.Look.nSkin)

              Local bs1 = self.Style.BorderSize1
              Local bs2 = self.Style.BorderSize2
              Local b1l = self.Style.Border1Light
              Local b1d = self.Style.Border1Dark
              Local b1fa = self.Style.Border1FillA
              Local b1fb = self.Style.Border1FillB
              Local b2l = self.Style.Border2Light
              Local b2d = self.Style.Border2Dark
              Local b2fa = self.Style.Border2FillA
              Local b2fb = self.Style.Border2FillB
              Local t = self.Style.Type

              GFX.OutputDevice.Select(#BRUSH, tmpBrush, #SELMODE_NORMAL)
                Local cx, cy, r =  self.area.size.w/2, self.area.size.h/2, Min(self.area.size.w/2.2, self.area.size.h/2.2)
                SetFormStyle(#ANTIALIAS)
                Local p = HL.Value2Perc(self.Range, self.Private.Value)
                Local angle = p*360
                If bs1 <> 0
                  SetFillStyle(#FILLCOLOR)
                  Circle(cx+bs1, cy, r, b1d, { AnchorX = 0.5, AnchorY = 0.5 })
                  Circle(cx+bs1, cy+bs1, r, b1d, { AnchorX = 0.5, AnchorY = 0.5 })
                  Circle(cx-bs1, cy, r, b1l, { AnchorX = 0.5, AnchorY = 0.5 })
                  Circle(cx-bs1, cy-bs1, r, b1l, { AnchorX = 0.5, AnchorY = 0.5 })
                EndIf
                SetFillStyle(#FILLGRADIENT, #LINEAR, b1fa, b1fb, 45)
                Circle(cx, cy, r, $bbbbbb, { AnchorX = 0.5, AnchorY = 0.5 })
                ;Arc(cx, cy, r, r, 0, angle, col1, { AnchorX = 0.5, AnchorY = 0.5 })
                ;Arc(cx, cy, r, r, angle, 360, col2, { AnchorX = 0.5, AnchorY = 0.5 })

                If t = 1
                  Local s, c, r1 = Sin(Rad(angle))*r*.8, Cos(Rad(angle))*r*.8, r/8
                  If bs2 <> 0
                    SetFillStyle(#FILLCOLOR)
                    Circle(cx+s-bs2, cy+c, r1, b2d, { AnchorX = 0.5, AnchorY = 0.5 })
                    Circle(cx+s-bs2, cy+c-bs2, r1, b2d, { AnchorX = 0.5, AnchorY = 0.5 })
                    Circle(cx+s+bs2, cy+c, r1, b2l, { AnchorX = 0.5, AnchorY = 0.5 })
                    Circle(cx+s+bs2, cy+c+bs2, r1, b2l, { AnchorX = 0.5, AnchorY = 0.5 })
                  EndIf
                  SetFillStyle(#FILLGRADIENT, #LINEAR, b2fa, b2fb, 45)
                  Circle(cx+s, cy+c, r1, $555555, { AnchorX = 0.5, AnchorY = 0.5 })
                ElseIf t = 2
                  Local p1x, p1y, r1 = Sin(Rad(angle))*r*.8, Cos(Rad(angle))*r*.8, r/8
                  Local p2x, p2y, r1 = Sin(Rad(angle))*r*.4, Cos(Rad(angle))*r*.4, r/8
                  SetFormStyle(#ANTIALIAS)
                  If bs2 > 0
                    Line(cx+p1x-bs2, cy+p1y-bs2, cx+p2x-bs2, cy+p2y-bs2, b2d, { Thickness = r1 })
                    Line(cx+p1x+bs2, cy+p1y+bs2, cx+p2x+bs2, cy+p2y+bs2, b2l, { Thickness = r1 })
                  EndIf
                  Line(cx+p1x, cy+p1y, cx+p2x, cy+p2y, b2n, { Thickness = r1 })
                  SetFormStyle(#NORMAL)
                EndIf

                SetFormStyle(#NORMAL)
                SetFillStyle(#FILLCOLOR)
              GFX.OutputDevice.EndSelect()
            EndIf
          EndIf

      ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: RENDER TEXT ::
      Case #HGUI_TEXT_GADGET
         If self.usecache
            Local br = 0
            Switch self.Status
               Case #HGUI_NORMAL_STATE
                  br = self.private.cache.normal

               Case #HGUI_HILIGHTED_STATE
                  br = self.private.cache.hilight

               Case #HGUI_PUSHED_STATE
                  br = self.private.cache.pushed

               Case #HGUI_DISABLED_STATE
                  br = self.private.cache.disabled

               Default
                  DBG.Console.Out("Unrecognized text state <" .. self.status .. ">", DBG.Error, HGui.DebugChannel)

            EndSwitch

            Local px, py, args = self.area.position.x, self.area.position.y, {}

            DisplayBrush(br, px, py)
            If Not(partial) Then self.TextObj:Render()

         Else
            Local bg = {}
            If TB.Item.Exists(self, "background") Then bg = self.background
            If self.flags.visible = #HGUI_VISIBLE
               GFX.OutputDevice.Select(#DISPLAY, self.window.private.HWId)
               Local Area = { x = self.area.position.x, y = self.area.position.y, w = self.area.size.w, h = self.area.size.h }

               Local sk, br = 0, 0
               Switch self.Status
                  Case #HGUI_NORMAL_STATE
                     sk = self.look.nskin

                  Case #HGUI_HILIGHTED_STATE
                     sk = self.look.hskin

                  Case #HGUI_PUSHED_STATE
                     sk = self.look.pskin

                  Case #HGUI_DISABLED_STATE
                     sk = self.look.dskin

                  Default
                     DBG.Console.Out("Unrecognized text state <" .. self.status .. ">", DBG.Error, HGui.DebugChannel)

               EndSwitch

               GFX.Skin.Area(Area, sk, bg)
               self.TextObj.Area = { x = self.Area.Position.x, y = self.Area.Position.y,
                                     w = self.Area.Size.w,     h = self.Area.Size.h }
               self.TextObj:Render()

               GFX.OutputDevice.EndSelect()
            EndIf
         EndIf




      Default
         DBG.Console.Out("Unrecognized gadget type <" .. self.type .. ">.", DBG.Error, HGui.DebugChannel)
         ;DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
         Return(False)

   EndSwitch
   
  If self.isVirtualized
    SetClipRegion(#NONE)
    FreeClipRegion(clipArea)
  EndIf   

   GFX.OutputDevice.EndSelect()

   If TB.Item.Exists(self.childs, "gadgets") and SkipChilds = False
      Local CCount = TB.Count(self.Childs.gadgets)
      For Local i = 0 To CCount - 1
         self.childs.gadgets[i]:render()
      Next
   EndIf

   ;DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
   Return(True)

EndFunction

Function HGui.Gadget:set(options, redraw) ; *TriDoc*
/*-------------------------------------------------------------------
HGui.Gadget:set(options, redraw)

Set gadget's properties and optionally execute a refresh.
---------------------------------------------------------------------
INPUT
  options : A table with all properties you need to change, some properties depends on the gadget type, some are common to all gadgets, basically you can set any parameter supported by the creation method :new().
  redraw : TRUE to redraw the gadget and its children when done.
------------------------------------------------------------------*/
  DBG.Console.Out(".Gadget:set() -> " .. self.name, DBG.OpenFunc, HGui.DebugChannel)

  HGui.BeginRefresh(self.window)
  
  Local NewGad     = self
  Local Rebuild    = False
  Local AreaChange = False
  Local Position   = self.area.position
  Local Size       = self.area.size

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: CONTEXTUAL :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "contextual")
    NewGad.Contextual = options.contextual
  EndIf
  
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: SET POSITION :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "position")
    If TB.Item.Exists(options.position, "x")
      If position.x <> options.position.x
        position.x = options.position.x
        AreaChange = True
      EndIf
    EndIf
    If TB.Item.Exists(options.position, "y")
      If position.y <> options.position.y
        position.y = options.position.y
        AreaChange = True
      EndIf
    EndIf
  EndIf

  ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: SET SIZE ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "size")
    If TB.Item.Exists(options.size, "w")
      If size.w <> options.size.w
        If Int(options.size.w) > 0
          size.w = options.size.w
        Else
          size.w = 1
        EndIf
        Rebuild = True
        AreaChange = True
      EndIf
    EndIf
    If TB.Item.Exists(options.size, "h")
      If size.h <> options.size.h
        If Int(options.size.h) > 0
          size.h = options.size.h
        Else
          size.h = 1
        EndIf
        Rebuild = True
        AreaChange = True
      EndIf
    EndIf

    ; dimensioni minime per i cursori dello scroller
    If self.Private.IsCursor
      If self.Private.Father.Orientation = #HGUI_HORIZONTAL_LAYOUT
        If size.w < HGui.MinSBCursorSize Then size.w = HGui.MinSBCursorSize
      ElseIf self.Private.Father.Orientation = #HGUI_VERTICAL_LAYOUT
        If size.h < HGui.MinSBCursorSize Then size.h = HGui.MinSBCursorSize
      EndIf
    EndIf
  EndIf

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;:: SET LOOK ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "look")
    ;:: BORDERS ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    If TB.Item.Exists(options.look, "borders")
      If TB.Item.Exists(options.look.borders, "top"   ) Then NewGad.look.borders.top    = options.look.borders.top
      If TB.Item.Exists(options.look.borders, "bottom") Then NewGad.look.borders.bottom = options.look.borders.bottom
      If TB.Item.Exists(options.look.borders, "left"  ) Then NewGad.look.borders.left   = options.look.borders.left
      If TB.Item.Exists(options.look.borders, "right" ) Then NewGad.look.borders.right  = options.look.borders.right
    EndIf

    ;:: SKIN :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
; NEW
If TB.Item.Exists(options.look)
  Rebuild = True
  AreaChange = True
EndIf
    If TB.Item.Exists(options.look, "nskin" ) Then NewGad.look.nskin  = options.look.nskin
    If TB.Item.Exists(options.look, "hskin" ) Then NewGad.look.hskin  = options.look.hskin
    If TB.Item.Exists(options.look, "pskin" ) Then NewGad.look.pskin  = options.look.pskin
    If TB.Item.Exists(options.look, "dskin" ) Then NewGad.look.dskin  = options.look.dskin
    If TB.Item.Exists(options.look, "npskin") Then NewGad.look.npskin = options.look.npskin
    If TB.Item.Exists(options.look, "hpskin") Then NewGad.look.hpskin = options.look.hpskin
    If TB.Item.Exists(options.look, "dpskin") Then NewGad.look.dpskin = options.look.dpskin
    If TB.Item.Exists(options.look, "ntext" ) Then NewGad.look.ntext:set(options.look.ntext)
    If TB.Item.Exists(options.look, "htext" ) Then NewGad.look.htext:set(options.look.htext)
    If TB.Item.Exists(options.look, "ptext" ) Then NewGad.look.ptext:set(options.look.ptext)
    If TB.Item.Exists(options.look, "dtext" ) Then NewGad.look.dtext:set(options.look.dtext)
    If TB.Item.Exists(options.look, "nptext") Then NewGad.look.nptext:set(options.look.nptext)
    If TB.Item.Exists(options.look, "hptext") Then NewGad.look.hptext:set(options.look.hptext)
    If TB.Item.Exists(options.look, "dptext") Then NewGad.look.dptext:set(options.look.dptext)

    ;:: ICONS ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    If TB.Item.Exists(options.look, "icons")
      If TB.Item.Exists(options.look.icons, "iname" ) Then NewGad.look.icons.iname  = options.look.icons.iname
      If TB.Item.Exists(options.look.icons, "nname" ) Then NewGad.look.icons.nname  = options.look.icons.nname
      If TB.Item.Exists(options.look.icons, "hname" ) Then NewGad.look.icons.hname  = options.look.icons.hname
      If TB.Item.Exists(options.look.icons, "pname" ) Then NewGad.look.icons.pname  = options.look.icons.pname
      If TB.Item.Exists(options.look.icons, "dname" ) Then NewGad.look.icons.dname  = options.look.icons.dname
      If TB.Item.Exists(options.look.icons, "npname") Then NewGad.look.icons.npname = options.look.icons.npname
      If TB.Item.Exists(options.look.icons, "hpname") Then NewGad.look.icons.hpname = options.look.icons.hpname
      If TB.Item.Exists(options.look.icons, "dpname") Then NewGad.look.icons.dpname = options.look.icons.dpname
      If TB.Item.Exists(options.look.icons, "alignment") Then NewGad.look.icons.alignment = options.look.icons.alignment
      If TB.Item.Exists(options.look.icons, "gap"      ) Then NewGad.look.icons.gap       = options.look.icons.gap
      If TB.Item.Exists(options.look.icons, "adjtext"  ) Then NewGad.look.icons.adjtext   = options.look.icons.adjtext
      If TB.Item.Exists(NewGad.look.icons, "iname")
        NewGad.look.icons.nname  = NewGad.look.icons.iname
        NewGad.look.icons.hname  = NewGad.look.icons.iname
        NewGad.look.icons.pname  = NewGad.look.icons.iname
        NewGad.look.icons.dname  = NewGad.look.icons.iname
        NewGad.look.icons.npname = NewGad.look.icons.iname
        NewGad.look.icons.hpname = NewGad.look.icons.iname
        NewGad.look.icons.dpname = NewGad.look.icons.iname
      EndIf
    EndIf

    Rebuild = True
    AreaChange = True
  EndIf

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: SET CAPTION ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "caption")
    NewGad.caption = options.caption

    ;::: STANDARD GADGETS :::::::::::::::::::::::::::::::::::::::::::::::::::::
    Local Target = NewGad
    Local newCaption = NewGad.Caption

    ;::: SCROLLBAR ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    If NewGad.Type = #HGUI_SCROLLBAR_GADGET
      Local Target = NewGad.childs.gadgets[0].childs.gadgets[1]
      
      newCaption = NewGad.Caption
      If GetType(NewCaption) = #TABLE Then NewCaption = NewCaption[0]
      newCaption = ReplaceStr(newCaption, "{value}", NewGad.private.Value)
      newCaption = ReplaceStr(newCaption, "{value.##}", Int(NewGad.private.Value*100)/100)
      newCaption = ReplaceStr(newCaption, "{intvalue}", Int(NewGad.private.Value))
      newCaption = ReplaceStr(newCaption, "{rangestart}", NewGad.Range[0])
      newCaption = ReplaceStr(newCaption, "{rangeend}", NewGad.Range[1])
      

      Target:set({ caption = newCaption }, redraw)

    ;::: SET PROGRESSBAR ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ElseIf NewGad.Type = #HGUI_PROGRESSBAR_GADGET
      Target = NewGad.childs.gadgets[0].childs.gadgets[0]
      If NewGad.backText
        target = NewGad.childs.gadgets[0]
      EndIf
      
      newCaption = NewGad.Caption
      If GetType(NewCaption) = #TABLE Then NewCaption = NewCaption[0]

      Local perc = Int((NewGad.Private.Value-NewGad.Range[0]+1)/(NewGad.Range[1]-NewGad.Range[0]+1)*10000)/100
      newCaption = ReplaceStr(newCaption, "{value}", NewGad.private.Value)
      newCaption = ReplaceStr(newCaption, "{value.##}", Int(NewGad.private.Value*100)/100)
      newCaption = ReplaceStr(newCaption, "{intvalue}", Int(NewGad.private.Value))
      newCaption = ReplaceStr(newCaption, "{rangestart}", NewGad.Range[0])
      newCaption = ReplaceStr(newCaption, "{rangeend}", NewGad.Range[1])
      newCaption = ReplaceStr(newCaption, "{perc}", perc)
      Target:set({ caption = newCaption }, redraw)

    Else
      ;::: ALL THE OTHER ::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Local asp = { "ntext", "htext", "ptext", "dtext", "nptext", "hptext", "dptext" }
      For i, v In Pairs(asp)
        If TB.Item.Exists(Target.Look, v)
          If TB.Item.Exists(Target.Look[v], "set")
            Target.Look[v]:set({ caption = newCaption })
          EndIf
        EndIf
      Next
      /*
      If TB.Item.Exists(Target.Look, "ntext") Then Target.Look.nText:set({ caption = newCaption })
      If TB.Item.Exists(Target.Look, "htext") Then Target.Look.hText:set({ caption = newCaption })
      If TB.Item.Exists(Target.Look, "ptext") Then Target.Look.pText:set({ caption = newCaption })
      If TB.Item.Exists(Target.Look, "dtext") Then Target.Look.dText:set({ caption = newCaption })
      If TB.Item.Exists(Target.Look, "nptext") Then Target.Look.npText:set({ caption = newCaption })
      If TB.Item.Exists(Target.Look, "hptext") Then Target.Look.hpText:set({ caption = newCaption })
      If TB.Item.Exists(Target.Look, "dptext") Then Target.Look.dpText:set({ caption = newCaption })
      */
    EndIf

    Rebuild = True
  EndIf

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: SET TIP ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "tip") Then NewGad.tip     = options.tip

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: SET FLAGS ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "flags")
    If TB.Item.Exists(options.flags, "visible"  ) Then NewGad.flags.visible   = options.flags.visible
    If TB.Item.Exists(options.flags, "enabled"  ) Then NewGad.flags.enabled   = options.flags.enabled
    If TB.Item.Exists(options.flags, "draggable") Then NewGad.flags.draggable = options.flags.draggable
    Rebuild = True
  EndIf

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: SET SHORTCUT :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "shortcut")
      If TB.Item.Exists(options.shortcut, "qualifier") Then NewGad.shortcut.qualifier = options.shortcut.qualifier
      If TB.Item.Exists(options.shortcut, "key"      ) Then NewGad.shortcut.key       = options.shortcut.key
      If TB.Item.Exists(options.shortcut, "altcode"  ) Then NewGad.shortcut.AltCode   = options.shortcut.AltCode
      InsertItem(HGui.Shortcuts, { qualifier = NewGad.shortcut.qualifier,
                                   key       = NewGad.shortcut.key,
                                   altcode   = NewGad.shortcut.altcode,
                                   object    = NewGad })
   EndIf

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: SET CACHE ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "usecache")
    NewGad.usecache = options.usecache
    If NewGad.usecache
      Rebuild = True
    Else
      NewGad:cacheFree()
    EndIf
  EndIf

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: SET SOUNDS :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "sounds")
    If TB.Item.Exists(options.sounds, "onover"  ) Then NewGad.sounds.onover   = options.sounds.onover
    If TB.Item.Exists(options.sounds, "onpushed") Then NewGad.sounds.onpushed = options.sounds.onpushed
    If TB.Item.Exists(options.sounds, "ondown"  ) Then NewGad.sounds.ondown   = options.sounds.ondown
  EndIf

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: SET ACTIONS ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "actions")
    If TB.Item.Exists(options.actions, "onover"  ) Then NewGad.actions.onover   = options.actions.onover
    If TB.Item.Exists(options.actions, "onout"   ) Then NewGad.actions.onout    = options.actions.onout
    If TB.Item.Exists(options.actions, "onpushed") Then NewGad.actions.onpushed = options.actions.onpushed
    If TB.Item.Exists(options.actions, "ondown"  ) Then NewGad.actions.ondown   = options.actions.ondown
    If TB.Item.Exists(options.actions, "ondrop"  ) Then NewGad.actions.ondrop   = options.actions.ondrop
    If TB.Item.Exists(options.actions, "ondropout") Then NewGad.actions.ondropout = options.actions.ondropout
  EndIf

   /*
   If TB.Item.Exists(options, "window")
      Switch GetType(options.window)
         Case #STRING
            Local win = HGui.windowFindByName(options.window)
            If GetType(win) = #TABLE
               SelectDisplay(win.private.HWId, True)
               NewGad.window = win
            Else
               DBG.Console.Out("* HGui.window:new() -> the window <" .. options.window .. "> does not exists.")
               Return(False)
            EndIf

         Case #TABLE
            SelectDisplay(options.window.private.HWId, True)
            NewGad.window = options.window

         Default
            DBG.Console.Out("* HGui.window:new() -> specified <window> is not recognized.")
            Return(False)

      EndSwitch

   Else
      SelectDisplay(options.window.private.HWId)

   EndIf
   */

   ; If TB.Item.Exists(options, "background") Then NewGad.background = options.background


  ;****************************************************************************
  ;*********** G A D G E T   S P E C I F I C  P R O P E R T I E S *************
  ;****************************************************************************
  Switch NewGad.type
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: SET BOX ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_BOX_GADGET
      If AreaChange
        self.Area:set(Options)
        self:skinBordersUpdate(self.Look.nSkin)
      EndIf

      ; It's a Virtual Root?
      If self.Private.IsVirtualRoot
        ; VirtualSize
        If TB.Item.Exists(options, "virtualsize")
          If TB.Item.Exists(options.VirtualSize, "w")
            self.oldVSW = self.VirtualSize.w
            self.VirtualSize.w = options.VirtualSize.w
          Else
            DBG.Console.Out("MISSING VirtualSize W", DBG.Error, HGui.DebugChannel)
          EndIf
          If TB.Item.Exists(options.VirtualSize, "h")
            self.oldVSH = self.VirtualSize.h
            self.VirtualSize.h = options.VirtualSize.h
          Else
            DBG.Console.Out("MISSING VirtualSize H", DBG.Error, HGui.DebugChannel)
          EndIf
        Else
          DBG.Console.Out("MISSING VirtualSize table", DBG.Error, HGui.DebugChannel)
        EndIf
         
        ; VirtualOffset
        If TB.Item.Exists(options, "virtualoffset")
          If TB.Item.Exists(options.VirtualOffset, "x")
            self.VirtualOffset.x = options.VirtualOffset.x
          Else
            self.VirtualOffset.x = 0
          EndIf
          If TB.Item.Exists(options.VirtualOffset, "y")
            self.VirtualOffset.y = options.VirtualOffset.y
          Else
            self.VirtualOffset.y = 0
          EndIf
        EndIf


        ;*** MA QUEST' AREA:SET() SERVE? SEMBREREBBE DI NO. ***
        ;self.Area:set({ w = self.VirtualSize.w, h = self.VirtualSize.h }); recurse = False })

      EndIf

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: SET VDIVIDER :::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_VDIVIDER_GADGET
        If AreaChange
          self.Area:set(Options)
          self:skinBordersUpdate(self.Look.nSkin)
        EndIf

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: SET HDIVIDER :::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_HDIVIDER_GADGET
        If AreaChange
          self.Area:set(Options)
          self:skinBordersUpdate(self.Look.nSkin)
        EndIf

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: SET LABEL ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_LABEL_GADGET
        If AreaChange
          self.Area:set(Options)
          self:skinBordersUpdate(self.Look.nSkin)
        EndIf

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: SET CANVAS :::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_CANVAS_GADGET
        If AreaChange
          self.Area:set(Options)
        EndIf
        
        If TB.Item.Exists(options, "canvassize")
          self.CanvasSize = CopyTable(options.CanvasSize)
          self.Virtual:Set({ VirtualSize = options.CanvasSize }, False)
          self:ResizeLayers()
        EndIf
        
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: SET VIRTUAL ::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_VIRTUAL_GADGET
        self.VBox:set(options, False)        
        
        If AreaChange
          If self.HAutoSense
            self.VBox.VirtualSize.w = Size.w - self.VScroller.Area.Size.w
          EndIf
          If self.VAutoSense
            self.VBox.VirtualSize.h = Size.h - self.VScroller.Area.Size.h
          EndIf

          self.Area = HGui.Area:new({ position = position, size = size })          
        EndIf
      
        If AreaChange Or self.VBox.oldVSW <> self.VBox.VirtualSize.w
          self.VBox.oldVSW = self.VBox.VirtualSize.w
          ;self:Set({ position = position, size = size })
          If TB.Item.Exists(self, "hscroller")
            self.HScroller:set({ Value = self.VBox.VirtualOffset.x, Range = { 1, self.VBox.VirtualSize.w, self.VBox.Area.Size.w }}, False)
          EndIf
          self:layoutUpdate()
        EndIf

        If AreaChange Or self.VBox.oldVSH <> self.VBox.VirtualSize.h
          self.VBox.oldVSH = self.VBox.VirtualSize.h        
          If TB.Item.Exists(self, "vscroller")
            self.VScroller:set({ Value = self.VBox.VirtualOffset.y, Range = { 1, self.VBox.VirtualSize.h, self.VBox.Area.Size.h }}, False)
          EndIf
          self:layoutUpdate()
        EndIf

        ;self.HScroller:layoutUpdate()

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: SET GROUP ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_GROUP_GADGET
        ;::: HEADER :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        If TB.Item.Exists(options, "header")
          /*
          ; Retrieve the Header position
           Local OuterBox = self.childs.gadgets[0]
           Local header_pos = 0
           If self.Group_LabelSide = #HGUI_ALIGN_RIGHT Or self.Group_LabelSide = #HGUI_ALIGN_BOTTOM
              header_pos    = 1
           EndIf        
           Local Header = OuterBox.childs.gadgets[header_pos]
           */
          Local Header = self.Header
          Header:set(options.header)
          Rebuild = True
        EndIf

        ;::: OUTER BOX ::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        If TB.Item.Exists(options, "outer_box")
          ; self.childs.gadgets[0].look.nskin = options.outer_box
          self.OuterBox:set(options.Outer_Box)
          Rebuild = True
        EndIf

        ;::: INNER BOX ::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        If TB.Item.Exists(options, "inner_box")
          /*
           Local inner_box_pos = 1
           Local header_pos = 0
           If self.Group_LabelSide = #HGUI_ALIGN_RIGHT Or self.Group_LabelSide = #HGUI_ALIGN_BOTTOM
              inner_box_pos = 0
              header_pos = 1
           EndIf
           self.childs.gadgets[0].childs.gadgets[inner_box_pos].look.nskin = options.inner_box
           */
          self.InnerBox:set(options.Inner_Box)
          Rebuild = True
        EndIf

        If AreaChange
           NewGad.Area = HGui.Area:new({ position = position, size = size })
        EndIf

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: SET BUTTON :::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_BUTTON_GADGET        
        If AreaChange
          NewGad.Area:set({ position = position, size = size, offset = NewGad.Look.Offset })
          NewGad.look.ntext:set({ position = position, size = size })
          NewGad.look.htext:set({ position = position, size = size })
          NewGad.look.ptext:set({ position = position, size = size })
          NewGad.look.dtext:set({ position = position, size = size })
          self:skinBordersUpdate(self.look.nskin)
          self:skinBordersUpdate(self.look.hskin)
          self:skinBordersUpdate(self.look.pskin)
          self:skinBordersUpdate(self.look.dskin)
        EndIf

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: SET TEXT :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_TEXT_GADGET
        
        If AreaChange
          NewGad.Area:set({ position = position, size = size})
          ; If NewGad.UseCache
          ;    NewGad.TextObj:SetArea({ x = 1, y = 1, w = size.w-2, h = size.h-2 })
          ; Else
          Local border = 2 ; *** mettere nelle opzioni
          NewGad.TextObj:SetArea({ x = position.x+border, y = position.y+border, w = size.w-border*2, h = size.h-border*2 })
          ; EndIf
          self:skinBordersUpdate(self.look.nskin)
          self:skinBordersUpdate(self.look.hskin)
          self:skinBordersUpdate(self.look.pskin)
          self:skinBordersUpdate(self.look.dskin)
        EndIf

        If TB.Item.Exists(options, "textobj")
          self.TextObj:Set(options.TextObj)
          If redraw
            self.TextObj:Render()
          EndIf
          
          /*
          ; Generate an event if the contents are changed
          If TB.Item.Exists(options.textobj, "text")
            If TB.Item.Exists(self.Actions, "oninputend")
              self.Actions.OnInputEnd(self, self.TextObj.Text)
            EndIf
          EndIf
          */
          
        EndIf
        
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: SET SWITCH :::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_SWITCH_GADGET
        If AreaChange
          NewGad.Area:set({ position = position, size = size})
          NewGad.look.ntext:set({ position = position, size = size })
          NewGad.look.htext:set({ position = position, size = size })
          NewGad.look.ptext:set({ position = position, size = size })
          NewGad.look.dtext:set({ position = position, size = size })
          NewGad.look.nptext:set({ position = position, size = size })
          NewGad.look.hptext:set({ position = position, size = size })
          NewGad.look.dptext:set({ position = position, size = size })
          self:skinBordersUpdate(self.look.nskin)
          self:skinBordersUpdate(self.look.hskin)
          self:skinBordersUpdate(self.look.pskin)
          self:skinBordersUpdate(self.look.dskin)
          self:skinBordersUpdate(self.look.npskin)
          self:skinBordersUpdate(self.look.hpskin)
          self:skinBordersUpdate(self.look.dpskin)
        EndIf

        If TB.Item.Exists(options, "value")
          self.private.value = options.value
          If options.value = 1 And self.status = #HGUI_NORMAL_STATE
            self.status = #HGUI_NPUSHED_STATE
          ElseIf options.value = 1 And self.status = #HGUI_HILIGHTED_STATE
            self.status = #HGUI_HPUSHED_STATE
          ElseIf options.value = 0 And self.status = #HGUI_NPUSHED_STATE
            self.status = #HGUI_NORMAL_STATE
          ElseIf options.value = 0 And self.status = #HGUI_HPUSHED_STATE
            self.status = #HGUI_NPUSHED_STATE
          EndIf
        EndIf

    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: SET SCROLLBAR ::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_SCROLLBAR_GADGET
      Local changes = False
      Local OuterBox = self.childs.gadgets[0]
      Local Spacer = self.Spacer;self.childs.gadgets[0].childs.gadgets[0]
      Local Cursor = self.Cursor;self.childs.gadgets[0].childs.gadgets[1]
      Local GroupGadgets = { Spacer, Cursor }
      Local GroupMode = self.Orientation
      Local prevValue = self.private.Value

      ;::: OUTER BOX ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      If TB.Item.Exists(options, "outer_box")
        OuterBox:set(options.Outer_Box, False)
        Rebuild = True
        changes = True
      EndIf

      ;::: CURSOR :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      If TB.Item.Exists(options, "cursor")
        Cursor:set(options.Cursor, False)
        Rebuild = True
        changes = True
      EndIf

      
      ;::: RANGE ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      If TB.Item.Exists(options, "range")
        If TB.Item.Exists(options.Range, 0) Then self.Range[0] = options.Range[0]
        If TB.Item.Exists(options.Range, 1) Then self.Range[1] = options.Range[1]
        If TB.Item.Exists(options.Range, 2) Then self.Range[2] = options.Range[2]
        If self.Range[2] > self.Range[1]-self.Range[0]
          self.Range[2] = self.Range[1]-self.Range[0]
        EndIf
        changes = True

        If NewGad.Private.Value < NewGad.Range[0]
          NewGad.Private.Value = NewGad.Range[0]
        ElseIf NewGad.Private.Value > (NewGad.Range[1] - NewGad.Range[2] + 1)
          NewGad.Private.Value = (NewGad.Range[1] - NewGad.Range[2] + 1)
        EndIf
        
        Redraw = True
        Rebuild = True
        ;HGui.gadgetEvent_DragScrollbarCursor({x=0, y=0, Userdata=NewGad})
        ;Rebuild = True
      EndIf
      
      ;::: VALUE ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      If TB.Item.Exists(options, "value")
        If options.Value < NewGad.Range[0]
          options.Value = NewGad.Range[0]
        ElseIf options.Value > (NewGad.Range[1] - NewGad.Range[2])
          options.Value = (NewGad.Range[1] - NewGad.Range[2])
        EndIf

        If self.private.value <> options.value
          self.private.value = options.value
          self:set({ caption = self.Caption }, redraw)
          If TB.Item.Exists(self.actions, "onchange")
            self.Actions.OnChange(self, self.private.value, prevValue)
          EndIf
          Rebuild = False
        Else
          ;=== SPERIMENTALE : Aggiunto il 20/10/2016 per tentare di eliminare  ===
          ;===                il flickering quando non √® necessario un refresh ===
          ;===                perch√® non c'√® nulla da aggiornare.              ===
          ;=== Da un test preliminare sembra tutto ok.                         ===
          If Not(changes)
            Redraw = False ;Return()
          EndIf
        EndIf

        ; To resolve the problem of the minimum cursor size and the cursor that
        ; go outside the container I've used the borders so that the exceding part
        ; will be contained
        Local bottomB, rightB = 0, 0

        Local steps = NewGad.Range[1] - NewGad.Range[0]
        Local cursorWeight, spacerWeight
        If steps>0
          ; Calculate min cursor weight in percentual
          Local minCursorWeight = HGui.MinSBCursorSize/IIf(NewGad.Orientation=#HGUI_HORIZONTAL_LAYOUT, OuterBox.Area.Size.w, OuterBox.Area.Size.h)
          ; Calculate cursor weight in percentual
          cursorWeight = NewGad.Range[2] / steps
          
          ; Validate cursor size
          If cursorWeight < minCursorWeight
            ; Set the minimum size and adjust the border to contain the cursor
            ; inside the container
            cursorWeight = minCursorWeight
            If self.Orientation = #HGUI_HORIZONTAL_LAYOUT
              rightB = HGui.MinSBCursorSize/2
            Else
              bottomB = HGui.MinSBCursorSize/2
            EndIf
          EndIf
          spacerWeight = (NewGad.Private.Value - NewGad.Range[0]) / steps
        Else
          cursorWeight = 1
          spacerWeight = 0
        EndIf

        OuterBox:layoutSet({ gadgets = GroupGadgets,
                             weights = { spacerWeight, cursorWeight },
                             gap = 0,
                             type = GroupMode,
                             borders = { top = 0, bottom = bottomB, left = 0, right = rightB }}, True)
        ; Rebuild = False

        ;--- va dentro l'if fino a qua ? ---

      EndIf


      
      If AreaChange
        NewGad.Area = HGui.Area:new({ position = position, size = size })
      EndIf

    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: SET SLIDER :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_SLIDER_GADGET
      Local OuterBox = self.childs.gadgets[0]
      Local Spacer   = self.childs.gadgets[0].childs.gadgets[0]
      Local Cursor   = self.childs.gadgets[0].childs.gadgets[1]
      Local GroupGadgets = { Spacer, Cursor }
      Local GroupMode    = self.Orientation
      Local prevValue = self.private.Value

      ;::: OUTER BOX ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      If TB.Item.Exists(options, "outer_box")
        OuterBox:set(options.Outer_Box, False)
        Rebuild = True
      EndIf

      ;::: CURSOR :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      If TB.Item.Exists(options, "cursor")
        Cursor:set(options.Cursor, False)
        Rebuild = True
      EndIf

      ;::: RANGE ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      If TB.Item.Exists(options, "range")
        If TB.Item.Exists(options.Range, 0) Then self.Range[0] = options.Range[0]
        If TB.Item.Exists(options.Range, 1) Then self.Range[1] = options.Range[1]

        If NewGad.Private.Value < NewGad.Range[0]
          NewGad.Private.Value = NewGad.Range[0]
        ElseIf NewGad.Private.Value > (NewGad.Range[1] - NewGad.Range[0] + 1)
          NewGad.Private.Value = (NewGad.Range[1] - NewGad.Range[0] + 1)
        EndIf

        ;HGui.gadgetEvent_DragScrollbarCursor({x=0, y=0, Userdata=NewGad})
        ;Rebuild = True
      EndIf
      
      ;::: VALUE ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      If TB.Item.Exists(options, "value")
        If options.Value < NewGad.Range[0]
          options.Value = NewGad.Range[0]
        ElseIf options.Value > NewGad.Range[1]
          options.Value = NewGad.Range[1]
        EndIf

        If self.private.value <> options.value
          self.private.value = options.value
          If TB.Item.Exists(self.actions, "onchange")
            self.Actions.OnChange(self, self.private.value)
          EndIf
          Rebuild = False
        EndIf

        ;Local cursorValue    = (NewGad.Range[1] - NewGad.Range[0]+1)*NewGad.CursorWeight
        Local steps          = NewGad.Range[1] - NewGad.Range[0]
        Local cursorWeight   = NewGad.CursorWeight
        Local spacerWeight   = HL.Value2Perc({ Newgad.Range[0],
                                               NewGad.Range[1] },
                                               NewGad.Private.Value)*(1-cursorWeight) ;(NewGad.Private.Value - NewGad.Range[0]) / steps

        OuterBox:layoutSet({ gadgets = GroupGadgets,
                             weights = { spacerWeight, cursorWeight },
                             gap = 0,
                             type = GroupMode,
                             borders = { top = 0, bottom = 0, left = 0, right = 0 }}, True)
        ; Rebuild = False
        ;--- va dentro l'if fino a qua ? ---
      EndIf

      If AreaChange
        NewGad.Area = HGui.Area:new({ position = position, size = size })
      EndIf

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: SET PROGRESSBAR ::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_PROGRESSBAR_GADGET
        Local OuterBox = self.childs.gadgets[0]
        Local Cursor   = self.childs.gadgets[0].childs.gadgets[0]
        Local GroupGadgets = { Cursor }

      ;::: OUTER BOX ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      If TB.Item.Exists(options, "outer_box")
        ;Rebuild = True
      EndIf

      ;::: CURSOR :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      If TB.Item.Exists(options, "cursor")
        ;Rebuild = True
      EndIf

      ;::: RANGE ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ; Even if the gadget is built using a range table it can be modified
      ; using the values 'valuemax' and 'valuemin'
      If TB.Item.Exists(options, "valuemin") Then NewGad.Range[0] = options.valueMin
      If TB.Item.Exists(options, "valuemax") Then NewGad.Range[1] = options.valueMax

      ;::: VALUE ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ; Compute real values
      If TB.Item.Exists(options, "value")
        If options.Value < NewGad.Range[0]
          options.Value = NewGad.Range[0]
        ElseIf options.Value > NewGad.Range[1]
          options.Value = NewGad.Range[1]
        EndIf

        If self.private.value <> options.value
          self.private.value = options.value
          self:set({ caption = self.Caption }, redraw)
          Rebuild = False
        EndIf
      EndIf

      ; 12/02/2015 - Corretta la riga qua sotto aggiungendo +1
      Local steps          = NewGad.Range[1] - NewGad.Range[0] + 1
      Local cursorWeight = 1

      If steps <> 0 Then cursorWeight = (self.private.value-NewGad.Range[0]+1) / steps
      
      If cursorWeight > 1 Then cursorWeight = 1
      OuterBox:layoutSet({ gadgets = GroupGadgets,
                           weights = { cursorWeight },
                           gap = 0,
                           type = #HGUI_HORIZONTAL_LAYOUT,
                           borders = { top = 1, bottom = 1, left = 1, right = 1 }}, True)
      ; Rebuild = False

      ;--- va dentro l'if fino a qua ? ---

      If AreaChange
        NewGad.Area = HGui.Area:new({ position = position, size = size })
      EndIf

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: SET LISTVIEW :::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_LISTVIEW_GADGET
        /* set data
           - ColumnSizes
           - Headers
           - Items
           - Selected
           ---> campi speciali
                - insert = { { items da aggiungere } }, index = posizione (vedi come fa HW)
                - remove = { <index> }, anche qua vedi come fa HW
        */

        ;::: DATA :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        If TB.Item.Exists(options, "data")
          ;::: Column Sizes :::::::::::::::::::::::::::::::::::::::::::::::::::
          If TB.Item.Exists(options.data, "columnsizes")
            Local count = ListItems(NewGad.Data.ColumnSizes)
            Local changed = False
            For Local i = 0 To count-1
              If TB.Item.Exists(Options.Data.ColumnSizes, i)
                If Int(NewGad.Data.ColumnSizes[i]) <> Int(options.Data.ColumnSizes[i])
                  Changed = True
                  NewGad.Data.ColumnSizes[i] = options.Data.ColumnSizes[i]
                EndIf
              EndIf
            Next
            If changed
              NewGad.TopBox:layoutSet({ gadgets = NewGad.Headers,
                                        weights = NewGad.Data.ColumnSizes,
                                        gap     = NewGad.ColumnsGap,
                                        type    = #HGUI_HORIZONTAL_LAYOUT,
                                        borders = NewGad.ColumnsBorders })
              NewGad.TopBox:layoutUpdate(True)
            EndIf
          EndIf
          
          ;::: Headers ::::::::::::::::::::::::::::::::::::::::::::::::::::::::
          If TB.Item.Exists(options.data, "headers")
            Local count = ListItems(NewGad.Data.Headers)
            For Local i = 0 To count-1
              If TB.Item.Exists(Options.Data.Headers, i)
                If NewGad.Data.Headers[i] <> options.Data.Headers[i]
                  NewGad.Data.Headers[i] = options.Data.Headers[i]
                  NewGad.Headers[i]:set({ caption = { NewGad.Data.Headers[i] } }, True)
                EndIf
              EndIf
            Next
          EndIf
          
          ;::: Items ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
          If TB.Item.Exists(options.data, "items")
            NewGad.Data.Items = options.Data.Items
            NewGad.data.selected = {}
            Local count = ListItems(NewGad.data.Items)
            For Local i = 0 To count-1 Do NewGad.data.selected[i] = False
          EndIf
          
          ;::: Insert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::
          If TB.Item.Exists(options.data, "insert")
            Local to_insert = ListItems(options.data.insert)
            For Local i = 0 To to_insert-1
              InsertItem(NewGad.Data.Items, Options.Data.Insert[i].Item, Options.Data.Insert[i].Index)
              InsertItem(NewGad.Data.Selected, False, Options.Data.Insert[i].Index)
            Next
          EndIf
          
          ;::: Remove :::::::::::::::::::::::::::::::::::::::::::::::::::::::::
          If TB.Item.Exists(options.data, "remove")
            Local to_remove = ListItems(options.data.remove)
            For Local i = 0 To to_remove-1
              RemoveItem(NewGad.Data.Items, Options.Data.Remove[i])
              RemoveItem(NewGad.Data.Selected, Options.Data.Remove[i])
            Next
          EndIf

          ;::: Selected :::::::::::::::::::::::::::::::::::::::::::::::::::::::
          If TB.Item.Exists(options.data, "selected")
          
            Switch GetType(options.data.selected)
              Case #TABLE
                For i, v In Pairs(options.data.selected)
                  NewGad.Data.Selected[i] = v
                Next

              Case #NUMBER
              
                If options.data.selected = #NONE
                  ; SELECTED : NONE
                  Local t = ListItems(NewGad.Data.Selected)
                  For Local i = 0 To t-1
                    NewGad.Data.Selected[i] = False
                  Next
                
                ElseIf options.data.selected = #ALL
                  ; SELECTED : ALL
                  Local t = ListItems(NewGad.Data.Selected)
                  For i = 0 To t-1
                    NewGad.Data.Selected[i] = True
                  Next
                
                Else
                
                  ; SELECTED : ADD THE SPECIFIED ITEM
                  ; If not multiselect clear previous selection
                  If Not(NewGad.Multiselect)
                    Local t = ListItems(NewGad.Data.Selected)
                    For Local i = 0 To t-1
                      NewGad.Data.Selected[i] = False
                    Next
                  EndIf
                EndIf
                
                NewGad.Data.Selected[options.data.selected] = True
                ; Se esiste triggera l'evento di selezione
                If TB.Item.Exists(NewGad, "onselect")
                  NewGad.OnSelect(NewGad, NewGad.Data.Items, NewGad.Data.Selected, options.data.selected)
                EndIf
                
              Default

            EndSwitch
          EndIf
         
        EndIf
        
        ;::: MULTISELECT :::
        If TB.Item.Exists(options, "multiselect")
          If NewGad.Multiselect And options.Multiselect = False
            ; Reset previous selections without rendering
            NewGad:UnselectAll(False)
            ; Attivo l'ultimo item attivato (se esiste)
            If TB.Item.Exists(NewGad.Data, "lastselected")
              NewGad:Set({ data = { selected = NewGad.Data.LastSelected } }, False)
            EndIf
          EndIf
          NewGad.Multiselect = Options.Multiselect
        EndIf

        If AreaChange
          NewGad.Area = HGui.Area:new({ position = position, size = size })
          NewGad:Set({ position = position, size = size })
          If NewGad._firstBuild
            ; Viene eseguito solo la prima volta quando si adatta alla finestra
            ; Questo perch√® quando il listview viene assemblato le dimensioni
            ; del contenitore sono quelle di default e non quelle della fiunestra
            ; e questo comporta che le dimensioni vengano adattate alla nuova misura
            ; al primo resize dovuto all'adattamento del layout.
            NewGad:rebuildLayout()
            NewGad:layoutUpdate(True)
            NewGad._firstBuild = False            
          EndIf            

        EndIf

        ; HScroller si autoimposta
        If Not(self.HScrollerOFF)
          Local totalSize = 0
          For i, v In IPairs(self.Headers)
            totalSize = totalSize + v.Area.Size.w
          Next
          self.HScroller:set({ Value = self.HScroller.Private.Value, Range = { 1, totalSize, self.TopBox.Area.Size.w }}, False)
        EndIf
        
        ; VScroller si autoimposta
        If Not(self.VScrollerOFF)
          Local totalItems = ListItems(self.Data.Items)
          Local totalVisible = Int(self.ListArea.Area.Size.h/self.EntryHeight)

          self.VScroller:set({ Value = self.VScroller.Private.Value, Range = { 0, totalItems-1, totalVisible-1 }}, False)
        EndIf
        
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: SET DROPDOWN :::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_DROPDOWN_GADGET
      
        

/*       
      ;--- DATA ---
      If TB.Item.Exists(options, "data")
         ;--- ColumnSizes ---
         If TB.Item.Exists(options.data, "columnsizes")
            Local count = ListItems(NewGad.Data.ColumnSizes)
            Local changed = False
            For Local i = 0 To count-1
               If TB.Item.Exists(Options.Data.ColumnSizes, i)
                  If Int(NewGad.Data.ColumnSizes[i]) <> Int(options.Data.ColumnSizes[i])
                     Changed = True
                     NewGad.Data.ColumnSizes[i] = options.Data.ColumnSizes[i]
                  EndIf
               EndIf
            Next
            If changed
               NewGad.TopBox:layoutSet({ gadgets = NewGad.Headers,
                                         weights = NewGad.Data.ColumnSizes,
                                         gap     = NewGad.ColumnsGap,
                                         type    = #HGUI_HORIZONTAL_LAYOUT,
                                         borders = NewGad.ColumnsBorders })
               NewGad.TopBox:layoutUpdate(True)
            EndIf
         EndIf
         ;--- Headers ---
         If TB.Item.Exists(options.data, "headers")
            Local count = ListItems(NewGad.Data.Headers)
            For Local i = 0 To count-1
               If TB.Item.Exists(Options.Data.Headers, i)
                  If NewGad.Data.Headers[i] <> options.Data.Headers[i]
                     NewGad.Data.Headers[i] = options.Data.Headers[i]
                     NewGad.Headers[i]:set({ caption = { NewGad.Data.Headers[i] } }, True)
                  EndIf
               EndIf
            Next
         EndIf
         ;--- Items ---
         If TB.Item.Exists(options.data, "insert")
            Local to_insert = ListItems(options.data.insert)
            For Local i = 0 To to_insert-1
               InsertItem(NewGad.Data.Items, Options.Data.Insert[i].Item, Options.Data.Insert[i].Index)
               InsertItem(NewGad.Data.Selected, False, Options.Data.Insert[i].Index)
            Next
         EndIf
         If TB.Item.Exists(options.data, "remove")
            Local to_remove = ListItems(options.data.remove)
            For Local i = 0 To to_remove-1
               RemoveItem(NewGad.Data.Items, Options.Data.Remove[i])
               RemoveItem(NewGad.Data.Selected, Options.Data.Remove[i])
            Next
         EndIf
      EndIf
*/
      /* set data
         - ColumnSizes
         - Headers
         - Items
         - Selected
         ---> campi speciali
              - insert = { { items da aggiungere } }, index = posizione (vedi come fa HW)
              - remove = { <index> }, anche qua vedi come fa HW
      */

      If AreaChange
         NewGad.Area = HGui.Area:new({ position = position, size = size })
         ;self:Set({ position = position, size = size })
         NewGad:layoutUpdate()
      EndIf
/*
      ; HScroller si autoimposta
      Local totalSize = 0
      For i, v In IPairs(self.Headers)
         totalSize = totalSize + v.Area.Size.w
      Next

      self.HScroller:set({ Value = self.HScroller.Private.Value, Range = { 1, totalSize, self.TopBox.Area.Size.w }}, False)

      ; VScroller si autoimposta
      Local totalItems = ListItems(self.Data.Items)
      Local totalVisible = Int(self.ListArea.Area.Size.h/self.EntryHeight)

      self.VScroller:set({ Value = self.VScroller.Private.Value, Range = { 0, totalItems-1, totalVisible-1 }}, False)
*/
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: SET IMAGE ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_IMAGE_GADGET
        If TB.Item.Exists(options, "source")
          NewGad.Source = Options.Source
          NewGad.Container:cacheFree()
          NewGad.Container:cacheBuild()
        EndIf
        
        If AreaChange
          NewGad.Area = HGui.Area:new({ position = position, size = size })
          ;self:Set({ position = position, size = size })
          NewGad:layoutUpdate()
        EndIf

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: SET KNOB :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_KNOB_GADGET
        ;::: VALUE ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        If TB.Item.Exists(options, "value")
          If options.Value < NewGad.Range[0]
            options.Value = NewGad.Range[0]
          ElseIf options.Value > NewGad.Range[1]
            options.Value = NewGad.Range[1]
          EndIf

          If self.private.value <> options.value
            self.private.value = options.value
            Rebuild = True
          EndIf
        EndIf

        ;::: CURSOR RADIUS ::::::::::::::::::::::::::::::::::::::::::::::::::::
        If TB.Item.Exists(options, "cursorradius")
          NewGad.CursorRadius = Options.CursorRadius
          Rebuild = True
        EndIf

        If AreaChange
          NewGad.Area = HGui.Area:new({ position = position, size = size, active = True, window = NewGad.window,
                                        events = { onmousedown = HGui.gadgetEvent_LMBDown,
                                                   onmouseup   = HGui.gadgetEvent_LMBUp,
                                                   onrightmouseup = HGui.gadgetEvent_RMBUp,
                                                   onmouseover = HGui.gadgetEvent_Over,
                                                   onmouseout  = HGui.gadgetEvent_Out } }, NewGad, UserData)

        EndIf

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: SET TREEVIEW :::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_TREEVIEW_GADGET
        ;::: DATA :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        If TB.Item.Exists(options, "data")
          ;::: ColumnSizes ::::::::::::::::::::::::::::::::::::::::::::::::::::
          If TB.Item.Exists(options.data, "columnsizes")
            Local count = ListItems(NewGad.Data.ColumnSizes)
            Local changed = False
            For Local i = 0 To count-1
              If TB.Item.Exists(Options.Data.ColumnSizes, i)
                If Int(NewGad.Data.ColumnSizes[i]) <> Int(options.Data.ColumnSizes[i])
                  Changed = True
                  NewGad.Data.ColumnSizes[i] = options.Data.ColumnSizes[i]
                EndIf
              EndIf
            Next
            If changed
              NewGad.TopBox:layoutSet({ gadgets = NewGad.Headers,
                                        weights = NewGad.Data.ColumnSizes,
                                        gap     = NewGad.ColumnsGap,
                                        type    = #HGUI_HORIZONTAL_LAYOUT,
                                        borders = NewGad.ColumnsBorders })
              NewGad.TopBox:layoutUpdate(True)
            EndIf
          EndIf

          ;::: Headers ::::::::::::::::::::::::::::::::::::::::::::::::::::::::
          If TB.Item.Exists(options.data, "headers")
            Local count = ListItems(NewGad.Data.Headers)
            For Local i = 0 To count-1
              If TB.Item.Exists(Options.Data.Headers, i)
                If NewGad.Data.Headers[i] <> options.Data.Headers[i]
                  NewGad.Data.Headers[i] = options.Data.Headers[i]
                  NewGad.Headers[i]:set({ caption = { NewGad.Data.Headers[i] } }, True)
                EndIf
              EndIf
            Next
          EndIf

          ;::: Items ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
          If TB.Item.Exists(options.data, "items")
            NewGad.Data.Items = CopyTable(options.data.items)
            NewGad.Data.realItems = HGui.treeView_ElaborateList(NewGad.Data.Items)

            ; This is needed to update the vertical scroller
            Local totalItems = ListItems(NewGad.Data.realItems)
            Local totalVisible = Int(NewGad.ListArea.Area.Size.h/NewGad.EntryHeight)
            NewGad.VScroller:set({ Value = NewGad.VScroller.Private.Value, Range = { 0, totalItems-1, totalVisible-1 }}, True)

          EndIf
          
          ;::: Insert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::
          ;::: Valid only for the first level
          If TB.Item.Exists(options.data, "insert")
            Local to_insert = ListItems(options.data.insert)
            For Local i = 0 To to_insert-1
              InsertItem(NewGad.Data.Items, Options.Data.Insert[i].Item, Options.Data.Insert[i].Index)
            Next
            NewGad.Data.realItems = HGui.treeView_ElaborateList(NewGad.Data.Items)
          EndIf
          
          ;::: Remove :::::::::::::::::::::::::::::::::::::::::::::::::::::::::
          ;::: Valid only for the first level
          If TB.Item.Exists(options.data, "remove")
            Local to_remove = ListItems(options.data.remove)
            For Local i = 0 To to_remove-1
              RemoveItem(NewGad.Data.Items, Options.Data.Remove[i])
            Next
            NewGad.Data.realItems = HGui.treeView_ElaborateList(NewGad.Data.Items)
          EndIf
        EndIf

        If AreaChange
          NewGad.Area = HGui.Area:new({ position = position, size = size })
          ;self:Set({ position = position, size = size })
          NewGad:layoutUpdate()
        EndIf

        ; HScroller si autoimposta
        Local totalSize = 0
        For i, v In IPairs(self.Headers)
          totalSize = totalSize + v.Area.Size.w
        Next

        self.HScroller:set({ Value = self.HScroller.Private.Value, Range = { 1, totalSize, self.TopBox.Area.Size.w }}, False)

        ; VScroller si autoimposta
        Local totalItems = ListItems(self.Data.realItems)
        Local totalVisible = Int(self.ListArea.Area.Size.h/self.EntryHeight)

        self.VScroller:set({ Value = self.VScroller.Private.Value, Range = { 0, totalItems-1, totalVisible-1 }}, False)

      ;--- DUPLICATED SECTION --- MUST BE CHECKED ---
      ;::: SET KNOB :::
      ;--- DUPLICATED SECTION --- MUST BE CHECKED ---
      Case #HGUI_KNOB_GADGET

        If TB.Item.Exists(options, "value")
           ;                                                           :: VALUE ::
           If options.Value < NewGad.Range[0]
              options.Value = NewGad.Range[0]
           ElseIf options.Value > NewGad.Range[1]
              options.Value = NewGad.Range[1]
           EndIf

           If self.private.value <> options.value
              self.private.value = options.value
              Rebuild = True
           EndIf
        EndIf

        If TB.Item.Exists(options, "cursorradius")
           NewGad.CursorRadius = Options.CursorRadius
           Rebuild = True
        EndIf

        If AreaChange
           NewGad.Area = HGui.Area:new({ position = position, size = size, active = True, window = NewGad.window,
                                         events = { onmousedown = HGui.gadgetEvent_LMBDown,
                                                    onmouseup   = HGui.gadgetEvent_LMBUp,
                                                    onrightmouseup = HGui.gadgetEvent_RMBUp,
                                                    onmouseover = HGui.gadgetEvent_Over,
                                                    onmouseout  = HGui.gadgetEvent_Out } }, NewGad, UserData)

        EndIf

      ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Default
        DBG.Console.Out("Unrecognized gadget type <" .. NewGad.type .. ">.", DBG.Error, HGui.DebugChannel)
        DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
        Return(False)

    EndSwitch


   /*
   If NewGad.Background
      If NewGad.UseCache
         NewGad.background = { Type = GFX.SkinBGType_Private,
                               BGStruct = { Brush = Nil, X = NewGad.area.Position.x, Y = NewGad.area.Position.y, W = NewGad.area.Size.w, H = NewGad.area.Size.h },
                               Offset = { x = 0, y = 0, w = 0, h = 0 } }
      Else
         NewGad.background = { Type = GFX.SkinBGType_Private,
                               BGStruct = { Brush = Nil, X = NewGad.area.Position.x, Y = NewGad.area.Position.y, W = NewGad.area.Size.w, H = NewGad.area.Size.h },
                               Offset = { x = 0, y = 0, w = 0, h = 0 } }
      EndIf
   Else
      NewGad.Background = Nil
   EndIf
   */

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: STATUS :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "status") Then NewGad.status = options.status

   
   ; UNCOMMENTED ON 16/08/2017
   If NewGad.area.active
      If(NewGad.flags.enabled = #HGUI_DISABLED Or NewGad.flags.visible = #HGUI_HIDDEN)
        SelectDisplay(NewGad.Area.Window.private.HWId, True)
        DisableButton(NewGad.area.private.button)
        If NewGad.flags.enabled = #HGUI_DISABLED
          options.Status = #HGUI_DISABLED_STATE
        EndIf
      Else
        If TB.Item.Exists(NewGad.area.private, "button")
          If GetType(NewGad.area.private.button) <> #NUMBER
            SelectDisplay(NewGad.Area.Window.private.HWId, True)
            EnableButton(NewGad.area.private.button)
          EndIf
        EndIf
        
      EndIf
   EndIf
   ; -------------------------

   
  ; Update the layout
  NewGad:layoutUpdate()

  ; If needed rebuild the cache
  If NewGad.usecache
    If Rebuild
      NewGad:cacheBuild()
    EndIf
  EndIf

  ; Check if auto-rendering is set
  If HGui.AutoRendering
    If Redraw
      If NewGad.Type <> #HGUI_VIRTUAL_GADGET
        ; 29/10/2018 : Added the 3rd parameter 'Quiet=True' to avoid
        ; auto window activation caused by a rendering.
        NewGad:render(Nil, Nil, True)

      Else
        NewGad.VBox:render()
        
      EndIf

    EndIf
  EndIf

  HGui.EndRefresh(self.window)
  
  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
  Return(NewGad)

EndFunction

Function HGui.Gadget:freeChildren(refresh) ; *TriDoc*
/*-------------------------------------------------------------------
result = HGui.Gadget:freeChildren(refresh)

Free all children attached to this gadget.
---------------------------------------------------------------------
INPUT
  refresh : TRUE to redraw the window's contents.

OUTPUT
  result : TRUE if the operation completed without errors.  
------------------------------------------------------------------*/
  DBG.Console.Out(".Gadget:freeChildren() -> " .. self.name, DBG.OpenFunc, HGui.DebugChannel)

  If self.IsKilled
    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
    Return(False)
  EndIf

  If HL.IsNil(refresh) Then refresh = False

  If TB.Item.Exists(self, "childs")
    If TB.Item.Exists(self.childs, "gadgets")
      Local i, v = NextItem(self.childs.gadgets)
      While GetType(i) <> #NIL
        v.Parent = Nil
        v:free(False)
        i, v = NextItem(self.childs.gadgets, i)
      Wend
    EndIf
  EndIf
  
  If refresh Then self:Render()
  
  ; self.childs = Nil
  
  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)

EndFunction

Function HGui.Gadget:free(refresh) ; *TriDoc*
/*-------------------------------------------------------------------
result = HGui.Gadget:free(refresh)

Free the gadget and its resources.
---------------------------------------------------------------------
INPUT
  refresh : TRUE to redraw the window's contents.

OUTPUT
  result : TRUE if the object was removed without errors.
------------------------------------------------------------------*/
  DBG.Console.Out(".Gadget:free() -> " .. self.name, DBG.OpenFunc, HGui.DebugChannel)

  If self.IsKilled
    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
    Return(False)
  EndIf
  
  If IsNil(refresh) Then refresh = False

  ; Remove this gadget from the parent layout
  If TB.Item.Exists(self, "parent")
    Local Parent = self.Parent
    Local GadPos = -1
      
    ; ho dovuto mettere questo controllo per il drop down che non ha child (controllare bene)
    If TB.Item.Exists(Parent, "childs")
      Local i, v = NextItem(Parent.Childs.Gadgets)
      While GetType(i) <> #NIL
        If v = self
          GadPos = i
          Break()
        EndIf
        i, v = NextItem(Parent.Childs.Gadgets, i)
      Wend
    EndIf
      
    If GadPos <> -1
      ; Qua si potrebbe espandere il codice per far occupare lo spazio ai
      ; rimanenti gadget, inoltre si potrebbe verificare che se non ci
      ; sono pi√π childs si possa eliminare la struttura di definizione
      RemoveItem(Parent.Childs.Gadgets, GadPos)
      RemoveItem(Parent.Childs.Weights, GadPos)
      Parent:layoutSet(Parent.childs.options, True)
    Else
      DBG.Console.Out("Gadget not found in its parent <" .. Parent.Name .. "> gadget.", DBG.Warning, HGui.DebugChannel)

    EndIf

  EndIf

  If TB.Item.Exists(self, "textobj")
    ; E' necessario eliminare la funzione di rendering
    ; altrimenti se esco da una callback che mi chiude
    ; il gadget questo verr√† renderizzato comunque
    ; un'ultima volta.
    self.textObj.Render = Function() EndFunction
    self.textObj:UnActivate()
  EndIf
  
  ; Remove this gadget cache
  Local i, v = NextItem(self.Private.Cache)
  While GetType(i) <> #NIL
    FreeBrush(v)
    i, v = NextItem(self.Private.Cache, i)
    self.private.cache[i] = Nil
  Wend

  ; CANVAS
  If self.Type = #HGUI_CANVAS_GADGET
    For i, v In Pairs(self.Layers) Do FreeBrush(v)
  EndIf

  ; ACTIVE GADGET?
  If TB.Item.Exists(HGui, "activegadget")
    If HGui.ActiveGadget = self
      DBG.Console.Out("Removing an active gadget...", DBG.Warning, HGui.DebugChannel)
      HGui.ActiveGadget = Nil
    EndIf
  EndIf
  
   /*
   ; Remove Background cache
   If TB.Item.Exists(self, "background")
      If TB.Item.Exists(self.background.BGStruct, "brush")
         FreeBrush(self.background.BGStruct.Brush)
      EndIf
   EndIf
   */

  ; Remove all CTexts
  If TB.Item.Exists(self, "look")
    If TB.Item.Exists(self.look, "ntext" ) And TB.Item.Exists(self.look.ntext, "free")
      If GetType(self.look.ntext.free) = #FUNCTION Then self.look.ntext:free()
    EndIf
    If TB.Item.Exists(self.look, "htext" ) And TB.Item.Exists(self.look.htext, "free")
      If GetType(self.look.htext.free) = #FUNCTION Then self.look.htext:free()
    EndIf
    If TB.Item.Exists(self.look, "ptext" ) And TB.Item.Exists(self.look.ptext, "free")
      If GetType(self.look.ptext.free) = #FUNCTION Then self.look.ptext:free()
    EndIf
    If TB.Item.Exists(self.look, "dtext" ) And TB.Item.Exists(self.look.dtext, "free")
      If GetType(self.look.dtext.free) = #FUNCTION Then self.look.dtext:free()
    EndIf
    If TB.Item.Exists(self.look, "nptext") And TB.Item.Exists(self.look.nptext, "free")
      If GetType(self.look.nptext.free) = #FUNCTION Then self.look.nptext:free()
    EndIf
    If TB.Item.Exists(self.look, "hptext") And TB.Item.Exists(self.look.hptext, "free")
      If GetType(self.look.hptext.free) = #FUNCTION Then self.look.hptext:free()
    EndIf
    If TB.Item.Exists(self.look, "dptext") And TB.Item.Exists(self.look.dptext, "free")
      If GetType(self.look.dptext.free) = #FUNCTION Then self.look.dptext:free()
    EndIf
    self.look = Nil
  EndIf
   
  ; Remove Area
  If TB.Item.Exists(self, "area")
    self.Area:free()
    self.Area = Nil
  EndIf
   
  ; Remove all childs
  If TB.Item.Exists(self, "childs")
    If TB.Item.Exists(self.childs, "gadgets")
      Local i, v = NextItem(self.childs.gadgets)
      While GetType(i) <> #NIL
        v.Parent = Nil
        v:free(False)
        i, v = NextItem(self.childs.gadgets, i)
      Wend
    EndIf
  EndIf
  self.childs = Nil

  ; Remove from the gadget list
  Local s, i = HGui.gadgetFindByName(self.name)
  If GetType(s) = #TABLE
    RemoveItem(HGui.Gadgets, i)
  Else
    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
    Return(False)
  EndIf

  ; Removing shortcut
  Local i, v = NextItem(HGui.Shortcuts)
  While GetType(i) <> #NIL
    If v.Object = self
      RemoveItem(HGui.Shortcuts, i)
      Break()
    EndIf
    i, v = NextItem(HGui.Shortcuts, i)
  Wend

  Local wptr = self.window
  ;wptr.root = Nil

   ;If TB.Item.Exists(self, "parent")
   ;   self.Parent:Render()
  self.IsKilled = True
   ;Else
   ;   self = Nil
  If refresh Then wptr:render()
   ;EndIf

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)

  Return(True)

EndFunction

Function HGui.Gadget:drag() ; SDOC, NOT YET AVAILABLE
/******************************************************************************
SKIP DOCS
HGui.Gadget:drag()

This method will be used to drag gadgets but it's not yet available.
******************************************************************************/
  ; #TODO
  DBG.Console.Out("::::::::::::::::::::::::::::::::::::::")
  DBG.Console.Out("[ HGui.Gadget:drag ] : MISSING METHODS", DBG.Error)
  DBG.Console.Out("::::::::::::::::::::::::::::::::::::::")
EndFunction

Function HGui.Gadget:setTheme(Theme, refreshWindow) ; *TriDoc*
/*-------------------------------------------------------------------
HGui.Gadget:setTheme(Theme, refreshWindow)

Setup the gadget theme unlinking it from the global theme, the current skin will be marked as custom skin.
---------------------------------------------------------------------
INPUT
  theme : The theme table to apply
  refreshWindow : TRUE to refresh the window's contents at the end of the proccess

NOTE
  This method is experimental and unfinished.
------------------------------------------------------------------*/
  Switch self.Type
    ;::: SET BOX THEME :::
    Case #HGUI_BOX_GADGET
      ; Accepted theme options
      ;   nSkin
      If TB.Item.Exists(Theme, "nskin")
        self.Look.nSkin    = CopyTable(Theme.nSkin)
        self.Look.IsCustom = True
      EndIf

      
    ;::: SET VDIVIDER THEME :::
    Case #HGUI_VDIVIDER_GADGET
      ; Colors, Size, Padding are part of the global theme
      ; Accepted theme options
      ;   nSkin
      ;   colors
      ;     color1
      ;     color2
      ;   size
      ;   padding
      If TB.Item.Exists(Theme, "nskin")
        self.Look.nSkin = CopyTable(Theme.nSkin)
        self.Look.IsCustom = True
      EndIf
      If TB.Item.Exists(Theme, "colors")
        TB.Set(HGui.Theme.VDivider.Colors, Theme.Colors, False)
      EndIf
      If TB.Item.Exists(Theme, "size") Then HGui.Theme.VDivider.Size = Theme.Size
      If TB.Item.Exists(Theme, "padding") Then HGui.Theme.VDivider.Padding = Theme.Padding


    ;::: SET HDIVIDER THEME :::
    Case #HGUI_HDIVIDER_GADGET
      ; Colors, Size, Padding are part of the global theme
      ; Accepted theme options
      ;   nSkin
      ;   colors
      ;     color1
      ;     color2
      ;   size
      ;   padding
      If TB.Item.Exists(Theme, "nskin")
        self.Look.nSkin = CopyTable(Theme.nSkin)
        self.Look.IsCustom = True
      EndIf
      If TB.Item.Exists(Theme, "colors")
        TB.Set(HGui.Theme.HDivider.Colors, Theme.Colors, False)
      EndIf
      If TB.Item.Exists(Theme, "size") Then HGui.Theme.HDivider.Size = Theme.Size
      If TB.Item.Exists(Theme, "padding") Then HGui.Theme.HDivider.Padding = Theme.Padding


    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: SET LABEL THEME ::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_LABEL_GADGET
      ; ACCEPTED
      ;   nSkin
      ;   nText
      If TB.Item.Exists(Theme, "nskin")
        self.Look.nSkin = CopyTable(Theme.nSkin)
        self.Look.IsCustom = True
      EndIf
      If TB.Item.Exists(Theme, "ntext")
        self.Look.nText:set(Theme.nText, True)
        self.Look.IsCustom = True
      EndIf

    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: SET BUTTON THEME :::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_BUTTON_GADGET
      ; ACCEPTED
      ;   nSkin, hSkin, pSkin, dSkin
      ;   nText, hText, pText, dText
      Local skins = { "nskin", "hskin", "pskin", "dskin" }
      Local texts = { "ntext", "htext", "ptext", "dtext" }
      HGui.Theme.Button = CopyTable(Theme)
      ; Rebuild Cache
      For k = 0 To 3
        Local skin, text = skins[k], texts[k]
        If TB.Item.Exists(Theme, skin)
          self.Look[skin] = Theme[skin]
          self.Look.IsCustom = True
        EndIf
        If TB.Item.Exists(Theme, text)
          self.Look[text]:set(Theme[text], True)
          self.Look.IsCustom = True
        EndIf
      Next

    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: SET SWITCH THEME :::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_SWITCH_GADGET
      ; ACCEPTED
      ;   nSkin, hSkin, pSkin, dSkin, npskin, hpskin, dpskin
      ;   nText, hText, pText, dText, nptext, hptext, dptext
      Local skins = { "nskin", "hskin", "pskin", "dskin", "npskin", "hpskin", "dpskin" }
      Local texts = { "ntext", "htext", "ptext", "dtext", "nptext", "hptext", "dptext" }
      HGui.Theme.Button = CopyTable(Theme)
      ; Rebuild Cache
      For k = 0 To 6
        Local skin, text = skins[k], texts[k]
        If TB.Item.Exists(Theme, skin)
          self.Look[skin] = Theme[skin]
          self.Look.IsCustom = True
        EndIf
        If TB.Item.Exists(Theme, text)
          self.Look[text]:set(Theme[text], True)
          self.Look.IsCustom = True
        EndIf
      Next

    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: SET GROUP THEME ::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_GROUP_GADGET
      ; ACCEPTED
      ;   obSkin
      ;   ibSkin
      ;   nSkin
      ;   nText
      If TB.Item.Exists(Theme, "obskin")
        self.OuterBox.Look.nSkin = CopyTable(Theme.obSkin)
        self.OuterBox.Look.IsCustom = True
        self.OuterBox:cacheBuild()
      EndIf
      If TB.Item.Exists(Theme, "ibskin")
        self.InnerBox.Look.nSkin = CopyTable(Theme.ibSkin)
        self.InnerBox.Look.IsCustom = True
        self.InnerBox:cacheBuild()
      EndIf
      If TB.Item.Exists(Theme, "nskin")
        self.Header.Look.nSkin = CopyTable(Theme.nSkin)
        self.Header.Look.IsCustom = True
      EndIf
      If TB.Item.Exists(Theme, "ntext")
        If self.Header.Type = #HGUI_LABEL_GADGET
         self.Header.Look.nText:set(Theme.nText, True)
         self.Header.Look.IsCustom = True
        EndIf
      EndIf
      If self.Header.Look.IsCustom Then self.Header:cacheBuild()

    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: SET SCROLLBAR THEME ::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_SCROLLBAR_GADGET
      ; ACCEPTED
      ;   oBox (nSkin, hSkin, pSkin, dSkin)
      ;   cBox (nSkin, hSkin, pSkin, dSkin)
      ;   cText (nText, hText, pText, dText)
      ;   Handle
      Local skins = { "nskin", "hskin", "pskin", "dskin" }
      Local texts = { "ntext", "htext", "ptext", "dtext" }
      HGui.Theme.Button = CopyTable(Theme)
      ; Rebuild Cache
      For k = 0 To 3
        Local skin, text = skins[k], texts[k]
        If TB.Item.Exists(Theme, "obox")
          If TB.Item.Exists(Theme.oBox, skin)
            self.OuterBox.Look[skin] = Theme.oBox[skin]
            self.OuterBox.Look.IsCustom = True
            self.OuterBox:cacheBuild()
          EndIf
        EndIf
        If TB.Item.Exists(Theme, "cbox")
          If TB.Item.Exists(Theme.cBox, skin)
            self.Cursor.Look[skin] = Theme.cBox[skin]
            self.Cursor.Look.IsCustom = True
          EndIf
          If TB.Item.Exists(Theme.cBox, text)
            self.Cursor.Look[text]:set(Theme.cBox[text], True)
            self.Cursor.IsCustom = True
          EndIf
          self.Cursor:cacheBuild()
        EndIf
      Next
      
    Default
      DebugPrint("MISSING TYPE IN  HGui.Gadget:setTheme")
      WaitLeftMouse()

  EndSwitch

  self:cacheBuild()
  If refreshWindow Then self.window:render()

EndFunction

Function HGui.Gadget:cacheFree() ; *TriDoc*
/*---------------------------------------------------------
HGui.Gadget:cacheFree()

Method used when the cache is switched off to free cached data.
--------------------------------------------------------*/
  Switch self.type
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: FREE BOX CACHE :::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_BOX_GADGET
      If TB.Item.Exists(self.private.cache, "normal")
        If TB.Item.Exists(self, "asynchid")
          CancelAsyncDraw(self.AsynchID)
          self.AsynchID = Nil
        EndIf
        If TB.Item.Exists(self, "asynchupdater")
          ClearInterval(self.AsynchUpdater)
          self.AsynchUpdater = Nil
        EndIf
        FreeBrush(self.private.cache.normal)
        self.private.cache.normal = Nil
      EndIf      

    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: FREE IMAGE CACHE :::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_IMAGE_GADGET
      If TB.Item.Exists(self.private.cache, "normal")
        FreeBrush(self.private.cache.normal)
        self.private.cache.normal = Nil
      EndIf      

    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: FREE VDIVIDER CACHE ::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_VDIVIDER_GADGET
      If TB.Item.Exists(self.private.cache, "normal")
        FreeBrush(self.private.cache.normal)
        self.private.cache.normal = Nil
      EndIf

    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: FREE HDIVIDER CACHE ::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_HDIVIDER_GADGET
      If TB.Item.Exists(self.private.cache, "normal")
        FreeBrush(self.private.cache.normal)
        self.private.cache.normal = Nil
      EndIf

    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: FREE LABEL CACHE :::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_LABEL_GADGET
      If TB.Item.Exists(self.Private.Cache, "normal")
        FreeBrush(self.Private.Cache.Normal)
        self.Private.Cache.Normal = Nil
      EndIf

    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: FREE GROUP CACHE :::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_GROUP_GADGET
      If TB.Item.Exists(self.InnerBox.Private, "normal")
        FreeBrush(Gadget.InnerBox.Private.Normal)
        self.InnerBox.Private.Normal = Nil
        self.InnerBox.UseCache = False
      EndIf
      If TB.Item.Exists(self.OuterBox.Private, "normal")
        FreeBrush(self.OuterBox.Private.Normal)
        self.OuterBox.Private.Normal = Nil
        self.OuterBox.UseCache = False
      EndIf
      If TB.Item.Exists(self.Header.Private, "normal")
        FreeBrush(self.Header.Private.Normal)
        self.Header.Private.Normal = Nil
        self.Header.UseCache = False
      EndIf

    Default
      DebugPrint("MISSING TYPE IN HGui.Gadget:cacheFree()")
      WaitLeftMouse()

  EndSwitch
EndFunction

Function HGui.Gadget:cacheBuild() ; *TriDoc*
/*---------------------------------------------------------
HGui.Gadget:cacheBuild()

Method used to build or rebuild the gadget's cache for each status it may get. The gadget cache is stored into a brush.
-----------------------------------------------------------
NOTES
  If the cache system is switched off this methods will do nothing.
---------------------------------------------------------*/
  DBG.Console.Out(":cacheBuild() -> " .. self.name, DBG.OpenFunc, HGui.DebugChannel)

  If Not(self.usecache)
    DBG.Console.Out("Gadget cache is switched off.", DBG.Warning, HGui.DebugChannel)
    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
    Return(False)
  EndIf

  Local Borders = self.look.borders

  ; Background
  Local Area = { x = self.area.position.x, y = self.area.position.y, w = self.area.size.w, h = self.area.size.h }

/*
   If TB.Item.Exists(self, "background")
      If TB.Item.Exists(self.background.bgstruct, "brush") Then FreeBrush(self.Background.BGStruct.Brush)
      Local BGP = GetAttribute(#DISPLAY, self.window.private.HWId, #ATTRBGPIC)
      self.background.bgstruct.brush = GFX.Skin.GetBackground(Area, BGP)
   EndIf

   Local background = {}
   If TB.Item.Exists(self, "background")
      background = self.background.bgstruct
   EndIf
*/

  ; Output brush
  Local tmpBrush = CreateBrush(Nil, self.Area.size.w + 2, self.Area.size.h + 2, #WHITE, { Alphachannel = True, Clear = True })
  Area.x, Area.y = 0, 0


  Switch self.type
    ;::: CACHE BOX ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_BOX_GADGET
      If TB.Item.Exists(self.private.cache, "normal")
        FreeBrush(self.private.cache.normal)
      EndIf

      Local tArea = G2D.Area:new(0, 0, self.area.size.w, self.area.size.h)
      GFX.OutputDevice.Select(#BRUSH, tmpBrush, #SELMODE_COMBO, 2)
        self:draw(tArea)
      GFX.OutputDevice.EndSelect()

      self.private.cache.Normal = tmpBrush
      
    ;::: CACHE VDIVIDER ::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_VDIVIDER_GADGET
        If TB.Item.Exists(self.private.cache, "normal")
          FreeBrush(self.private.cache.normal)
        EndIf

        Local tArea = G2D.Area:new(0, 0, self.area.size.w, self.area.size.h)
        GFX.OutputDevice.Select(#BRUSH, tmpBrush, #SELMODE_COMBO, 2)
          self:draw(tArea)
        GFX.OutputDevice.EndSelect()

        self.private.cache.Normal = tmpBrush

    ;::: CACHE HDIVIDER ::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_HDIVIDER_GADGET
      If TB.Item.Exists(self.private.cache, "normal")
      FreeBrush(self.private.cache.normal)
    EndIf

    Local tArea = G2D.Area:new(0, 0, self.area.size.w, self.area.size.h)
    GFX.OutputDevice.Select(#BRUSH, tmpBrush, #SELMODE_COMBO, 2)
      self:draw(tArea)
    GFX.OutputDevice.EndSelect()

    self.private.cache.Normal = tmpBrush
    
    ;::: CACHE LABEL ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_LABEL_GADGET
    /*
      If TB.Item.Exists(self.Private.Cache, "normal")
        FreeBrush(self.Private.Cache.Normal)
      EndIf

      Local txtBrush = CreateBrush(Nil, self.Area.Size.w + 2, self.Area.Size.h + 2, #WHITE, { Alphachannel = True, Clear = True })
      Local tArea = G2D.Area:new(0, 0, self.Area.Size.w, self.Area.Size.h)
      GFX.OutputDevice.Select(#BRUSH, tmpBrush, #SELMODE_COMBO)
        self:draw(tArea, txtBrush)
      GFX.OutputDevice.EndSelect()
      MixBrush(tmpBrush, txtBrush, "100%")
      FreeBrush(txtBrush)

      self.Private.Cache.Normal = tmpBrush
*/
;   QUESTA PARTE QUA SOTTO NON VA BENE PERCHE' L'ALPHA CHANNEL NON VIENE ANCORA
;   GESTITO CORRETTAMENTE DA HOLLYWOOD, NELLA PROSSIMA VERSIONE IL PROBLEMA
;   DOVREBBE ESSERE STATO RISOLTO.
   
      If TB.Item.Exists(self.private.cache, "normal") Then FreeBrush(self.private.cache.normal)

        Local tArea = G2D.Area:new(Area.x, Area.y, Area.w, Area.h)
        GFX.OutputDevice.Select(#BRUSH, tmpBrush, #SELMODE_COMBO, 2)
          tArea:skinMulti(self.look.NSkin)
          If HGui.CacheGadText
            ; RIGHE COMMENTATE PER PROVARE SE IL BUG E' STATO RISOLTO'
            Local tmpBrush2 = CreateBrush(Nil, self.Area.size.w + 2, self.Area.size.h + 2, #WHITE, { Alphachannel = True, Clear = True })
            GFX.OutputDevice.Select(#BRUSH, tmpBrush2, #SELMODE_COMBO, 2)
            self.look.ntext:render({ position = { x = 0, y = 0 }, size = { w = self.area.size.w, h = self.area.size.h }, { x = area.x, y = area.y, w = self.area.size.w, h = self.area.size.h }})
            GFX.OutputDevice.EndSelect()
            GFX.OutputDevice.EndSelect()
            MixBrush(tmpBrush, tmpBrush2, "100%")
            FreeBrush(tmpBrush2)
          Else
            GFX.OutputDevice.EndSelect()
          EndIf

        self.private.cache.Normal = tmpBrush


    ;::: CACHE GROUP ::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_GROUP_GADGET
      FreeBrush(tmpBrush)
      ; Funziona anche se sta roba qua sotto la commento!!
      /*
      self.childs.gadgets[0]:cacheBuild()
      self.childs.gadgets[0].childs.gadgets[0]:cacheBuild()
      self.childs.gadgets[0].childs.gadgets[1]:cacheBuild()
      */

    ;::: CACHE BUTTON :::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_BUTTON_GADGET
      Local tArea  = G2D.Area:new(Area.x, Area.y, Area.w, Area.h)
      Local state  = { "normal", "hilighted", "pushed", "disabled" }
      Local statec = { "normal", "hilight", "pushed", "disabled" }       
      Local skin   = { "nskin", "hskin", "pskin", "dskin" }
      Local text   = { "ntext", "htext", "ptext", "dtext" }
      Local icon   = { "nname", "hname", "pname", "dname" } 
      Local status = { #HGUI_NORMAL_STATE, #HGUI_HILIGHTED_STATE, #HGUI_PUSHED_STATE, #HGUI_DISABLED_STATE }
      Local iconAlign = self.look.icons.alignment
        
        For Local i = 0 To 3
          If i <> 0 Then tmpBrush = CreateBrush(Nil, self.Area.size.w + 2, self.Area.size.h + 2, #WHITE, { Alphachannel = True, Clear = True })        
          Local cState, cSkin, cText, cIcon, cStatus, bState = state[i], skin[i], text[i], icon[i], status[i], statec[i]    
          If TB.Item.Exists(self.private.cache, bState)
            FreeBrush(self.private.cache[bState])
            self.private.cache[bState] = Nil
          EndIf

          GFX.OutputDevice.Select(#BRUSH, tmpBrush, #SELMODE_COMBO, 2)
          ;-- Skin --
          tArea:skinMulti(self.Look[cSkin])
      
          ;-- Cursor's Handle ? --
          If self.Private.IsCursor Then self:drawScrollbarHandle(cStatus)
          ;-- Icon --
          If TB.Item.Exists(self.look.icons, cIcon)
            Local iname = self.look.icons[cIcon]
            Local iptr  = GFX.Image.get(iname)
            Local x, y  = 0, 0
            If iconAlign & #HGUI_ALIGN_LEFT    = #HGUI_ALIGN_LEFT    Then x = self.look.icons.gap / 2
            If iconAlign & #HGUI_ALIGN_RIGHT   = #HGUI_ALIGN_RIGHT   Then x = area.w - self.look.icons.gap / 2 - iptr.size.w
            If iconAlign & #HGUI_ALIGN_TOP     = #HGUI_ALIGN_TOP     Then y = self.look.icons.gap / 2
            If iconAlign & #HGUI_ALIGN_BOTTOM  = #HGUI_ALIGN_BOTTOM  Then y = area.h - self.look.icons.gap / 2 - iptr.size.h
            If iconAlign & #HGUI_ALIGN_HCENTER = #HGUI_ALIGN_HCENTER Then x = (area.w - iptr.size.w)/2
            If iconAlign & #HGUI_ALIGN_VCENTER = #HGUI_ALIGN_VCENTER Then y = (area.h - iptr.size.h)/2
            ;Local tmpBrush2 = CreateBrush(Nil, self.Area.size.w + 2, self.Area.size.h + 2, #WHITE, { Alphachannel = True, Clear = True })
            ;GFX.OutputDevice.Select(#BRUSH, tmpBrush2, #SELMODE_COMBO)
              iptr:Draw({ x = x, y = y })
            ;GFX.OutputDevice.EndSelect()
            GFX.OutputDevice.EndSelect()
            ;MixBrush(tmpBrush, tmpBrush2, "100%")
            ;FreeBrush(tmpBrush2)
            GFX.OutputDevice.Select(#BRUSH, tmpBrush, #SELMODE_COMBO, 2)
          EndIf
          ;-- Text --
          If HGui.CacheGadText
            Local tmpBrush2 = CreateBrush(Nil, self.Area.size.w + 2, self.Area.size.h + 2, #WHITE, { Alphachannel = True, Clear = True })
            GFX.OutputDevice.Select(#BRUSH, tmpBrush2, #SELMODE_COMBO, 2)       
              self.look[cText]:render({ position = { x = 0, y = 0 }, size = { w = self.area.size.w, h = self.area.size.h }, { x = area.x, y = area.y, w = self.area.size.w, h = self.area.size.h }})
            GFX.OutputDevice.EndSelect()
            GFX.OutputDevice.EndSelect()
            MixBrush(tmpBrush, tmpBrush2, "100%")
            FreeBrush(tmpBrush2)
          Else
            GFX.OutputDevice.EndSelect()
          EndIf

          self.private.cache[bState] = tmpBrush
        Next
        
      ;::: CACHE SWITCH :::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_SWITCH_GADGET 
        Local tArea  = G2D.Area:new(Area.x, Area.y, Area.w, Area.h)
        Local state  = { "normal", "hilighted", "pushed", "disabled", "npushed", "hpushed", "dpushed" }
        Local statec = { "normal", "hilight", "pushed", "disabled", "npushed", "hpushed", "dpushed" }       
        Local skin   = { "nskin", "hskin", "pskin", "dskin", "npskin", "hpskin", "dpskin" }
        Local text   = { "ntext", "htext", "ptext", "dtext", "nptext", "hptext", "dptext" }
        Local icon   = { "nname", "hname", "pname", "dname", "npname", "hpname", "dpname" } 
        Local status = { #HGUI_NORMAL_STATE, #HGUI_HILIGHTED_STATE, #HGUI_PUSHED_STATE, #HGUI_DISABLED_STATE, #HGUI_NPUSHED_STATE, #HGUI_HPUSHED_STATE, #HGUI_DPUSHED_STATE }
        Local iconAlign = self.look.icons.alignment
        
        For Local i = 0 To 6
          If i <> 0 Then tmpBrush = CreateBrush(Nil, self.Area.size.w + 2, self.Area.size.h + 2, #WHITE, { Alphachannel = True, Clear = True })        
          Local cState, cSkin, cText, cIcon, cStatus, bState = state[i], skin[i], text[i], icon[i], status[i], statec[i]    
          If TB.Item.Exists(self.private.cache, bState)
            FreeBrush(self.private.cache[bState])
            self.private.cache[bState] = Nil
          EndIf

          GFX.OutputDevice.Select(#BRUSH, tmpBrush, #SELMODE_COMBO, 2)
          ;-- Skin --
          tArea:skinMulti(self.Look[cSkin])
          ;-- Cursor's Handle ? --
          If self.Private.IsCursor Then self:drawScrollbarHandle(cStatus)
          ;-- Icon --
          If TB.Item.Exists(self.look.icons, cIcon)
            Local iname = self.look.icons[cIcon]
            Local iptr  = GFX.Image.Get(iname)
            Local x, y  = 0, 0
            If iconAlign & #HGUI_ALIGN_LEFT    = #HGUI_ALIGN_LEFT    Then x = self.look.icons.gap / 2
            If iconAlign & #HGUI_ALIGN_RIGHT   = #HGUI_ALIGN_RIGHT   Then x = area.w - self.look.icons.gap / 2 - iptr.size.w
            If iconAlign & #HGUI_ALIGN_TOP     = #HGUI_ALIGN_TOP     Then y = self.look.icons.gap / 2
            If iconAlign & #HGUI_ALIGN_BOTTOM  = #HGUI_ALIGN_BOTTOM  Then y = area.h - self.look.icons.gap / 2 - iptr.size.h
            If iconAlign & #HGUI_ALIGN_HCENTER = #HGUI_ALIGN_HCENTER Then x = (area.w - iptr.size.w)/2
            If iconAlign & #HGUI_ALIGN_VCENTER = #HGUI_ALIGN_VCENTER Then y = (area.h - iptr.size.h)/2
            ;Local tmpBrush2 = CreateBrush(Nil, self.Area.size.w + 2, self.Area.size.h + 2, #WHITE, { Alphachannel = True, Clear = True })
            ;GFX.OutputDevice.Select(#BRUSH, tmpBrush2, #SELMODE_COMBO)
              iptr:Draw({ x = x, y = y })
            ;GFX.OutputDevice.EndSelect()
            GFX.OutputDevice.EndSelect()
            ;MixBrush(tmpBrush, tmpBrush2, "100%")
            ;FreeBrush(tmpBrush2)
            GFX.OutputDevice.Select(#BRUSH, tmpBrush, #SELMODE_COMBO, 2)
          Else
            DBG.Console.Out("Missing icon state for switch <" .. self.name .. "> : " .. cIcon, DBG.Warning, HGui.DebugChannel)
          EndIf
          ;-- Text --
          If HGui.CacheGadText
            Local tmpBrush2 = CreateBrush(Nil, self.Area.size.w + 2, self.Area.size.h + 2, #WHITE, { Alphachannel = True, Clear = True })
            GFX.OutputDevice.Select(#BRUSH, tmpBrush2, #SELMODE_COMBO, 2)
              self.look[cText]:render({ position = { x = 0, y = 0 }, size = { w = self.area.size.w, h = self.area.size.h }, { x = area.x, y = area.y, w = self.area.size.w, h = self.area.size.h }})
            GFX.OutputDevice.EndSelect()
            GFX.OutputDevice.EndSelect()
            MixBrush(tmpBrush, tmpBrush2, "100%")
            FreeBrush(tmpBrush2)
          Else
            GFX.OutputDevice.EndSelect()
          EndIf

          self.private.cache[bState] = tmpBrush
        Next
      
      ;::: CACHE SCROLLBAR :::
      Case #HGUI_SCROLLBAR_GADGET
        FreeBrush(tmpBrush)
        /*
        self.childs.gadgets[0]:cacheBuild()                    ; Outer Box
        self.childs.gadgets[0].childs.gadgets[0]:cacheBuild()  ; Spacer
        self.childs.gadgets[0].childs.gadgets[1]:cacheBuild()  ; Cursor
        */

      ;                                                  :: CACHE PROGRESSBAR ::
      Case #HGUI_PROGRESSBAR_GADGET
         FreeBrush(tmpBrush)
         /*
         self.childs.gadgets[0]:cacheBuild()                    ; Outer Box    |
         self.childs.gadgets[0].childs.gadgets[1]:cacheBuild()  ; Cursor       |
         */

      Case #HGUI_SLIDER_GADGET
         FreeBrush(tmpBrush)
         /*
         self.childs.gadgets[0]:cacheBuild()                    ; Outer Box    |
         self.childs.gadgets[0].childs.gadgets[1]:cacheBuild()  ; Cursor       |
         */

      Case #HGUI_LISTVIEW_GADGET
         ; This part was uncommented on 02/02/2022 to prevent a memory leak
         ExitOnError(False)
         FreeBrush(tmpBrush)
         ExitOnError(True)

      Case #HGUI_VIRTUAL_GADGET
      
      
      Case #HGUI_CANVAS_GADGET
      
      
      Case #HGUI_IMAGE_GADGET
         FreeBrush(tmpBrush)

      Case #HGUI_KNOB_GADGET
         If TB.Item.Exists(self.private.cache, "normal")
            FreeBrush(self.private.cache.normal)
         EndIf

         Local tArea = G2D.Area:new(0, 0, self.area.size.w, self.area.size.h)
         GFX.OutputDevice.Select(#BRUSH, tmpBrush, #SELMODE_COMBO, 2)
            tArea:skinMulti(self.Look.nSkin)
         GFX.OutputDevice.EndSelect()

         Local bs1 = self.Style.BorderSize1
         Local bs2 = self.Style.BorderSize2
         Local b1l = self.Style.Border1Light
         Local b1d = self.Style.Border1Dark
         Local b1fa = self.Style.Border1FillA
         Local b1fb = self.Style.Border1FillB
         Local b2l = self.Style.Border2Light
         Local b2d = self.Style.Border2Dark
         Local b2fa = self.Style.Border2FillA
         Local b2fb = self.Style.Border2FillB
         Local t = self.Style.Type

         GFX.OutputDevice.Select(#BRUSH, tmpBrush, #SELMODE_NORMAL)
            Local cx, cy, r =  self.area.size.w/2, self.area.size.h/2, Min(self.area.size.w/2.2, self.area.size.h/2.2)
            SetFormStyle(#ANTIALIAS)
            Local p = HL.Value2Perc(self.Range, self.Private.Value)
            Local angle = 360-p*360
            If bs1 <> 0
               SetFillStyle(#FILLCOLOR)
               Circle(cx+bs1, cy, r, b1d, { AnchorX = 0.5, AnchorY = 0.5 })
               Circle(cx+bs1, cy+bs1, r, b1d, { AnchorX = 0.5, AnchorY = 0.5 })
               Circle(cx-bs1, cy, r, b1l, { AnchorX = 0.5, AnchorY = 0.5 })
               Circle(cx-bs1, cy-bs1, r, b1l, { AnchorX = 0.5, AnchorY = 0.5 })
            EndIf
            SetFillStyle(#FILLGRADIENT, #LINEAR, b1fa, b1fb, 45)
            Circle(cx, cy, r, $bbbbbb, { AnchorX = 0.5, AnchorY = 0.5 })
            ;Arc(cx, cy, r, r, 0, angle, col1, { AnchorX = 0.5, AnchorY = 0.5 })
            ;Arc(cx, cy, r, r, angle, 360, col2, { AnchorX = 0.5, AnchorY = 0.5 })

            If t = 1
               Local s, c, r1 = Sin(Rad(angle))*r*self.Style.Radius2, Cos(Rad(angle))*r*self.Style.Radius2, r/self.Style.RadiusWidth
               If bs2 <> 0
                  SetFillStyle(#FILLCOLOR)
                  Circle(cx+s-bs2, cy+c, r1, b2d, { AnchorX = 0.5, AnchorY = 0.5 })
                  Circle(cx+s-bs2, cy+c-bs2, r1, b2d, { AnchorX = 0.5, AnchorY = 0.5 })
                  Circle(cx+s+bs2, cy+c, r1, b2l, { AnchorX = 0.5, AnchorY = 0.5 })
                  Circle(cx+s+bs2, cy+c+bs2, r1, b2l, { AnchorX = 0.5, AnchorY = 0.5 })
               EndIf
               SetFillStyle(#FILLGRADIENT, #LINEAR, b2fa, b2fb, 45)
               Circle(cx+s, cy+c, r1, $555555, { AnchorX = 0.5, AnchorY = 0.5 })
            ElseIf t = 2
               Local p1x, p1y, r1 = Sin(Rad(angle))*r*self.Style.Radius2, Cos(Rad(angle))*r*self.Style.Radius2, r/self.Style.RadiusWidth
               Local p2x, p2y, r1 = Sin(Rad(angle))*r*self.Style.Radius1, Cos(Rad(angle))*r*self.Style.Radius1, r/self.Style.RadiusWidth
               SetFormStyle(#ANTIALIAS)
               If bs2 > 0
                  Line(cx+p1x-bs2, cy+p1y-bs2, cx+p2x-bs2, cy+p2y-bs2, b2d, { Thickness = r1 })
                  Line(cx+p1x+bs2, cy+p1y+bs2, cx+p2x+bs2, cy+p2y+bs2, b2l, { Thickness = r1 })
               EndIf
               Line(cx+p1x, cy+p1y, cx+p2x, cy+p2y, b2fa, { Thickness = r1 })
               SetFormStyle(#NORMAL)
            EndIf

            SetFormStyle(#NORMAL)
            SetFillStyle(#FILLCOLOR)
         GFX.OutputDevice.EndSelect()

         self.private.cache.Normal = tmpBrush


      Case #HGUI_TEXT_GADGET ; BUILD TEXT
         Local tArea = G2D.Area:new(Area.x, Area.y, Area.w, Area.h)
         ;                                                          NORMAL STATE
         If TB.Item.Exists(self.private.cache, "normal"  ) Then FreeBrush(self.private.cache.normal  )

         GFX.OutputDevice.Select(#BRUSH, tmpBrush, #SELMODE_COMBO, 2)
            ;-- Skin --
            tArea:skinMulti(self.look.NSkin)
            ;-- Text --
            ;self.TextObj:Render()
         GFX.OutputDevice.EndSelect()

         self.private.cache.Normal = tmpBrush

         ;                                                          HILIGHTED STATE
         If TB.Item.Exists(self.private.cache, "hilight"  )
            FreeBrush(self.private.cache.hilight  )
         EndIf

         tmpBrush = CreateBrush(Nil, self.Area.size.w + 2, self.Area.size.h + 2, #WHITE, { Alphachannel = True, Clear = True })

         GFX.OutputDevice.Select(#BRUSH, tmpBrush, #SELMODE_COMBO, 2)
            ;-- Skin --
            tArea:skinMulti(self.look.HSkin)
            ;-- Text --
            ;self.TextObj:Render()
         GFX.OutputDevice.EndSelect()

         self.private.cache.hilight = tmpBrush

         ;                                                          PUSHED STATE
         If TB.Item.Exists(self.private.cache, "pushed"  ) Then FreeBrush(self.private.cache.pushed )

         tmpBrush = CreateBrush(Nil, self.Area.size.w + 2, self.Area.size.h + 2, #WHITE, { Alphachannel = True, Clear = True })

         GFX.OutputDevice.Select(#BRUSH, tmpBrush, #SELMODE_COMBO, 2)
            ;-- Skin --
            tArea:skinMulti(self.look.PSkin)
            ;-- Text --
           ;self.TextObj:Render()
         GFX.OutputDevice.EndSelect()

         self.private.cache.Pushed = tmpBrush

         ;                                                          DISABLED STATE
         If TB.Item.Exists(self.private.cache, "disabled"  ) Then FreeBrush(self.private.cache.disabled  )

         tmpBrush = CreateBrush(Nil, self.Area.size.w + 2, self.Area.size.h + 2, #WHITE, { Alphachannel = True, Clear = True })

         GFX.OutputDevice.Select(#BRUSH, tmpBrush, #SELMODE_COMBO, 2)
            ;-- Skin --
            tArea:skinMulti(self.look.DSkin)
            ;-- Text --
            ; self.TextObj:Render()
         GFX.OutputDevice.EndSelect()

         self.private.cache.Disabled = tmpBrush


      ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Default
         DBG.Console.Out("Unrecognized gadget type <" .. self.type .. ">, operation failed.", DBG.Error, HGui.DebugChannel)
         DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
         Return(False)

   EndSwitch

   DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
   Return(True)

EndFunction

Function HGui.Gadget:skinBordersUpdate(skin) ; *TriDoc*
/*-------------------------------------------------------------------
HGui.Gadget:skinBordersUpdate(skin)

Recalculate the skin area computing in the process the skin borders.
---------------------------------------------------------------------
INPUT
  skin: Skin table
------------------------------------------------------------------*/

 ;  DBG.Console.Out("[ HGui.Gadget:skinBordersUpdate ] : Update <" .. self.name .. "> gadget's borders", DBG.OpenFunc, HGui.DebugChannel)

   Local skc = TB.Count(skin) - 1
   For Local i = 0 To skc
      skin[i].Area =  { x = skin[i].Area.x+self.look.borders.left, y = skin[i].Area.y+self.look.borders.top, w = skin[i].Area.w-(self.look.borders.left + self.look.borders.right), h = skin[i].Area.h-(self.look.borders.top + self.look.borders.bottom)}
   Next

 ;  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
   Return(True)

EndFunction

Function HGui.ListView_ContentsUpdate(object) ; *TriDoc*
/*-------------------------------------------------------------------
HGui.ListView_ContentsUpdate(object)

Redraw the ListView contents.
---------------------------------------------------------------------
INPUT
  object : A valid ListView object
------------------------------------------------------------------*/
  ; Se lo scroller orizzontale non √® stato definito le colonne devono adattarsi
  ; alla dimensione disponibile.  
  Local i, v
  If object.HScrollerOFF
    ; Ridimensiona le colonne in proporzione allo spazio disponibile
    Local OriginalPerc, NewSizes, OriginalWidth, Changed = {}, {}, 0, False
    For i, v In IPairs(object.Data.ColumnSizes) Do OriginalWidth = OriginalWidth + v
    ; Calculate the available space
    Local availSpace = object.ListArea.Area.Size.w - ListItems(object.Data.ColumnSizes) * object.columnsGap
    
    For i, v In IPairs(object.Data.ColumnSizes)
      OriginalPerc[i] = v/OriginalWidth
      NewSizes[i] = Int(OriginalPerc[i] * availSpace)
      If NewSizes[i] <> object.Data.ColumnSizes[i] Then Changed = True
    Next
    
    ; Effettua un aggiornamento solo se necessario
    If Changed
      object:set({ data = { columnsizes = NewSizes }}, False)
      object.TopBox:Render()
    EndIf
  EndIf
  
  ; Impostazione font
  SetFont(object.FontName, object.EntryHeight+object.FontSizeOffset, { Engine = #FONTENGINE_INBUILT })
  SetFontStyle(object.FontStyle)
  
  ; Crea un brush con il contenuto
  Local bid = CreateBrush(Nil, object.ListArea.Area.Size.w, object.ListArea.Area.Size.h, object.ListAreaBG1, { AlphaChannel = False, Clear = False })
  GFX.OutputDevice.Select(#BRUSH, bid, #SELMODE_NORMAL)
    Local y = 0
    Local tabs = {}
    Local sizes = {}
    Local margin = 2
    For i = 0 To ListItems(object.Headers) - 1
      tabs[i]  = object.Headers[i].Area.Position.x + object.Headers[i].Look.Offset.x - Object.TopBox.Area.Position.x
      sizes[i] = object.Headers[i].Area.Size.w - margin*2
    Next

    SetFillStyle(#FILLCOLOR)
    Local totalVisible = Int(object.ListArea.Area.Size.h/object.EntryHeight)
    For Local i = object.FirstVisible To object.FirstVisible+totalVisible
      If object.AlternateLines
        If Int(i/2)*2 = i
          Box(0, y, object.ListArea.Area.Size.w, object.EntryHeight, object.ListAreaBG2)
        EndIf
      Else
        Box(0, y, object.ListArea.Area.Size.w, object.EntryHeight, object.ListAreaBG1)
      EndIf
      
      If TB.Item.Exists(object.data.items, i)
        If object.data.selected[i]
          SetFontColor(object.SelectedFontColor)
          Box(0, y, object.ListArea.Area.Size.w, object.EntryHeight, object.SelectedListAreaBG)
        Else
          SetFontColor(object.FontColor)
        EndIf

        Local firstXOffset = 0
        Local drawIcon, brushIcon = False
        If HaveItem(object.data, "icons")
          If HaveItem(object.data.icons, i)
            ;If object.data.icons[i] <> ""
              If Exists(object.data.icons[i])
                Local r, info = IsPicture(object.data.icons[i])
                If r
                  Local pic = LoadBrush(Nil, object.data.icons[i], { LoadAlpha = info.Alpha }) 
                  Local offsetX = object.IconsXOffset;object.IconsSizeOffset/2
                  Local offsetY = 0;object.IconsSizeOffset/2
                  Local sizeX = object.EntryHeight + object.IconsSizeOffset*2
                  Local sizeY = object.EntryHeight; + object.IconsSizeOffset*2
                  If object.IconsAsBackground
                    sizeX = object.ListArea.Area.Size.w
                    sizeY = object.EntryHeight
                    object.IconsMaximize = True
                  EndIf
                  If object.IconsMaximize
                    pic = GFX.ImageFX.Scale(pic, sizeX, sizeY, False, True, True, True)
                  Else
                    pic = GFX.ImageFX.Scale(pic, sizeX, sizeY, False, False, True, True)                    
                  EndIf
                  drawIcon = True
                  brushIcon = pic
                  ;DisplayBrush(pic, offsetX, y - offsetY)
                  ;FreeBrush(pic)
                  firstXOffset = sizeX + object.IconsTextGap;object.EntryHeight + 2
                  If object.IconsAsBackground
                    firstXOffset = 0
                  EndIf
                EndIf
              EndIf
            ;EndIf
          EndIf
          If object.IconsFixedTextOffset Then firstXOffset = object.EntryHeight + object.IconsSizeOffset*2 + object.IconsTextGap          
        Else
          firstXOffset = 0
        EndIf
            

            
        ;DebugPrint("RENDERING COLUMNS")
        For k = 0 To ListItems(object.Headers)-1
          Local x, h = tabs[k], object.EntryHeight
          If y+h > object.ListArea.Area.Size.h
            h = object.ListArea.Area.Size.h - y
          EndIf

          ;Local cid = CreateClipRegion(Nil, #BOX, 0, y, object.ListArea.Area.Size.w, h)
          ;SetClipRegion(cid)
          Local visualText = object.ColumnHandlers[k](object.data.items[i][k])
          If sizes[k] > 0             ; Colonna non nascosta
             And x + sizes[k] > 0     ; Colonna visibile a sinistra
             And x < object.ListArea.Area.Size.w ; Colonna visibile a destra
             
            ; COLONNA > 0 -> VISIBILE
            ;DebugPrint("RENDERING COLUMN", k)
            ;If 
              ; 
            ;DebugPrint("I:" .. i, "K:" .. k, x, y, sizes[k], object.EntryHeight)
            Local sz = sizes[k]
            If x < 0 Then sz = sz + x
            Local cid = GFX.SafeClipRegion(Nil, #BOX, x, y, sz, object.EntryHeight)
            ;DebugPrint("COL ", k, "Size", sizes[k], "Real", x+sz)
            ;DebugPrint("AREA SIZE:", object.ListArea.Area.Size.w, object.ListArea.Area.Size.h)
            ;DebugPrint("CLIP REG.:", x, y, sz, object.EntryHeight)
            SetClipRegion(cid)
            ; Qui √® dove avviene il rendering del testo e dove posso utilizzare un eventuale allineamento
            ; che sar√† memorizzato in object.data.Alignments[columns]
            ; TODO
            Local colSpace = sizes[k] - GFX.Text.GetWidth(visualText)
            Local alignedX = 0
            Local align = #LEFT
            ;object.data.Alignments[k] = #HGUI_ALIGN_CENTER
            If object.data.Alignments[k] = #HGUI_ALIGN_RIGHT
              align = #RIGHT
              alignedX = colSpace - margin - firstXOffset
            ElseIf object.data.alignments[k] = #HGUI_ALIGN_CENTER
              align = #CENTER
              alignedX = colSpace/2
            EndIf
            If drawIcon And k = 0
              DisplayBrush(brushIcon, object.IconsXOffset+x, 0)
              FreeBrush(brushIcon)
            EndIf
            Local xrender  = x+margin+IIf(k=0, firstXOffset, 0) + alignedX
            Local wrapSize = sizes[k] - IIf(k=0, firstXOffset, 0)
            If Not(object.Wordwrap) Then wrapSize = 0
            TextOut(xrender, y, HL.Convert.ForTextOut(visualText), { WordWrap = wrapSize })
           
            ;GFX.Text.ClipAlign(cid, HL.Convert.ForTextOut(visualText), align, margins, Object.Wordwrap, IIf(k=0, firstXOffset, 0));firstXOffset)
            
            FreeClipRegion(cid)
          EndIf
          ;FreeClipRegion(cid)
          ; L'icona √® solo nella prima colonna
          firstXOffset = 0
        Next
      Else
        Break
      EndIf
      y = y + object.EntryHeight
    Next

    If object.VLines
      For k = 1 To ListItems(object.Headers)-1
        Local x = tabs[k]
        ;Local cid = CreateClipRegion(Nil, #BOX, x, y, sizes[k], object.EntryHeight)
        ;SetClipRegion(cid)
        Line(x-2, 0, x-2, object.ListArea.Area.Size.h, object.VLinesColor1)
        Line(x-1, 0, x-1, object.ListArea.Area.Size.h, object.VLinesColor2)
        ;FreeClipRegion(c9d)
      Next
    EndIf

  GFX.OutputDevice.EndSelect()

  GFX.OutputDevice.Select(#DISPLAY, object.window.private.HWId)
    DisplayBrush(bid, object.ListArea.Area.Position.x+1, object.ListArea.Area.Position.y+1)
  GFX.OutputDevice.EndSelect()

  FreeBrush(bid)

EndFunction

Function HGui.treeView_drawOpenCloseSign(opened, x, y, width, height, sColor1, sColor2, OCStyle) ; *TriDoc*
/*---------------------------------------------------------
HGui.treeView_drawOpenCloseSign(opened, x, y, width, height, sColor1, sColor2, OCStyle)

Draw the open/close sign of a TreeView node.
-----------------------------------------------------------
INPUT
  opened  : TRUE to draw an opened node sign
  x       : Horizontal position
  y       : Vertical position
  width   : Sign's width
  height  : Sign's height
  sColor1 : Sign's color 1
  sColor2 : Sign's color 2
  OCStyle : Sign's style (1=Plus/Minus or 2=Triangles)
---------------------------------------------------------*/

  Local w = Min(width, height)
  Local h = w

  If OCStyle = 1
    y = y+2
    w = w-5
    h = h-5
    If w<1 Or h<1 Then Return()
    SetFillStyle(#FILLCOLOR)
    Box(x, y, w, h, sColor2)
    SetFillStyle(#FILLNONE)
    Box(x, y, w, h, sColor1)
    x = x+2
    y = y+2
    w = w-5
    h = h-5

    If Not(opened)
      ; simbolo +
      Line(x, y+h/2, x+w, y+h/2, sColor1)
      Line(x+w/2, y, x+w/2, y+h, sColor1)
    Else
      ; simbolo -
      Line(x, y+h/2, x+w, y+h/2, sColor1)
    EndIf
  ElseIf OCStyle = 2
    ;y = y+2
    ;w = w-5
    ;h = h-5
    If w<1 Or h<1 Then Return()

    If Not(opened)
      ; simbolo +
      SetFillStyle(#FILLCOLOR)
      SetFormStyle(#ANTIALIAS)
      Polygon(0, 0, { x+w/16, y+h/8, x+w/8*5, y+h/2, x+w/16, y+h/8*7 }, 3, sColor2)
      SetFillStyle(#FILLNONE)
      Polygon(0, 0, { x+w/16, y+h/8, x+w/8*5, y+h/2, x+w/16, y+h/8*7 }, 3, sColor1)
    Else
      ; simbolo -
      SetFillStyle(#FILLCOLOR)
      SetFormStyle(#ANTIALIAS)
      Polygon(-2, 0, { x+w/8, y+h/8*2, x+w/8*7, y+h/8*2, x+w/2, y+h/8*7 }, 3, sColor2)
      SetFillStyle(#FILLNONE)
      Polygon(-2, 0, { x+w/8, y+h/8*2, x+w/8*7, y+h/8*2, x+w/2, y+h/8*7 }, 3, sColor1)
    EndIf
  EndIf

  SetFormStyle(#NONE)
  SetFillStyle(#FILLCOLOR)

EndFunction

Function HGui.treeView_RecursiveSort_Childs(gadget, Item) ; *TriDoc*
/*---------------------------------------------------------
HGui.treeView_RecursiveSort_Childs(gadget, Item)

Used internally to sort recursively all TreeView's children.
-----------------------------------------------------------
INPUT
  gadget : TreeView object
  item   : TreeView item

NOTES
  Used by HGui.treeView_RecursiveSort()
---------------------------------------------------------*/

  If TB.Item.Exists(Item, "childs")
    TB.Sort(Item.Childs, Gadget.DescendingSort, Gadget.ColumnNumber)

    Local count = ListItems(Item.Childs)-1
    For Local i = 0 To count
      HGui.treeView_RecursiveSort_Childs(gadget, Item.Childs[i])
    Next

  EndIf

EndFunction

Function HGui.treeView_RecursiveSort(gadget) ; *TriDoc*
/*---------------------------------------------------------
HGui.treeView_RecursiveSort(gadget)

Used internally to start the sort process of all TreeView items.
-----------------------------------------------------------
INPUT
  gadget : TreeView object
  
NOTES
  This function uses LineHook switches
---------------------------------------------------------*/
  DisableLineHook()

  Local Father = Gadget.Father
  Local Items = Father.Data.Items
  Local realItems = Father.Data.realItems
  TB.Sort(Items, Gadget.DescendingSort, Gadget.ColumnNumber)

  Local count = ListItems(Items)-1
  For Local i = 0 To count
    HGui.treeView_RecursiveSort_Childs(gadget, Items[i])
  Next

  Father.Data.realItems = HGui.treeView_ElaborateList(Items, 0)
  
  EnableLineHook()

EndFunction

Function HGui.treeView_ContentsUpdate(object) ; *TriDoc*
/*---------------------------------------------------------
HGui.treeView_ContentsUpdate(object)

Redraw the TreeView contents.
-----------------------------------------------------------
INPUT
  object : A valid TreeView object
---------------------------------------------------------*/
  Local closedSign = "[[+]] "
  Local openedSign = "[[-]] "
  Local signOffset = object.EntryHeight

  ; Se lo scroller orizzontale non √® stato definito le colonne devono adattarsi
  ; alla dimensione disponibile.
  If object.HScrollerOFF
    ; Ridimensiona le colonne in proporzione allo spazio disponibile
    Local i, v
    Local OriginalPerc, NewSizes, OriginalWidth, Changed = {}, {}, 0, False
    For i, v In IPairs(object.Data.ColumnSizes) Do OriginalWidth = OriginalWidth + v
    
    For i, v In IPairs(object.Data.ColumnSizes)
      OriginalPerc[i] = v/OriginalWidth
      NewSizes[i] = Int(OriginalPerc[i] * object.ListArea.Area.Size.w)
      If NewSizes[i] <> object.Data.ColumnSizes[i] Then Changed = True
    Next
    
    ; Effettua un aggiornamento solo se necessario
    If Changed
      object:set({ data = { columnsizes = NewSizes }}, False)
      object.TopBox:Render()
    EndIf
  EndIf
   
  ; Impostazione font
  SetFont(object.FontName, object.EntryHeight+object.FontSizeOffset, { Engine = #FONTENGINE_INBUILT })
  SetFontStyle(object.FontStyle)
   
  ; Crea un brush con il contenuto
  Local bid = CreateBrush(Nil, object.ListArea.Area.Size.w, object.ListArea.Area.Size.h, object.ListAreaBG1, { AlphaChannel = False, Clear = False })
  GFX.OutputDevice.Select(#BRUSH, bid, #SELMODE_NORMAL)
    Local y = 0
    Local tabs = {}
    Local sizes = {}
    Local margin = 2
    For i = 0 To ListItems(object.Headers) - 1
      tabs[i] = object.Headers[i].Area.Position.x + object.Headers[i].Look.Offset.x - Object.TopBox.Area.Position.x
      sizes[i] = object.Headers[i].Area.Size.w - margin*2
    Next

    SetFillStyle(#FILLCOLOR)
    Local totalVisible = Int(object.ListArea.Area.Size.h/object.EntryHeight)
    For i = object.FirstVisible To object.FirstVisible+totalVisible
      If object.AlternateLines
        If Int(i/2)*2 = i
          Box(0, y, object.ListArea.Area.Size.w, object.EntryHeight, object.ListAreaBG2)
        EndIf
      Else
        Box(0, y, object.ListArea.Area.Size.w, object.EntryHeight, object.ListAreaBG1)
      EndIf
      If TB.Item.Exists(object.data.realItems, i)
        If object.data.realItems[i]._selected
          SetFontColor(object.SelectedFontColor)
          Box(0, y, object.ListArea.Area.Size.w, object.EntryHeight, object.SelectedListAreaBG)
        Else
          SetFontColor(object.FontColor)
        EndIf

        Local ident = (object.data.realItems[i]._Ident + 1) * signOffset
        Local sign = ""
            
        Local firstXOffset = 0
        If HaveItem(object.data, "icons")
          If HaveItem(object.data.icons, i)
            ;If object.data.icons[i] <> ""
              If Exists(object.data.icons[i])
                Local r, info = IsPicture(object.data.icons[i])
                If r
                  Local pic = LoadBrush(Nil, object.data.icons[i], { LoadAlpha = info.Alpha }) 
                  Local offsetX = object.IconsXOffset;object.IconsSizeOffset/2
                  Local offsetY = 0;object.IconsSizeOffset/2
                  Local sizeX = object.EntryHeight + object.IconsSizeOffset*2
                  Local sizeY = object.EntryHeight; + object.IconsSizeOffset*2
                  If object.IconsAsBackground
                    sizeX = object.ListArea.Area.Size.w
                    sizeY = object.EntryHeight
                    object.IconsMaximize = True
                  EndIf
                  If object.IconsMaximize
                    pic = GFX.ImageFX.Scale(pic, sizeX, sizeY, False, True, True, True)
                  Else
                    pic = GFX.ImageFX.Scale(pic, sizeX, sizeY, False, False, True, True)                    
                  EndIf
                  DisplayBrush(pic, offsetX, y - offsetY)
                  FreeBrush(pic)
                  firstXOffset = sizeX + object.IconsTextGap;object.EntryHeight + 2
                  If object.IconsAsBackground
                    firstXOffset = 0
                  EndIf
                EndIf
              EndIf
            ;EndIf
          EndIf
        EndIf
                
        If object.IconsFixedTextOffset Then firstXOffset = object.EntryHeight + object.IconsSizeOffset*2 + object.IconsTextGap
            

        For k = 0 To ListItems(object.Headers)-1
          Local x, h = tabs[k], object.EntryHeight
          If y+h > object.ListArea.Area.Size.h
            h = object.ListArea.Area.Size.h - y
          EndIf
               
          Local cid = CreateClipRegion(Nil, #BOX, 0, y, object.ListArea.Area.Size.w, h)

          Local visualText = object.ColumnHandlers[k](object.data.realItems[i][k])

          If k = 0
            ; Prima colonna, traccia il segno di apertura/chiusura
            ; Ignore alignment on first row because it interfere with identation
            If object.data.realItems[i]._opened And TB.Item.Exists(object.data.realItems[i], "childs")
              HGui.treeView_drawOpenCloseSign(True, x+margin+ident-signOffset, y, h, h, object.VLinesColor1, object.VLinesColor2, object.OCStyle)
              ;sign = openedSign
            EndIf
            If Not(object.data.realItems[i]._opened) And TB.Item.Exists(object.data.realItems[i], "childs")
              HGui.treeView_drawOpenCloseSign(False, x+margin+ident-signOffset, y, h, h, object.VLinesColor1, object.VLinesColor2, object.OCStyle)
              ;sign = closedSign
            EndIf
            TextOut(x+margin, y, sign, { WordWrap = sizes[k] })
            SetClipRegion(cid)
            TextOut(x+margin+ident, y, HL.Convert.ForTextOut(visualtext), { WordWrap = sizes[k]-ident })
          Else
            SetClipRegion(cid)
            Local colSpace = sizes[k] - GFX.Text.GetWidth(visualText)
            Local alignedX = 0
            Local align = #LEFT
            If object.data.alignments[k] = #HGUI_ALIGN_RIGHT
              align = #RIGHT
              alignedX = colSpace-margin
            ElseIf object.data.alignments[k] = #HGUI_ALIGN_CENTER
              align = #CENTER
              alignedX = colSpace/2
            EndIf
            Local xrender  = x+margin+ alignedX
            Local wrapSize = sizes[k]
            ;If Not(object.Wordwrap) Then wrapSize = 0
            TextOut(xrender, y, HL.Convert.ForTextOut(visualText), { WordWrap = sizes[k] })
          EndIf
          FreeClipRegion(cid)
        Next
      Else
        Break
      EndIf
      y = y + object.EntryHeight
    Next

    If object.VLines
      If TB.Count(object.data.realItems) <> 0
        tabs[0] = tabs[0] + (object.data.realItems[0]._Ident + 1) * signOffset
      Else
        tabs[0] = 0
      EndIf
      For k = 1 To ListItems(object.Headers)-1
        Local x = tabs[k]
        ;Local cid = CreateClipRegion(Nil, #BOX, x, y, sizes[k], object.EntryHeight)
        ;SetClipRegion(cid)
        Line(x-2, 0, x-2, object.ListArea.Area.Size.h, object.VLinesColor1)
        Line(x-1, 0, x-1, object.ListArea.Area.Size.h, object.VLinesColor2)
        ;FreeClipRegion(c9d)
      Next
    EndIf

  GFX.OutputDevice.EndSelect()

  GFX.OutputDevice.Select(#DISPLAY, object.window.private.HWId)
  DisplayBrush(bid, object.ListArea.Area.Position.x+1, object.ListArea.Area.Position.y+1)
  GFX.OutputDevice.EndSelect()
  FreeBrush(bid)

EndFunction

Function HGui.ListView_VScrollerUpdate(object, value, previous) ; *TriDoc*
/*-------------------------------------------------------------------
HGui.ListView_VScrollerUpdate(object, value, previous)

Used internally to update the ListView contents from its vertical scroller position.
---------------------------------------------------------------------
INPUT
  object   : ListView object
  value    : Scroller value
  previous : Previous scroller value
------------------------------------------------------------------*/

  If TB.Item.Exists(object.private, "father")
    If object.private.Father.FirstVisible <> Int(value)
      object.private.Father.FirstVisible = Int(value)
 
      HGui.ListView_ContentsUpdate(object.private.Father)
    EndIf
  EndIf

EndFunction

Function HGui.treeView_VScrollerUpdate(object, value, previous) ; *TriDoc*
/*---------------------------------------------------------
HGui.treeView_VScrollerUpdate(object, value, previous)

Used internally to update the TreeView contents from its vertical scroller position.
-----------------------------------------------------------
INPUT
  object   : TreeView object
  value    : Scroller value
  previous : Previous scroller value
---------------------------------------------------------*/

   If TB.Item.Exists(object.private, "father")
      If object.private.Father.FirstVisible <> Int(value)
        object.private.Father.FirstVisible = Int(value)
         
        HGui.treeView_ContentsUpdate(object.private.Father)
      EndIf
   EndIf
   
EndFunction

Function HGui.ListView_HScrollerUpdate(object, value, previous) ; *TriDoc*
/*-------------------------------------------------------------------
HGui.ListView_HScrollerUpdate(object, value, previous)

Used internally to update the ListView contents from its horizontal scroller position.
---------------------------------------------------------------------
INPUT
  object   : ListView object
  value    : Scroller value
  previous : Previous scroller value
------------------------------------------------------------------*/

  If TB.Item.Exists(object.private, "father")
    Local oldValue = 1
    If TB.Item.Exists(object.private.Father, "oldvalue") Then oldValue = object.private.Father.oldValue
    If value <> oldvalue
      Local count = ListItems(object.private.Father.Headers)-1
      For Local i = 0 To count
        Local Header = object.private.Father.Headers[i]
        Header.Look.Offset = { x = -value, y = 0 }
        Header.Area:set({ position = Header.Area.Position }, Header, Header.Look.Offset)
      Next
      object.private.Father.oldValue = value
      object.private.Father.TopBox:render()
      HGui.ListView_ContentsUpdate(object.private.Father)
    EndIf
  EndIf

EndFunction

Function HGui.Virtual_HScrollerUpdate(object, value, previous) ; *TriDoc*
/*-------------------------------------------------------------------
HGui.Virtual_HScrollerUpdate(object, value, previous)

Used internally to update the Virtual contents from its horizontal scroller position.
---------------------------------------------------------------------
INPUT
  object   : Virtual object
  value    : Scroller value
  previous : Previous scroller value
------------------------------------------------------------------*/

  If TB.Item.Exists(object.private, "father")
    If TB.Item.IsNil(object.private.father, "oldvaluex") Then object.private.father.oldvaluex = value
    If -value <> object.private.father.oldvaluex
      Local currentOffset = object.private.father.vbox.virtualoffset
      currentOffset.x = -value
      Object.private.Father:set({ virtualoffset = currentOffset }, True)
      object.private.father.oldvaluex = -value
    EndIf
  EndIf

EndFunction

Function HGui.Virtual_VScrollerUpdate(object, value, previous) ; *TriDoc*
/*-------------------------------------------------------------------
HGui.Virtual_VScrollerUpdate(object, value, previous)

Used internally to update the Virtual contents from its vertical scroller position.
---------------------------------------------------------------------
INPUT
  object   : Virtual object
  value    : Scroller value
  previous : Previous scroller value
------------------------------------------------------------------*/

  If TB.Item.Exists(object.private, "father")
    If TB.Item.IsNil(object.private.father, "oldvaluey") Then object.private.father.oldvaluey = value
    If -value <> object.private.father.oldvaluey
      Local currentOffset = object.private.father.vbox.virtualoffset
      currentOffset.y = -value
      Object.private.Father:set({ virtualoffset = currentOffset }, True)
      object.private.father.oldvaluey = -value
    EndIf
  EndIf

EndFunction

Function HGui.treeView_HScrollerUpdate(object, value, previous) ; *TriDoc*
/*-------------------------------------------------------------------
HGui.treeView_HScrollerUpdate(object, value, previous)

Used internally to update the TreeView contents from its horizontal scroller position.
---------------------------------------------------------------------
INPUT
  object   : TreeView object
  value    : Scroller value
  previous : Previous scroller value
------------------------------------------------------------------*/

  If TB.Item.Exists(object.private, "father")
    Local oldValue = 1
    If TB.Item.Exists(object.private.Father, "oldvalue") Then oldValue = object.private.Father.oldValue
    If value <> oldvalue
      Local count = ListItems(object.private.Father.Headers)-1
      For Local i = 0 To count
        Local Header = object.private.Father.Headers[i]
        Header.Look.Offset = { x = -value, y = 0 }
        Header.Area:set({ position = Header.Area.Position }, Header, Header.Look.Offset)
      Next
      object.private.Father.oldValue = value
      object.private.Father.TopBox:render()
      HGui.treeView_ContentsUpdate(object.private.Father)
    EndIf
  EndIf

EndFunction

Function HGui.Gadget:draw(tArea, txtBrush, state) ; *TriDoc*
/*---------------------------------------------------------
HGui.Gadget:draw(tArea, txtBrush, state)

This method is used to draw or refresh the gadget object and any children attached to it.
This method is used to draw the gadget but also to build the cache.
---------------------------------------------------------------------
INPUT
  tArea    : Area where this gadget should be rendered
  txtBrush : Optional text brush
  state    : State of the gadget we wish to draw.

NOTES
  Even if all is working fine, this method must be completed in order to finish the separation between the drawing routines and the :Render() method.
***************************************************************/
  
  If IsNil(state) Then state = self.Status
  
  Switch self.type
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: DRAW BOX :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_BOX_GADGET
      ; Skinning
      tArea:skinMulti(self.Look.nSkin)
      
      ; SPECIAL CASE : The box is an IMAGE's child
      If TB.Item.Exists(self.private, "father")
        If self.private.Father.Type = #HGUI_IMAGE_GADGET
          Local originalSmoothMode = GFX.SmoothZoom
          GFX.Smoothing(self.private.Father.Smooth)
          
          ; Render also the image
          Local Father = self.private.Father

          Local a2 = CopyTable(tArea)
          a2.x = a2.x + Father.Borders.Left
          a2.y = a2.y + Father.Borders.Top
          a2.w = a2.w - Father.Borders.Left - Father.Borders.Right
          a2.h = a2.h - Father.Borders.Top - Father.Borders.Bottom

          Local bid = -1
          Local source = Father.Source
          If Father.Mode = #HGUI_IMAGEMODE_FITMIN
            a2:skinFitMin(Source, Father.Offset, Father.Alpha, Father.Align, Father.BorderColor)
          ElseIf Father.Mode = #HGUI_IMAGEMODE_FITMAX
            a2:skinFitMax(Source, Father.Offset, Father.Alpha, Father.Align, Father.BorderColor)
          ElseIf Father.Mode > #HGUI_IMAGEMODE_FITMAX
            If GetType(Father.Source) = #STRING
              ;--- Source is a filename ---
              If Exists(Father.Source)
                Local r, info = IsPicture(Father.Source)
                If r
                  bid = LoadBrush(Nil, Father.Source, { LoadAlpha = info.Alpha })
                EndIf
              EndIf
            Else
              ;--- Source is a brush id ---
              bid = CopyBrush(Father.Source, Nil)
            EndIf

            If GetType(bid) <> #NUMBER
              If Father.Mode = #HGUI_IMAGEMODE_SCALE
                Local bw, bh = GetAttribute(#BRUSH, bid, #ATTRWIDTH), GetAttribute(#BRUSH, bid, #ATTRHEIGHT)
                bid = GFX.ImageFX.Scale(bid, bw*Father.Scale.w, Father.Scale.h, False, True, False, False)
                CropBrush(bid, Father.Offset.x+200, Father.Offset.y+200, a2.w, a2.h)

              ElseIf Father.Mode = #HGUI_IMAGEMODE_STRETCH
                ScaleBrush(bid, a2.w, a2.h, True)

              EndIf

              DisplayBrush(bid, a2.x, a2.y)

            EndIf
          EndIf

          If GetType(bid) <> #NUMBER
            FreeBrush(bid)
          EndIf
          
          GFX.Smoothing(originalSmoothMode)
          
        EndIf
      EndIf
    
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: DRAW HDIVIDER ::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_HDIVIDER_GADGET
      tArea:skinMulti(self.Look.nSkin)
      Local x1, y1 = tArea.x + Round(tArea.w/2), tArea.y + HGui.Theme.HDivider.Padding
      Local x2, y2 = x1, tArea.y + tArea.h - HGui.Theme.HDivider.Padding

      For Local i = 0 To HGui.Theme.HDivider.Size-1
        Line(x1-i, y1 , x2-i, y2, HGui.Theme.HDivider.Colors.Color1)
        Line(x1+1+i, y1, x2+1+i, y2, HGui.Theme.HDivider.Colors.Color2)
      Next
    
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: DRAW VDIVIDER ::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_VDIVIDER_GADGET
      tArea:skinMulti(self.Look.nSkin)
      Local x1, y1 = tArea.x + HGui.Theme.VDivider.Padding , tArea.y + Round(tArea.h/2)
      Local x2, y2 = tArea.x + tArea.w - HGui.Theme.VDivider.Padding, y1

      For Local i = 0 To HGui.Theme.VDivider.Size-1
        Line(x1, y1-i  , x2, y2-i  , HGui.Theme.VDivider.Colors.Color1)
        Line(x1, y1+1+i, x2, y2+1+i, HGui.Theme.VDivider.Colors.Color2)
      Next
    
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: DRAW LABEL :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_LABEL_GADGET
      tArea:skinMulti(self.Look.nSkin)
      If HL.IsNotNil(txtBrush)
        GFX.OutputDevice.Select(#BRUSH, txtBrush, #SELMODE_COMBO, 2)
          self.Look.nText:render({ Position = { x = 0, y = 0 }, Size = { w = tArea.w, h = tArea.h }, { x = 0, y = 0, w = tArea.w, h = tArea.h }})
        GFX.OutputDevice.EndSelect()
      Else
        self.Look.nText:render({ Position = { x = tArea.x, y = tArea.y }, Size = { w = tArea.w, h = tArea.h }, { x = tArea.x, y = tArea.y, w = tArea.w, h = tArea.h }})
      EndIf
      
    ;::: DRAW GROUP :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ; NOT NEEDED AS A COMPOSITE GADGET
    
  EndSwitch
  
EndFunction

Function HGui.Gadget:adaptFontSize(minSize) ; *TriDoc*
/*---------------------------------------------------------
gadgetObject:adaptFontSize(minSize)

Method used with Label & Button gadgets to adapt the font's size to the visible area's size.
This method will find the right font size to display all the text specified in the button or label.
-----------------------------------------------------------
INPUT
  minSize : Minimum font size in pixels (Defaults to 8)
---------------------------------------------------------*/
  ; Adapt font size to the gadget size
  If IsNil(minSize) Then minSize = 8
  
  Switch self.type
    Case #HGUI_BUTTON_GADGET
      Local btnHeigth = self.Area.Size.h
      Local btnWidth = self.Area.Size.w * 0.9
      Local fontSize  = Int(btnHeigth*0.9)
      Local texts = { "ntext", "htext", "ptext", "dtext" }
      
      ; Calcola la dimensione per l'aspetto normale e la
      ; applica a tutti gli altri aspetti
      Local look, v = {}, "ntext"
      Local fs = fontSize
      SetFont(self.Look[v].Font.Name, fs, { Engine = #FONTENGINE_INBUILT })
      SetFontStyle(self.Look[v].Font.Style)
      
      ; Ciclo di divisione per due per rispettare la larghezza
      While GFX.Text.GetWidth(self.Caption) > btnWidth
        fs = Int(fs/2)
        If fs <= minSize Then Break
        SetFont(self.Look[v].Font.Name, fs, { Engine = #FONTENGINE_INBUILT })
      Wend
      
      ; Ciclo di incremento di uno per massimizzare l'altezza
      While GFX.Text.GetWidth(self.Caption) < btnWidth And fs < fontSize
        fs = fs+1
        If fs <= minSize Then Break
        SetFont(self.Look[v].Font.Name, fs, { Engine = #FONTENGINE_INBUILT })
      Wend

      Local i, v
      For i, v In Pairs(texts)        
        look[v] = { Font = { Size = fs } }
      Next
      
      self:set({ Look = Look }, True)
      
    Case #HGUI_LABEL_GADGET
      Local btnHeigth = self.Area.Size.h
      Local btnWidth = self.Area.Size.w * 0.9
      Local fontSize  = Int(btnHeigth*0.9)
      Local texts = { "ntext" }
      
      ; Calcola la dimensione per l'aspetto normale e la
      ; applica a tutti gli altri aspetti
      Local look, v = {}, "ntext"
      Local fs = fontSize
      SetFont(self.Look[v].Font.Name, fs, { Engine = #FONTENGINE_INBUILT })
      SetFontStyle(self.Look[v].Font.Style)
      
      ; Ciclo di divisione per due per rispettare la larghezza
      While GFX.Text.GetWidth(self.Caption) > btnWidth
        fs = Int(fs/2)
        If fs <= minSize Then Break
        SetFont(self.Look[v].Font.Name, fs, { Engine = #FONTENGINE_INBUILT })
      Wend
      
      ; Ciclo di incremento di uno per massimizzare l'altezza
      While GFX.Text.GetWidth(self.Caption) < btnWidth And fs < fontSize
        fs = fs+1
        If fs <= minSize Then Break
        SetFont(self.Look[v].Font.Name, fs, { Engine = #FONTENGINE_INBUILT })
      Wend

      Local i, v
      For i, v In Pairs(texts)        
        look[v] = { Font = { Size = fs } }
      Next
      
      self:set({ Look = Look }, True)
    
    Default
      DBG.Console.Out("UNSUPPORTED GADGET: _adaptFontSize()", DBG.Warning, HGui.DebugChannel)
    
  EndSwitch
  
EndFunction

Function HGui.Gadget:new(type, options, parent) ; *TriDoc*
/*-------------------------------------------------------------------
gadgetObj = HGui.Gadget:new(class, options, parent)

Build a new gadget of the given 'class', with the given 'options' and the 
optional 'parent' gadget.
---------------------------------------------------------------------
INPUT
  type : Gadget class, can be one of the following:
    - #HGUI_BOX_GADGET : Box Gadget
    - #HGUI_VDIVIDER_GADGET : Vertical Divider
    - #HGUI_HDIVIDER_GADGET : Horizontal Divider
    - #HGUI_LABEL_GADGET : Label
    - #HGUI_GROUP_GADGET ; Group, following subtypes are supported :
      - #HGUI_GTYPE_GENERIC : Custom groups
      - #HGUI_GTYPE_CHECK : Group with Check-Gadgets
      - #HGUI_GTYPE_RADIO : Group with Radio-Gadgets
    - #HGUI_BUTTON_GADGET : Button
    - #HGUI_SWITCH_GADGET : Switch
    - #HGUI_SCROLLBAR_GADGET : Scrollbar
    - #HGUI_PROGRESSBAR_GADGET : Progress Bar
    - #HGUI_SLIDER_GADGET : Slider
    - #HGUI_KNOB_GADGET : Knob
    - #HGUI_TEXT_GADGET : Text / Input Box
    - #HGUI_LISTVIEW_GADGET : Listview
    - #HGUI_TREEVIEW_GADGET : Treeview
    - #HGUI_DROPDOWN_GADGET : Drop-down
    - #HGUI_IMAGE_GADGET : Image
    - #HGUI_VIRTUAL_GADGET : Virtual
    - #HGUI_CANVAS_GADGET : Canvas
    - #HGUI_PREBUILT_GROUP : Prebuilt Groups (Internal)
  options : Table with all gadget's options we want to set, here are all common supported fields, for specific gadget's arguments please
             see the related appendix.
    name : Set the gadget name instead of a random generated one. If you try to assing an already assigned name the creation will fail.
    caption : Gadget caption text (a string or a table of strings)
    tip : Gadget's floating tip text (a string or a table of strings)
    contextual : Contextual menu (table)
    status : Create the gadget with the given initial state, available states are :
      - #HGUI_NORMAL_STATE : NORMAL gadget state
      - #HGUI_HILIGHTED_STATE : HILIGHTED gadget state
      - #HGUI_PUSHED_STATE : PUSHED gadget state
      - #HGUI_DISABLED_STATE : DISABLED gadget state
      - #HGUI_NPUSHED_STATE : NORMAL PUSHED
      - #HGUI_HPUSHED_STATE : HILIGHTED PUSHED
      - #HGUI_DPUSHED_STATE : DISABLED PUSHED
    flags : Gadget flags, a table with one or more of the following fields:
      - visible : Is this gadget visible? True/False or #HGUI_ENABLED/#HGUI_DISABLED
      - enabled : Is this gadget enabled? True/False or #HGUI_VISIBLE/#HGUI_HIDDEN
      - draggable : Is this gadget draggable? True/False
    userdata : Custom data you want to be returned by event detected by this gadget.
    position : Defines the gadget position, it should have an 'x' and 'y' fields or at least one of them. This option is useless if you are using the automatic layout system.
      x : Horizontal position in pixels
      y : Vertical position in pixels
    size : Defines the gadget size, it should have a 'w' and 'h' fields or at least one of them. This option is useless if you are using the automatic layout system.
      w : Gadget's width in pixels
      h : Gadget's height in  pixels
    shortcut : Shortcut combo to simulate an OnPushed event
      qualifier : Qualifier key, can be an empty string or :
        - LSHIFT
        - RSHIFT
        - LCONTROL
        - RCONTROL
        - LALT
        - RALT
        - LCOMMAND
        - RCOMMAND
      key : Character to be pressed
      altcode : Alternative character (for example for CONTROL+char)
    sounds : Table to associate sounds to events
      onover : Sound for the onOver event
      onout : Sound for the onOut event
      onpushed : Sound for the onPushed event
      ondown : Sound for the onDown event
    actions : Actions callback functions
      onover : OnOver callback
      onout : OnOut callback
      onpushed : OnPushed callback
      ondown : OnDown callback
      ondrop : OnDrop callback
      ondropout : OnDropOut callback      
    look : Defines the gadget look and can have the following fields:
      borders : Defines the skin borders and have the following fields:
        top : Top border in pixels
        bottom : Bottom border in pixels
        left : Left border in pixels
        right : RIght border in pixels
      nskin : Background skin for normal state
      hskin : Background skin for hilighted state
      pskin : Background skin for pushed state
      dskin : Background skin for disabled state
      npskin : Background skin for normal-pushed state
      hpskin : Background skin for hilighted-pushed state
      dpskin : Background skin for disabled-pushed state
      ntext : cText object for normal state text
      htext : cText object for hilighted state text
      ptext : cText object for pushed state text
      dtext : cText object for disabled state text
      nptext : cText object for normal-pushed state text
      hptext : cText object for hilighted-pushed state text
      dptext : cText object for disabled-pushed state text
      icons : Icon definitions for all possible states
        iname : Icon name for all supported states
        nname : Icon name for normal state
        hname : Icon name for hilighted state
        pname : Icon name for pushed state
        dname : Icon name for disabled state
        npname : Icon name for normal-pushed state
        hpname : Icon name for hilighted-pushed state
        dpname : Icon name for disabled-pushed state
        alignment : Icon Alignment, see alignment constants
        gap : Icon gap in pixels
        adjtext : Text adjustment (True or False)
    usecache : True to activate the cache system (default True)
    window : Window father, object or name (default = current window)
  parent : Optional parent gadget object, mostly used internally to build composed and complex gadgets.

OUTPUT
  gadgetObj : A new gadget object or FALSE if the creation failed

NOTE
  Please have a look at the specific appendix to have an in-dept description and examples, also look at the specific appendix for gadgets that support its own arguments.
------------------------------------------------------------------*/
  DBG.Console.Out(".Gadget:new()", DBG.OpenFunc, HGui.DebugChannel)
  
  If IsNil(options) Then options = {}
  
  Local NewGad = CopyTable(self)
  NewGad.status = #HGUI_NORMAL_STATE

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: CLASS (Type) :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If IsNil(type)
    DBG.Console.Out("MISSING <TYPE> ARGUMENT", DBG.Error, HGui.DebugChannel)
    DBG.Console.Out("Creation failed.", DBG.Error, HGui.DebugChannel)
    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
    Return(False)
  Else
    NewGad.Type = type
  EndIf

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: CONTEXTUAL :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "contextual")
    NewGad.Contextual = options.contextual
  EndIf
  
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: NAME :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: 
  If HaveItem(options, "name") ; If TB.Item.Exists(options, "name")
    ;Local gad = HGui.gadgetFindByName(options.name)
    ;If GetType(gad) = #TABLE
    If HGui.gadgetExistsByName(options.name)
      DBG.Console.Out("TAG <NAME> ERROR", DBG.Error, HGui.DebugChannel)
      DBG.Console.Out("Gagdet name '" .. options.name .. "' is already assigned, creation failed.", DBG.Error, HGui.DebugChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
      Return(False)
    Else
      NewGad.name = options.name
    EndIf
  Else
    NewGad.name = HL.GetRndName()
    DBG.Console.Out("Auto-naming gadget : " .. NewGad.name, DBG.Warning, HGui.DebugChannel)
  EndIf

  ; Default values
  Local position = { x = 0, y = 0 }
  Local size     = { w = 128, h = 128 }
  Local active   = False
  Local userdata = {}

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: STATUS :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "status")
    If HGui.validateGadgetStatus(options.status)
      NewGad.Status = options.status
    Else
      DBG.Console.Out("TAG <STATUS> ERROR", DBG.Error, HGui.DebugChannel)
      DBG.Console.Out("Invalid gadget status -> '" .. options.status .. "', creation failed.", DBG.Error, HGui.DebugChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
      Return(False)     
    EndIf
  EndIf

  
  
  DBG.Console.Out("Class : " .. HGui.GadgetDescriptions[type] .. ", Name : " .. NewGad.Name .. ", Status : " .. HGui.StatusDescriptions[NewGad.status], Nil, HGui.DebugChannel)

  
  
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: USERDATA :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "userdata") Then NewGad.userdata = options.userdata

  
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: POSITION :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "position")
    If TB.Item.Exists(options.position, "x") Then position.x = options.position.x
    If TB.Item.Exists(options.position, "y") Then position.y = options.position.y
  EndIf

  
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: SIZE :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "size")
    If TB.Item.Exists(options.size, "w") Then size.w = options.size.w
    If TB.Item.Exists(options.size, "h") Then size.h = options.size.h
  EndIf

  
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: LOOK :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "look")
    If TB.Item.Exists(options.look, "borders")
      If TB.Item.Exists(options.look.borders, "top"   ) Then NewGad.look.borders.top    = options.look.borders.top
      If TB.Item.Exists(options.look.borders, "bottom") Then NewGad.look.borders.bottom = options.look.borders.bottom
      If TB.Item.Exists(options.look.borders, "left"  ) Then NewGad.look.borders.left   = options.look.borders.left
      If TB.Item.Exists(options.look.borders, "right" ) Then NewGad.look.borders.right  = options.look.borders.right
    EndIf
    
    ; During creation the skin can be passed only as a complete skin set, not
    ; just a modification of the current theme! The custom skin are references, this
    ; means that you can modify your references and easily rebuild the gadgets.
    If TB.Item.Exists(options.look, "nskin" ) Then NewGad.look.nskin  = options.look.nskin
    If TB.Item.Exists(options.look, "hskin" ) Then NewGad.look.hskin  = options.look.hskin
    If TB.Item.Exists(options.look, "pskin" ) Then NewGad.look.pskin  = options.look.pskin
    If TB.Item.Exists(options.look, "dskin" ) Then NewGad.look.dskin  = options.look.dskin
    If TB.Item.Exists(options.look, "npskin") Then NewGad.look.npskin = options.look.npskin
    If TB.Item.Exists(options.look, "hpskin") Then NewGad.look.hpskin = options.look.hpskin
    If TB.Item.Exists(options.look, "dpskin") Then NewGad.look.dpskin = options.look.dpskin
    
    ; During creation you are allowed to pass a part of the CText structure to
    ; customize it, in any way a new, indipendent, CText object will be attached
    ; to the gadgets.
    If TB.Item.Exists(options.look, "ntext" ) Then NewGad.look.ntext  = options.look.nText
    If TB.Item.Exists(options.look, "htext" ) Then NewGad.look.htext  = options.look.hText
    If TB.Item.Exists(options.look, "ptext" ) Then NewGad.look.ptext  = options.look.pText
    If TB.Item.Exists(options.look, "dtext" ) Then NewGad.look.dtext  = options.look.dText
    If TB.Item.Exists(options.look, "nptext") Then NewGad.look.nptext = options.look.npText
    If TB.Item.Exists(options.look, "hptext") Then NewGad.look.hptext = options.look.hpText
    If TB.Item.Exists(options.look, "dptext") Then NewGad.look.dptext = options.look.dpText
    
    If TB.Item.Exists(options.look, "icons")
      ; iname is used to assign the same icon to all the possible states
      If TB.Item.Exists(options.look.icons, "iname" ) Then NewGad.look.icons.iname  = options.look.icons.iname
      If TB.Item.Exists(NewGad.look.icons, "iname")
        NewGad.look.icons.nname  = NewGad.look.icons.iname
        NewGad.look.icons.hname  = NewGad.look.icons.iname
        NewGad.look.icons.pname  = NewGad.look.icons.iname
        NewGad.look.icons.dname  = NewGad.look.icons.iname
        NewGad.look.icons.npname = NewGad.look.icons.iname
        NewGad.look.icons.dpname = NewGad.look.icons.iname
        NewGad.look.icons.hpname = NewGad.look.icons.iname
      EndIf
      If TB.Item.Exists(options.look.icons, "nname" ) Then NewGad.look.icons.nname  = options.look.icons.nname
      If TB.Item.Exists(options.look.icons, "hname" ) Then NewGad.look.icons.hname  = options.look.icons.hname
      If TB.Item.Exists(options.look.icons, "pname" ) Then NewGad.look.icons.pname  = options.look.icons.pname
      If TB.Item.Exists(options.look.icons, "dname" ) Then NewGad.look.icons.dname  = options.look.icons.dname
      If TB.Item.Exists(options.look.icons, "npname") Then NewGad.look.icons.npname = options.look.icons.npname
      If TB.Item.Exists(options.look.icons, "dpname") Then NewGad.look.icons.dpname = options.look.icons.dpname
      If TB.Item.Exists(options.look.icons, "hpname") Then NewGad.look.icons.hpname = options.look.icons.hpname
      If TB.Item.Exists(options.look.icons, "alignment") Then NewGad.look.icons.alignment = options.look.icons.alignment
      If TB.Item.Exists(options.look.icons, "gap"      ) Then NewGad.look.icons.gap       = options.look.icons.gap
      If TB.Item.Exists(options.look.icons, "adjtext"  )
        NewGad.look.icons.adjtext   = options.look.icons.adjtext
      EndIf
    EndIf
  EndIf

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: CAPTION ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "caption")
    NewGad.caption = options.caption
  EndIf

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: TIP ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "tip") Then NewGad.tip = options.tip

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: FLAGS ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "flags")
    If TB.Item.Exists(options.flags, "visible"  ) Then NewGad.flags.visible   = options.flags.visible
    If TB.Item.Exists(options.flags, "enabled"  ) Then NewGad.flags.enabled   = options.flags.enabled
    If TB.Item.Exists(options.flags, "draggable") Then NewGad.flags.draggable = options.flags.draggable
  EndIf

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: SHORTCUT :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "shortcut")
    If TB.Item.Exists(options.shortcut, "qualifier")
      NewGad.shortcut.qualifier = options.shortcut.qualifier
    Else
      NewGad.shortcut.qualifier = ""
    EndIf
    If TB.Item.Exists(options.shortcut, "key") 
      NewGad.shortcut.key = options.shortcut.key
    Else
      NewGad.shortcut.key = ""
    EndIf
    If TB.Item.Exists(options.shortcut, "altcode")
      NewGad.shortcut.altcode = options.shortcut.altcode
    Else
      NewGad.shortcut.altcode = ""
    EndIf
    
    InsertItem(HGui.Shortcuts, { qualifier = NewGad.shortcut.qualifier,
                                 key       = NewGad.shortcut.key,
                                 altcode   = NewGad.shortcut.altcode,
                                 object    = NewGad })
  EndIf

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: USECACHE :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "usecache") Then NewGad.usecache = options.usecache

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: SOUNDS :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "sounds")
    If TB.Item.Exists(options.sounds, "onover"  ) Then NewGad.sounds.onover   = options.sounds.onover
    If TB.Item.Exists(options.sounds, "onout"   ) Then NewGad.sounds.onout    = options.sounds.onout
    If TB.Item.Exists(options.sounds, "onpushed") Then NewGad.sounds.onpushed = options.sounds.onpushed
    If TB.Item.Exists(options.sounds, "ondown"  ) Then NewGad.sounds.ondown   = options.sounds.ondown
  EndIf

  ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: ACTIONS :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "actions")
    If TB.Item.Exists(options.actions, "onover"  ) Then NewGad.actions.onover   = options.actions.onover
    If TB.Item.Exists(options.actions, "onout"   ) Then NewGad.actions.onout    = options.actions.onout
    If TB.Item.Exists(options.actions, "onpushed") Then NewGad.actions.onpushed = options.actions.onpushed
    If TB.Item.Exists(options.actions, "ondown"  ) Then NewGad.actions.ondown   = options.actions.ondown
    If TB.Item.Exists(options.actions, "ondrop"  ) Then NewGad.actions.ondrop   = options.actions.ondrop
    If TB.Item.Exists(options.actions, "ondropout") Then NewGad.actions.ondropout = options.actions.ondropout
  EndIf

  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: WINDOW :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "window")
    Switch GetType(options.window)
      Case #STRING
        ;--- WINDOW NAME ---
        Local win = HGui.windowFindByName(options.window)
        If GetType(win) = #TABLE
          SelectDisplay(win.private.HWId, True)
          NewGad.window = win
        Else
          DBG.Console.Out("Window <" .. options.window .. "> does not exists.", DBG.Error, HGui.DebugChannel)
          DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
          Return(False)
        EndIf

      Case #TABLE
        ;--- WINDOW STRUCTURE ---
        If TB.Item.Exists(options.window, "private")
          If TB.Item.Exists(options.window.private, "hwid")
            SelectDisplay(options.window.private.HWId, True)
            NewGad.window = options.window
          Else
            DBG.Console.Out("Invalid window's object, field <HWid> was not found, creation failed.", DBG.Error, HGui.DebugChannel)
            DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
            Return(False)
          EndIf
        Else
          DBG.Console.Out("Invalid window's object, field <private> was not found, creation failed.", DBG.Error, HGui.DebugChannel)
          DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
          Return(False)
        EndIf

      Default
        ;--- UNRECOGNIZED WINDOW PARAMETER ---
        DBG.Console.Out("Unrecognized window parameter, creation failed.", DBG.Error, HGui.DebugChannel)
        DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
        Return(False)

    EndSwitch

  Else
    DBG.Console.Out("No window specified, using the currently active window as target", DBG.Warning, HGui.DebugChannel)
    NewGad.window = HGui.ActiveWindow
    SelectDisplay(NewGad.window.private.HWId, True)
    
  EndIf

  ;::: Options:BACKGROUND :::::::::::::::::::::::::::::::::::::::::::::::::::::
  ; NON DOCUMENTATA PERCHE' FORSE NON SERVE
  If TB.Item.Exists(options, "background") Then NewGad.background = options.background


  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::: GADGET TYPES :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  Switch NewGad.type
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: NEW BOX ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_BOX_GADGET
      NewGad.Area = HGui.Area:new(
        { position = position, 
          size     = size, 
          active   = False, 
          window   = NewGad.Window }, 
        NewGad, 
        UserData)

      ; If no skin has been specified assign the default theme
      If TB.Item.IsNil(NewGad.Look, "nskin") Then NewGad.Look.nSkin = HGui.Theme.Box.nSkin
      NewGad:skinBordersUpdate(NewGad.Look.nSkin)
        
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: NEW VDIVIDER :::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_VDIVIDER_GADGET
      NewGad.Area = HGui.Area:new({ position = position, size = size, active = False, window = NewGad.Window }, NewGad, UserData)

      ; If no skin has been specified assign the default theme
      If TB.Item.IsNil(NewGad.Look, "nskin") Then NewGad.Look.nSkin = HGui.Theme.VDivider.nSkin
      NewGad:skinBordersUpdate(HGui.Theme.VDivider.nSkin)

    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: NEW HDIVIDER :::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    Case #HGUI_HDIVIDER_GADGET
      NewGad.Area = HGui.Area:new({ position = position, size = size, active = False, window = NewGad.Window }, NewGad, UserData)

      ; If no skin has been specified assign the default theme
      If TB.Item.IsNil(NewGad.Look, "nskin") Then NewGad.Look.nSkin = HGui.Theme.HDivider.nSkin
      NewGad:skinBordersUpdate(HGui.Theme.HDivider.nSkin)

      
      
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: NEW LABEL ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ; Accepts nText object fields in the options table for CText tuning.
    ; Accepts nSkin table for custom theme only for this label.
    ;
    ; CUSTOM METHODS *TriDoc*
    ; -----------------------
    ;   :Align(text_alignment, refresh)                 Set text alignment
    ;   :AppendLine(txt, autoscroll, refresh)           Append the text as last line
    ;   :Clear(refresh)                                 Clear the label's contents
    ;   :FontMargins(margins_table, refresh)            Set text margins
    ;   :FontName(fontName, refresh)                    Set the specified font
    ;   :FontSize(size, refresh)                        Set the font size
    ;   :FontStyle(styles, refresh)                     Set the font style
    ;   :Get()                                          Returns the stored text as table and as string
    ;   :SetCaption(caption, refresh)                   Set the label caption
    ;   :SetColor(color, refresh)                       Set text color
    ;   :SetWordwrap(value, refresh)                    Set wordwrap on/off
    ;   :ScrollUp(rows, refresh)                        Scroll up rows lines
    ;   :ScrollDown(rows, refresh)                      Scroll down rows lines
    ;   :ScrollTop(refresh)                             Scroll to the first line
    ;   :ScrollBottom(maximize, refresh)                Scroll to the last line
    ;   :ScrollTo(row, refresh)                         Scroll to the given row
    ;--------------------------------------------------------------------------
    Case #HGUI_LABEL_GADGET
      NewGad.Area = HGui.Area:new({ position = position, 
                                    size     = size, 
                                    active   = False, 
                                    window   = NewGad.window }, 
                                    NewGad, 
                                    UserData)

      ; SKIN
      ; ----
      ; If no skin has been specified assign the default theme
      If TB.Item.IsNil(NewGad.Look, "nskin")
        NewGad.Look.nSkin = HGui.Theme.sLabel.nSkin
      EndIf

      NewGad:skinBordersUpdate(NewGad.Look.nSkin)
      
      ; CTEXT
      ; -----
      ; If exists means that there is a customization specified, if not we have
      ; to create it using the default theme.
      Local text   = "ntext"
      Local xtheme = CopyTable(HGui.Theme.sLabel[text])

      ; Apply the customization if provided
      If TB.Item.Exists(NewGad.Look, text)
        TB.Set(xtheme, NewGad.Look[text])

      EndIf
      
      ; Added on 10/02/2023
      If TB.Item.Exists(options, "angle")
        xtheme.angle = options.angle
      EndIf
      
      xtheme.Area       = NewGad.Area
      xtheme.Window     = NewGad.Window
      xtheme.Name       = NewGad.Name .. suffix
      xtheme.Caption    = options.Caption
      NewGad.Look[text] = HGui.CText:New(xtheme)
      
      ; CUSTOM METHODS
      ; ==============
      ; :Align()
      ; -------------------------------
      NewGad.Align = 
        Function(NewGad, align, redraw)
          If IsNil(align) Then align = #HGUI_ALIGN_VCENTER + #HGUI_ALIGN_RIGHT
          If IsNil(redraw) Then redraw = True
          NewGad:Set({ Look = { nText = { Font = { Align = Align } } } }, redraw)
        EndFunction
      
      ; :FontMargins()
      ; -------------------------------
      NewGad.FontMargins = 
        Function(NewGad, margins, redraw)
          If IsNil(margins) Then margins = { top = 0, bottom = 0, left = 0, right = 0 }
          If IsNil(redraw) Then redraw = True
          NewGad:Set({ Look = { nText = { margins = margins } } }, redraw)
        EndFunction

      ; :SetCaption()
      ; -------------------------------
      NewGad.SetCaption = 
        Function(NewGad, caption, redraw)
          If IsNil(caption) Then caption = ""
          If IsNil(redraw) Then redraw = True
          NewGad:Set({ Caption = caption }, redraw)
        EndFunction
        
      ; :SetColor()
      ; -------------------------------
      NewGad.SetColor = 
        Function(NewGad, color, redraw)
          If IsNil(color) Then Return
          If IsNil(redraw) Then redraw = True
          NewGad:Set({ Look = { nText = { Font = { Color = Color } } } }, redraw)
        EndFunction

      ; :SetWordwrap()
      ; -------------------------------
      NewGad.SetWordwrap = 
        Function(NewGad, value, redraw)
          If IsNil(value) Then Return
          If IsNil(redraw) Then redraw = True
          NewGad:Set({ Look = { nText = { wordwrap = value } } }, redraw)
        EndFunction

      ; :FontSize()
      ; -------------------------------
      NewGad.FontSize =
        Function(NewGad, size, redraw)
          If IsNil(size) Then size = 16
          If IsNil(redraw) Then redraw = True
          NewGad:Set({ Look = { nText = { Font = { Size = Size } } } }, redraw)
        EndFunction

      ; :FontName()
      ; -------------------------------
      NewGad.FontName =
        Function(NewGad, fontName, redraw)
          If IsNil(fontName) Then Return()
          If IsNil(redraw) Then redraw = True
          NewGad:Set({ Look = { nText = { Font = { Name = fontName } } } }, redraw)
        EndFunction
        
      ; :FontStyle()
      ; -------------------------------
      NewGad.FontStyle = 
        Function(NewGad, style, redraw)
          If IsNil(style) Then style = #NORMAL
          If IsNil(redraw) Then redraw = True
          NewGad:Set({ Look = { nText = { Font = { Style = Style } } } }, redraw)
        EndFunction

      ; :ScrollUp()
      ; -------------------------------
      NewGad.ScrollUp = 
        Function(NewGad, r, redraw)
          If IsNil(r) Then r = 1
          If IsNil(redraw) Then redraw = True
          Local l = NewGad.look.nText.First_Line
          l = l + r
          NewGad:Set({ Look = { nText = { First_Line = l }}}, redraw)
        EndFunction

      ; ScrollDown()
      ; -------------------------------
      NewGad.ScrollDown = 
        Function(NewGad, r, redraw)
          If IsNil(r) Then r = 1
          If IsNil(redraw) Then redraw = True
          Local l = NewGad.look.nText.First_Line
          l = l - r
          NewGad:Set({ Look = { nText = { First_Line = l }}}, redraw)
        EndFunction

      ; :ScrollTop()
      ; -------------------------------
      NewGad.ScrollTop = 
      Function(NewGad, redraw)
        If IsNil(redraw) Then redraw = True
        NewGad:Set({ Look = { nText = { First_Line = 1 }}}, redraw)
      EndFunction

      ; :ScrollBottom()
      ; -------------------------------
      ;   maximize : TRUE, put the last line to the last visible line
      NewGad.ScrollBottom = 
        Function(NewGad, maximize, redraw)
          If IsNil(redraw) Then redraw = True
          Local l = ListItems(NewGad.caption)
          If maximize Then l = l - NewGad.Look.nText.VisibleRows
          NewGad:Set({ Look = { nText = { First_Line = l }}}, redraw)
        EndFunction
        
      ; :ScrollTo()
      ; -------------------------------
      NewGad.ScrollTo = 
        Function(NewGad, value, redraw)
          If IsNil(redraw) Then redraw = True
          NewGad:Set({ Look = { nText = { First_Line = Int(value) }}}, redraw)
        EndFunction
          
      ; :AppendLine()
      ; -------------------------------
      NewGad.AppendLine = 
        Function(NewGad, text, autoscroll, redraw)
          If IsNil(text)       Then Return()
          If IsNil(autoScroll) Then autoScroll = True
          If IsNil(redraw)     Then redraw = True
          Local caption = NewGad.Caption
          If GetType(caption) = #STRING
            NewGad.Caption = { NewGad.Caption }
            caption = NewGad.Caption
          EndIf
          InsertItem(caption, text)
          If autoscroll
            NewGad:Set({ caption = caption }, False)
            NewGad:ScrollBottom(True, redraw)
          Else
            NewGad:Set({ caption = caption }, redraw)
          EndIf
        EndFunction
      
      ; :Clear(refresh)
      ; -------------------------------
      NewGad.Clear =
        Function(Newgad, Refresh)
          If IsNil(Refresh) Then Refresh = True
          NewGad:Set({ caption = "" }, Refresh)
        EndFunction
        
      ; :Get()
      ; -------------------------------
      NewGad.Get = 
        Function(NewGad)
          Local asTable  = NewGad.Caption
          Local asString = ""
          If GetType(asTable) = #TABLE
            Local lastItem = ListItems(asTable)-1
            For Local i = 0 To lastItem
              asString = asString .. asTable[i]
              If i < lastItem then asString = asString .. "\n"
            Next
          Else
            asString = asTable
            asTable  = { asTable }
          EndIf
          Return(asTable, asString)
        EndFunction

        
        
        
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::: NEW GROUP ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ; Additional tags *TriDocs*
    ;   Outer_Box       Standard BOX class options for outer box
    ;   Inner_Box       Standard BOX class options for inner box
    ;   Header          Standard LABEL class options for header label
    ;   Group_LabelSide Label position : #HGUI_ALIGN_TOP, _BOTTOM, _LEFT, _RIGHT
    ;   Group_LabelGap  Increase/Deacrease label area size
    ;   GroupType       Group type : #HGUI_GTYPE_GENERIC, _CHECK, _RADIO
    ;
    ; NOTES *TriDocs*
    ;   If caption is not specified or is an empty string the label gadget
    ;   will be replaced by an empty box with the minimum possible size.
    ;
    ; METHODS *TriDoc*
    ;   :GetValues()    Returns a list of included gadgets and their values
    ;                   Each entry has :
    ;                     { index = n, name = s, value = n, gadget = <gadobject> }
    
    Case #HGUI_GROUP_GADGET  
      ; *** COMPOSITE GADGET ***
      NewGad.Area = HGui.Area:new({ position = position, size = size, active = False, window = NewGad.window }, NewGad, UserData)

      ;--- DEFAULT VALUES ---
      Local GroupMode     = #HGUI_VERTICAL_LAYOUT
      Local GroupLabelGap = 4
      If TB.Item.IsNil(options, "group_labelside") Then options.Group_LabelSide = #HGUI_ALIGN_TOP

      ; Outer_Box : Box class
      Local Box1 = HGui.Gadget:new(#HGUI_BOX_GADGET, { look = { nskin = HGui.theme.Group.obskin }, window = NewGad.window, usecache = NewGad.usecache })
      Box1.name = NewGad.name .. "_OuterBox"
      If TB.Item.Exists(options, "outer_box") Then Box1:set(options.outer_box)
      NewGad.OuterBox = Box1
  
      ; Header : Label/Box class
      Local Head = {}
      If TB.Item.Exists(options, "caption")
        If GetType(NewGad.caption) = #STRING
          NewGad.caption = { NewGad.caption }
        EndIf
        If ListItems(NewGad.Caption) = 0
          Head = HGui.Gadget:new(#HGUI_BOX_GADGET, 
            { look     = { nskin = HGui.Theme.Group.nSkin }, 
              usecache = NewGad.usecache, 
              window   = NewGad.window })   

        Else
          Head = HGui.Gadget:new(#HGUI_LABEL_GADGET, 
            { caption  = NewGad.Caption, 
              usecache = NewGad.usecache, 
              window   = NewGad.window,  
              look     = { ntext = HGui.Theme.Group.nText,
                           nskin = HGui.Theme.Group.nSkin }})
        EndIf
        
      Else
        Head = HGui.Gadget:new(#HGUI_BOX_GADGET, 
          { look     = { nskin = HGui.Theme.Group.nSkin }, 
            usecache = NewGad.usecache, 
            window   = NewGad.window })      

      EndIf
      
      Head.name = NewGad.name .. "_Header"
      If TB.Item.Exists(options, "header") Then Box1:set(options.header)
      NewGad.Header = Head
  
      ; Inner_Box : Box class
      Local Box2 = HGui.Gadget:new(#HGUI_BOX_GADGET, 
        { look     = { nskin = HGui.Theme.Group.ibSkin }, 
          usecache = NewGad.usecache, 
          window   = NewGad.window })
          
      Box2.name = NewGad.name .. "_InnerBox"
      If TB.Item.Exists(options, "inner_box") Then Box1:set(options.inner_box)
      NewGad.InnerBox = Box2
  
  
      ; GroupLabel Gap Option
      If TB.Item.Exists(options, "group_labelgap") Then GroupLabelGap = options.Group_LabelGap
      NewGad.GroupLabelGap = GroupLabelGap

      ; GroupType
      If TB.Item.Exists(options, "grouptype")
        NewGad.SubType = options.GroupType
        
      Else
        NewGad.SubType = #HGUI_GTYPE_GENERIC
        
      EndIf

      ; METHODS
      ; -------
      ; :GetValues()
      NewGad.GetValues = 
        Function(gad)
          Local results = {}
          If HaveItem(gad, "childs")
            If HaveItem(gad.childs, "gadgets")
              If HaveItem(gad.childs.gadgets, 0)
                If HaveItem(gad.childs.gadgets[0], "childs")
                  If HaveItem(gad.childs.gadgets[0].childs, "gadgets")
                    If HaveItem(gad.childs.gadgets[0].childs.gadgets, 1)
                      If HaveItem(gad.childs.gadgets[0].childs.gadgets[1], "childs")
                        If HaveItem(gad.childs.gadgets[0].childs.gadgets[1].childs, "gadgets")
                          Local list = gad.childs.gadgets[0].childs.gadgets[1].childs.gadgets
                          For Local i = 0 To ListItems(list)-1
                            Local v = -1
                            If HaveItem(list[i], "private")
                              If HaveItem(list[i].private, "value")
                                v = list[i].private.value
                              EndIf
                            EndIf
                            InsertItem(results, { index = i, name = list[i].name, value = v, gadget = list[i] })
                          Next
                        EndIf
                      EndIf
                    EndIf
                  EndIf
                EndIf
              EndIf
            EndIf
          EndIf
          
          Return(results)

        EndFunction
        
      ; Composite Gadget Building
      Local GroupGadgets = { Head, Box2 }
      Local GroupWeights = {}
      If Head.Type = #HGUI_LABEL_GADGET
        GroupWeights = { Head.look.ntext.font.size + GroupLabelGap, 1 }
        
      Else
        GroupWeights = { HGui.Theme.Group.AnonymousGroupHeader, 1 }
        
      EndIf

      If TB.Item.Exists(options, "group_labelside") And Head.Type = #HGUI_LABEL_GADGET
        Switch options.Group_LabelSide
          Case #HGUI_ALIGN_LEFT
            GroupMode = #HGUI_HORIZONTAL_LAYOUT
            Head.look.ntext:set({ angle = 90 })

          Case #HGUI_ALIGN_RIGHT
            GroupMode = #HGUI_HORIZONTAL_LAYOUT
            Head.look.ntext:set({ angle = 90 })
            GroupGadgets = { Box2, Head }
            GroupWeights = { 1, Head.look.ntext.font.size + GroupLabelGap }

          Case #HGUI_ALIGN_BOTTOM
            GroupMode = #HGUI_VERTICAL_LAYOUT
            GroupGadgets = { Box2, Head }
            GroupWeights = { 1, Head.look.ntext.font.size + GroupLabelGap }

        EndSwitch
      EndIf

      NewGad.Group_LabelSide = options.Group_LabelSide

      Box1:layoutSet({ gadgets = GroupGadgets,
                       weights = GroupWeights,
                       gap     = HGui.Theme.Group.gap,
                       type    = GroupMode,
                       borders = HGui.Theme.Group.iBorders }, False)

      NewGad.init_mode = True
      NewGad:layoutSet({ gadgets = { Box1 },
                         borders = HGui.Theme.Group.oBorders }, False)
      NewGad.init_mode = Nil

      ;::: NEW CANVAS ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ; :: Additional Parameters *TriDoc*
      ; :: CanvasSize         Canvas Size
      ; :: CanvasOffset       Canvas Offset
      ; :: DefaultLayerArgs   Default layer arguments (brush arguments)
      ; ::  -- nel virtual ci metto un box a dimensione fissa con cache attiva
      ; ::  -- nel quale renderizzo il canvas
      ; :: Additional Actions *TriDoc*
      ; ::  -- OnMove
      ; :: Custom methods *TriDocs* BUT LACKS DETAILED DOCS!!
      ; ::  :addLayer([layerArgs])
      ; ::  :removeLayer(layerID)
      ; ::  :getLayers()
      ; ::  :beginDraw(layerID, mode)
      ; ::  :endDraw()
      ; ::  :refresh()
      ; ::  :scaleLayers(w, h, smooth)
      ; ::  :resizeLayers() EXPERIMENTAL
      
      Case #HGUI_CANVAS_GADGET
        ; COMPOSITE GADGET
        DBG.Console.Out("CANVAS Gadget", Nil, HGui.DebugChannel)
        
        ; Canvas Size
        NewGad.CanvasSize = { w = 320, h = 200 }
        If TB.Item.Exists(options, "canvassize") Then TB.Set(NewGad.CanvasSize, options.CanvasSize, False)
        
        ; Canvas Offset
        NewGad.CanvasOffset = { x = 1, y = 1 }
        If TB.Item.Exists(options, "canvasoffset") Then TB.Set(NewGad.CanvasOffset, options.CanvasOffset, False)
        
        ; Default Layer Args
        NewGad.DefaultLayerArgs = { Alpha = True, Clear = True }
        If TB.Item.Exists(options, "defaultlayerargs") Then TB.Set(NewGad.DefaultLayerArgs, options.DefaultLayerArgs, False)
        
        ; OnMove action
        If TB.Item.Exists(options, "actions")
          If TB.Item.Exists(options.Actions, "onmove")
            NewGad.Actions.OnMove = Options.Actions.OnMove
          EndIf
        EndIf
        
        NewGad.SelectedLayer = -1
        
        NewGad.Area = HGui.Area:new(
          { position = position, 
            size     = size, 
            active   = False, 
            window   = NewGad.window }, 
          NewGad, 
          UserData)
          
        NewGad.Area:set({ active = True, window = NewGad.window,
                          events = { onmousedown    = HGui.gadgetEvent_LMBDown,;HGui.canvasEvent_LMBDown,
                                     onmouseup      = HGui.gadgetEvent_LMBUp,;HGui.canvasEvent_LMBUp,
                                     onrightmouseup = HGui.gadgetEvent_RMBUp,
                                     onmouseover    = HGui.canvasEvent_Over,
                                     onmouseout     = HGui.canvasEvent_Out } }, NewGad)

        ;:: DEFAULT LAYER ::
        NewGad.Layers = {}
        NewGad.Layers[0] = CreateBrush(Nil, NewGad.CanvasSize.w, NewGad.CanvasSize.h, #BLACK, NewGad.DefaultLayerArgs)
        
        ;:: METHODS ::
        NewGad.scaleLayers = Function(gad, w, h, smooth)
                                For i, v In Pairs(gad.Layers)
                                  ScaleBrush(v, w, h, smooth)
                                Next
                             EndFunction
        NewGad.resizeLayers = Function(gad)
                                For i, v In Pairs(gad.Layers)
                                  FreeBrush(v)
                                  gad.Layers[i] = CreateBrush(Nil, NewGad.CanvasSize.w, NewGad.CanvasSize.h, #RED, NewGad.DefaultLayerArgs)
                                Next
                              EndFunction
        NewGad.addLayer = Function(gad, layerArgs)
                            If IsNil(layerArgs) Then layerArgs = gad.DefaultLayerArgs
                            gad.Layers[ListItems(gad.Layers)] = CreateBrush(Nil, gad.CanvasSize.w, gad.CanvasSize.h, #BLACK, layerArgs)
                            Return(ListItems(gad.Layers)-1)
                          EndFunction
        NewGad.removeLayer = Function(gad, layerID)
                               If TB.Item.Exists(gad.Layers, layerID)
                                 FreeBrush(gad.Layers[layerID])
                                 RemoveItem(gad.Layers, layerID)
                               EndIf
                             EndFunction
        NewGad.getLayers = Function(gad)
                             Return(gad.Layers)
                           EndFunction
        NewGad.beginDraw = Function(gad, layerID, mode)
                             If TB.Item.Exists(gad.Layers, layerID)
                               If gad.SelectedLayer <> -1
                                 GFX.OutputDevice.EndSelect()
                                 gad.SelectedLayer = -1
                               EndIf
                               gad.SelectedLayer = layerID
                               GFX.OutputDevice.Select(#BRUSH, gad.Layers[layerID], mode)
                             EndIf
                           EndFunction
        NewGad.endDraw = Function(gad)
                           If gad.SelectedLayer <> -1
                             GFX.OutputDevice.EndSelect()
                             gad.SelectedLayer = -1
                           EndIf
                         EndFunction
        NewGad.refresh = Function(gad)
                           GFX.OutputDevice.Select(#BRUSH, gad.OutputBox.Private.Cache.Normal, #SELMODE_COMBO, 2)
                           For i, v In IPairs(gad.Layers)
                             DisplayBrush(v, 0, 0)
                           Next
                           GFX.OutputDevice.EndSelect()
                           gad.OutputBox:render(False, True)
                        EndFunction
                        
        ;:: VIRTUAL CONTAINER ::
        NewGad.Virtual = HGui.Gadget:new(#HGUI_VIRTUAL_GADGET, 
          { VirtualSize   = NewGad.CanvasSize,
            VirtualOffset = NewGad.CanvasOffset })
        NewGad.Virtual.Father = NewGad

        ;:: OUTPUT BOX ::
        NewGad.OutputBox = HGui.Gadget:new(#HGUI_BOX_GADGET, { usecache = True })
        NewGad.OutputBox:skinBordersUpdate(NewGad.OutputBox.Look.nSkin)

        NewGad:layoutSet({ gadgets = { NewGad.Virtual },
                            weights = { 1 },
                            gap     = 1,
                            Type    = #HGUI_VERTICAL_LAYOUT,
                            borders = { top = 0, bottom = 0, left = 0, right = 0 }})

        NewGad.Virtual.VBox:layoutSet({ gadgets = { NewGad.OutputBox },
                            weights = { 1 },
                            gap     = 1,
                            Type    = #HGUI_HORIZONTAL_LAYOUT,
                            borders = { top = 0, bottom = 0, left = 0, right = 0 }})

        
      ;::: NEW VIRTUAL :::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_VIRTUAL_GADGET
         ; COMPOSITE GADGET *TriDoc*
         ; :: VirtualSize     Size in pixel of the virtualized space (w and h)
         ; :: VirtualOffset   Rendering offset of the virtual space
         ; :: Container       Container options NEED MORE DOCS **********************
         ; :: VirtualBox      Virtual box options NEED MORE DOCS **********************
         ; :: Scrollers       Scrollbars options NEED MORE DOCS **********************
         ; :: ScrollerSize    Scrollbars size NEED MORE DOCS **********************
         ; :: HScrollerOFF    TRUE to switch off the horizontal scrollbar
         ; :: VScrollerOFF    TRUE to switch off the vertical scrollbar
         ; :: HAutoSense      TRUE to switch on the horizontal auto-sensing, this will
         ;                    switch off the horizontal scroller
         ; :: VAutoSense      TRUE to switch on the horizontal auto-sensing, this will
         ;                    switch off the horizontal scroller
         

         DBG.Console.Out("VIRTUAL Gadget", Nil, HGui.DebugChannel)
                 
         NewGad.Area = HGui.Area:new(
          { position = position, 
            size     = size, 
            active   = False, 
            window   = NewGad.window }, 
          NewGad, 
          UserData)
         
         ;:: CONTAINER :::
         NewGad.Container = HGui.Gadget:New(#HGUI_BOX_GADGET, { Name = NewGad.Name .. "_Container", look = { nSkin = HGui.Theme.Virtual.Container.nSkin }, usecache = NewGad.usecache, look = HGui.Theme.Virtual.Container, usecache = NewGad.usecache })
         If TB.Item.Exists(options, "container") Then NewGad.Container:set(options.Container, False)
         NewGad.Container:skinBordersUpdate(NewGad.Container.Look.nSkin)
         
         ;::: VIRTUAL AREA :::
         NewGad.VBox = HGui.Gadget:New(#HGUI_BOX_GADGET, { Name = NewGad.Name .. "_VirtualBox", look = { nSkin = HGui.Theme.Virtual.VirtualBox.nSkin }, usecache = NewGad.usecache, look = { nskin = HGui.theme.Group.obskin }, usecache = NewGad.usecache })
         If TB.Item.Exists(options, "virtualbox") Then NewGad.VBox:set(options.VirtualBox, False)
         NewGad.VBox:skinBordersUpdate(NewGad.VBox.Look.nSkin)
         
         ;::: VERTICAL SCROLLER :::
         NewGad.VScroller = HGui.Gadget:New(#HGUI_SCROLLBAR_GADGET, 
                                           { Name = NewGad.Name .. "_VScroller", 
                                             Range = { 1, 1, 1 },
                                             OnChange = HGui.Virtual_VScrollerUpdate,
                                             Orientation = #HGUI_VERTICAL_LAYOUT,
                                             Caption = "",
                                             ;Flags = { visible = Not(NewGad.VScrollerOFF) },
                                             Look = { OuterBox = HGui.Theme.Virtual.Scroller.oBox,
                                                      CursorBox = HGui.Theme.Virtual.Scroller.cBox,
                                                      Handle = HGui.Theme.Virtual.Scroller.Handle },
                                             usecache = NewGad.usecache })
         If TB.Item.Exists(options, "scrollers") Then NewGad.VScroller:set(options.Scrollers, False)
         NewGad.VScroller.private.Father = NewGad
                                             
         NewGad.HScroller = HGui.Gadget:New(#HGUI_SCROLLBAR_GADGET, 
                                           { Name = NewGad.Name .. "_HScroller", 
                                             Range = { 1, 1, 1 },
                                             OnChange = HGui.Virtual_HScrollerUpdate, ;<< INSERIRE FUNZIONE
                                             Orientation = #HGUI_HORIZONTAL_LAYOUT,
                                             Caption = "",
                                             ;Flags = { visible = Not(NewGad.VScrollerOFF) },
                                             Look = { OuterBox = HGui.Theme.Virtual.Scroller.oBox,
                                                      CursorBox = HGui.Theme.Virtual.Scroller.cBox,
                                                      Handle = HGui.Theme.Virtual.Scroller.Handle },
                                             usecache = NewGad.usecache })
         If TB.Item.Exists(options, "scrollers") Then NewGad.HScroller:set(options.Scrollers, False)
         NewGad.HScroller.private.Father = NewGad

         NewGad.VBox.Private.IsVirtualRoot = True
         
         ;NewGad.Private.isVirtual = True
         
         
         ; VirtualSize
         If TB.Item.Exists(options, "virtualsize")
           If TB.Item.Exists(options.VirtualSize, "w")
             NewGad.VBox.VirtualSize.w = options.VirtualSize.w
             NewGad.VBox.oldVSW = options.VirtualSize.w
           Else
             DBG.Console.Out("MISSING VirtualSize W", DBG.Error, HGui.DebugChannel)
           EndIf
           If TB.Item.Exists(options.VirtualSize, "h")
             NewGad.VBox.VirtualSize.h = options.VirtualSize.h
             NewGad.VBox.oldVSH = options.VirtualSize.w
           Else
             DBG.Console.Out("MISSING VirtualSize H", DBG.Error, HGui.DebugChannel)
           EndIf
         Else
           DBG.Console.Out("MISSING VirtualSize table", DBG.Error, HGui.DebugChannel)
         EndIf
         
         ; VirtualOffset
         If TB.Item.Exists(options, "virtualoffset")
           If TB.Item.Exists(options.VirtualOffset, "x")
             NewGad.VBox.VirtualOffset.x = options.VirtualOffset.x
           Else
             NewGad.VBox.VirtualOffset.x = 0
           EndIf
           If TB.Item.Exists(options.VirtualOffset, "y")
             NewGad.VBox.VirtualOffset.y = options.VirtualOffset.y
           Else
             NewGad.VBox.VirtualOffset.y = 0
           EndIf
         EndIf

         ; ScrollerSize
         NewGad.ScrollerSize = -100
         If TB.Item.Exists(options, "scrollersize") Then NewGad.ScrollerSize = options.ScrollerSize
         NewGad.HScrollerOFF = False
         If TB.Item.Exists(options, "hscrolleroff") Then NewGad.HScrollerOFF = options.HScrollerOFF
         NewGad.VScrollerOFF = False
         If TB.Item.Exists(options, "vscrolleroff") Then NewGad.VScrollerOFF = options.VScrollerOFF
         
         ; AutoSense
         If TB.Item.IsNil(options, "hautosense")
          options.HAutoSense = False
         ElseIf options.HAutoSense = True
          NewGad.HScrollerOFF = True
         EndIf
         NewGad.HAutoSense = options.HAutoSense
         
         If TB.Item.IsNil(options, "vautosense")
          options.VAutoSense = False
         ElseIf options.VAutoSense = True
          NewGad.VScrollerOFF = True
         EndIf
         NewGad.VAutoSense = options.VAutoSense
         
         Local scrWidth, scrHeight = GFX.GetHostSize()
         Local VScrollerSizePerc = NewGad.ScrollerSize/ScrHeight
         Local HScrollerSizePerc = VScrollerSizePerc
         If NewGad.VScrollerOFF
          VScrollerSizePerc = 0.000001
          NewGad.VScroller.Flags.Visible = False
         EndIf
         If NewGad.HScrollerOFF
          HScrollerSizePerc = 0.000001
          NewGad.HScroller.Flags.Visible = False
         EndIf
         
         Local w1, w2 = 1, 1
         If VScrollerSizePerc > 0 Then w1 = w1-VScrollerSizePerc
         If HScrollerSizePerc > 0 Then w2 = w2-HScrollerSizePerc

         If NewGad.HScrollerOFF
           NewGad.Container:layoutSet({ gadgets = { NewGad.VBox },
                              weights = { 1 },
                              gap     = 1,
                              Type    = #HGUI_VERTICAL_LAYOUT,
                              borders = { top = 0, bottom = 0, left = 0, right = 0 }})
           NewGad.HScroller:free()
           Newgad.HScroller = Nil
           
         Else
           NewGad.Container:layoutSet({ gadgets = { NewGad.VBox, NewGad.HScroller },
                              weights = { w2, HScrollerSizePerc },
                              gap     = 1,
                              Type    = #HGUI_VERTICAL_LAYOUT,
                              borders = { top = 0, bottom = 0, left = 0, right = 0 }})
           NewGad.HScroller:set({ Value = NewGad.VBox.VirtualOffset.x, Range = { 1, NewGad.VBox.VirtualSize.w, NewGad.VBox.Area.Size.w }}, False)

         EndIf
         
         If NewGad.VScrollerOFF
           NewGad:layoutSet({ gadgets = { NewGad.Container },
                              weights = { 1 },
                              gap     = 1,
                              Type    = #HGUI_HORIZONTAL_LAYOUT,
                              borders = { top = 0, bottom = 0, left = 0, right = 0 }})
           NewGad.VScroller:free()
           Newgad.VScroller = Nil

         Else
           NewGad:layoutSet({ gadgets = { NewGad.Container, NewGad.VScroller },
                              weights = { w1, VScrollerSizePerc },
                              gap     = 1,
                              Type    = #HGUI_HORIZONTAL_LAYOUT,
                              borders = { top = 0, bottom = 0, left = 0, right = 0 }})
           NewGad.VScroller:set({ Value = NewGad.VBox.VirtualOffset.y, Range = { 1, NewGad.VBox.VirtualSize.h, NewGad.VBox.Area.Size.h }}, False)
         EndIf
        
        ; Se l'auto sense √® attivo forza un refresh
        If NewGad.HAutoSense Or NewGad.VAutoSense
          NewGad:set({ position = position, size = size })
        EndIf

      ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::         
      ;::: NEW BUTTON ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ; Accepts n|h|p|dText object fields in the options table for CText tuning.
      ; Accepts n|h|p|nSkin table for custom theme only for this label.
      ;
      ; CUSTOM METHODS *TriDoc*
      ; --------------
      ; :Aligns(table, refresh)            Set text alignment(s)
      ; :SetCaptions(table, refresh)       Set text caption(s)

      Case #HGUI_BUTTON_GADGET
        DBG.Console.Out("BUTTON Gadget", Nil, HGui.DebugChannel)
        NewGad.Area = HGui.Area:new(
          { position = position, 
            size     = size, 
            active   = True, 
            window   = NewGad.window,
            events   = { onmousedown    = HGui.gadgetEvent_LMBDown,
                         onmouseup      = HGui.gadgetEvent_LMBUp,
                         onrightmouseup = HGui.gadgetEvent_RMBUp,
                         onmouseover    = HGui.gadgetEvent_Over,
                         onmouseout     = HGui.gadgetEvent_Out } 
            }, NewGad, UserData)

        Local skins = { "nskin", "hskin", "pskin", "dskin" }
        Local texts = { "ntext", "htext", "ptext", "dtext" }
        Local icons = { "nname", "hname", "pname", "dname" }
        Local sufx  = { "", "_h", "_p", "_d" }
        For Local k = 0 To 3
          Local skin, text, icon, suffix = skins[k], texts[k], icons[k], sufx[k]
          ; If no skin has been specified attach the default theme
          If TB.Item.IsNil(NewGad.look, skin)
            NewGad.look[skin] = HGui.Theme.Button[skin]
          EndIf
          NewGad:skinBordersUpdate(NewGad.look[skin])    
          
          ; CText: if exists means that there is a customization specified
          ; if not we have to create it using default theme
          Local xtheme = CopyTable(HGui.Theme.Button[text])
          
          ; Se esiste una customizzazione la applico
          If TB.Item.Exists(NewGad.Look, text)
            TB.Set(xtheme, NewGad.Look[text])
            
          Else
            ; Non esiste, non faccio nulla

          EndIf
          
          ; Added on 10/02/2023
          If TB.Item.Exists(options, "angle")
            xtheme.angle = options.angle
          EndIf
          
          xtheme.Area       = NewGad.Area
          xtheme.Window     = NewGad.Window
          xtheme.Name       = NewGad.Name .. suffix
          xtheme.Caption    = options.Caption
          NewGad.Look[text] = HGui.CText:New(xtheme)

          If TB.Item.Exists(NewGad.Look.Icons, icon)
            If NewGad.Look.Icons.AdjText
               Local icon_name = NewGad.Look.Icons[icon]
               Local icon_ptr  = GFX.Image.Get(icon_name)
               Local align     = NewGad.Look.Icons.Alignment
               If align & #HGUI_ALIGN_LEFT   = #HGUI_ALIGN_LEFT   Then NewGad.look[text]:set({ margins = { left   = NewGad.look[text].margins.left   + icon_ptr.size.w + NewGad.Look.Icons.Gap }})
               If align & #HGUI_ALIGN_RIGHT  = #HGUI_ALIGN_RIGHT  Then NewGad.look[text]:set({ margins = { right  = NewGad.look[text].margins.right  + icon_ptr.size.w + NewGad.Look.Icons.Gap }})
               If align & #HGUI_ALIGN_TOP    = #HGUI_ALIGN_TOP    Then NewGad.look[text]:set({ margins = { top    = NewGad.look[text].margins.top    + icon_ptr.size.h + NewGad.Look.Icons.Gap }})
               If align & #HGUI_ALIGN_BOTTOM = #HGUI_ALIGN_BOTTOM Then NewGad.look[text]:set({ margins = { bottom = NewGad.look[text].margins.bottom + icon_ptr.size.h + NewGad.Look.Icons.Gap }})
               
            EndIf
            
          EndIf
           
        Next

        
        ; CUSTOM METHODS
        ; ==============
        ; :Aligns(table, refresh)
        ;   Set the button's alignments for each states separately if you pass a table
        ;   with single states fields (normal, pushed, disabled, hilighted), or, if
        ;   you pass an alignment constant, it will be applied to all states.
        NewGad.Aligns =
          Function(gadget, tbl, refresh)
            If GetType(tbl) = #NUMBER
              gadget:Set({ Look = { ntext  = { Font = { Align = tbl } } } }, False)
              gadget:Set({ Look = { htext  = { Font = { Align = tbl } } } }, False)
              gadget:Set({ Look = { ptext  = { Font = { Align = tbl } } } }, False)
              gadget:Set({ Look = { dtext  = { Font = { Align = tbl } } } }, False)
              
            ElseIf GetType(tbl) = #TABLE
              If TB.Item.Exists(tbl, "normal")    Then gadget:Set({ Look = { ntext  = { Font = { Align = tbl.normal    } } } }, False)
              If TB.Item.Exists(tbl, "hilighted") Then gadget:Set({ Look = { htext  = { Font = { Align = tbl.hilighted } } } }, False)
              If TB.Item.Exists(tbl, "pushed")    Then gadget:Set({ Look = { ptext  = { Font = { Align = tbl.pushed    } } } }, False)
              If TB.Item.Exists(tbl, "disabled")  Then gadget:Set({ Look = { dtext  = { Font = { Align = tbl.disabled  } } } }, False)
            
            EndIf

            If refresh Then gadget:Render()

          EndFunction
          
        ; :SetCaptions(table, refresh)
        ;   Set the button's caption for each states separately if you pass a table
        ;   with single states fields (normal, pushed, disabled, hilighted), or, if
        ;   pass a string, it will sets the given caption on all states.
        ;   I you pass a table of string with a numeric index than it will be interpreted
        ;   as a multiline string to apply to all states.
        NewGad.SetCaptions =
          Function(gadget, tbl, refresh)
            If GetType(tbl) = #STRING
              tbl = { normal    = tbl, 
                      hilighted = tbl, 
                      disabled  = tbl, 
                      pushed    = tbl }
            EndIf
            
            If GetType(tbl) = #TABLE
              ; Table of strings for all captions
              If TB.Item.IsNil(tbl, "normal") And
                 TB.Item.IsNil(tbl, "hilighted") And
                 TB.Item.IsNil(tbl, "disabled") And
                 TB.Item.IsNil(tbl, "pushed")
                 
                gadget:Set({ Look = { ntext  = { Caption = tbl } } }, False)
                gadget:Set({ Look = { htext  = { Caption = tbl } } }, False)
                gadget:Set({ Look = { ptext  = { Caption = tbl } } }, False)
                gadget:Set({ Look = { dtext  = { Caption = tbl } } }, False)
                
              Else
                ; Table of string states
                If TB.Item.Exists(tbl, "pushed")    Then gadget:Set({ Look = { ptext = { Caption = tbl.pushed    } } }, False)
                If TB.Item.Exists(tbl, "normal")    Then gadget:Set({ Look = { ntext = { Caption = tbl.normal    } } }, False)
                If TB.Item.Exists(tbl, "hilighted") Then gadget:Set({ Look = { htext = { Caption = tbl.hilighted } } }, False)
                If TB.Item.Exists(tbl, "disabled")  Then gadget:Set({ Look = { dtext = { Caption = tbl.disabled  } } }, False)
              
              EndIf
              
            EndIf

            If refresh Then gadget:Render()
            
          EndFunction
        
      ;::: NEW SWITCH ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;:: Additional Option's table parameters *TriDoc*                       ::
      ;:: - Value             1 = Switch ON (Down), 0 = Switch OFF (Up)       ::
      ;::
      ;:: METHODS
      ;::   :GetValue()      Return the switch value (0 or 1)
      ;::   :SetValue(v)     Set the switch value
      ;::   :IsDown()        Return if the switch is pressed
      ;::   :IsUp()          Return if the switch is not pressed
      ;::   :SetCaptions(t)  Change the 'normal' and 'pushed' texts
      ;::
      ;:: EVENTS
      ;::   OnPushed
      
      Case #HGUI_SWITCH_GADGET
        DBG.Console.Out("SWITCH Gadget", Nil, HGui.DebugChannel)
        NewGad.Area = HGui.Area:new({ position = position, size = size, active = True, window = NewGad.window,
                                      events = { onmousedown = HGui.gadgetEvent_LMBDown,
                                                 onmouseup   = HGui.gadgetEvent_LMBUp,
                                                 onrightmouseup = HGui.gadgetEvent_RMBUp,
                                                 onmouseover = HGui.gadgetEvent_Over,
                                                 onmouseout  = HGui.gadgetEvent_Out } }, NewGad, UserData)
        ;:: VALUE ::
        If TB.Item.Exists(options, "value")
          If Options.Value > 1
            Options.Value = 1
          ElseIf Options.Value < 0
            Options.Value = 0
          EndIf

          NewGad.private.Value = Options.Value
        Else
          NewGad.private.Value = 0
        EndIf

        If NewGad.private.Value = 0
          NewGad.Status = #HGUI_NORMAL_STATE
        Else
          NewGad.Status = #HGUI_NPUSHED_STATE
        EndIf

        Local skins = { "nskin", "hskin", "pskin", "dskin", "npskin", "hpskin", "dpskin" }
        Local texts = { "ntext", "htext", "ptext", "dtext", "nptext", "hptext", "dptext" }
        Local icons = { "nname", "hname", "pname", "dname", "npname", "hpname", "dpname" }
        Local sufx  = { "", "_h", "_p", "_d", "_np", "_hp", "_dp" }
        
        ; METHODS
        ; -------
        ; :GetValue()
        NewGad.GetValue = Function(gadget) Return(ToNumber(gadget.Private.Value)) EndFunction
        
        ; :SetValue(value)
        NewGad.SetValue = Function(gadget, value) gadget:Set({ Value = value }, True) EndFunction
        
        ; :IsDown()
        NewGad.IsDown   = Function(gadget) Return(IIf(gadget.Private.Value=1, True, False)) EndFunction
        
        ; :IsUp()
        NewGad.IsUp     = Function(gadget) Return(IIf(gadget.Private.Value=0, True, False)) EndFunction
        
        ; :SetCaptions(table)
        ;   fields : normal, pushed
        NewGad.SetCaptions =
          Function(gadget, tbl, refresh)
            Local i, v
            For i, v In Pairs(tbl)
              If i = "pushed"
                gadget:Set({ Look = { ptext  = { Caption = v },
                                      nptext = { Caption = v },
                                      hptext = { Caption = v },
                                      dptext = { Caption = v }
                                      } 
                            }, False)
              ElseIf i = "normal"
                gadget:Set({ Look = { ntext = { Caption = v },
                                      htext = { Caption = v },
                                      dtext = { Caption = v }
                                      } 
                            }, False)              
              EndIf
            Next
            If refresh Then gadget:Render()
          EndFunction
          
        ; --------------------------------------------------------------------
        For Local k = 0 To 6
          Local skin, text, icon, suffix = skins[k], texts[k], icons[k], sufx[k]
            ; If no skin has been specified attach the default theme
            If TB.Item.IsNil(NewGad.look, skin)
              NewGad.look[skin] = HGui.theme["switch"][skin]
            EndIf
            NewGad:skinBordersUpdate(NewGad.look[skin])    
            
            ; CText: if exists means that there is a customization specified
            ; if not we have to create it using default theme
            Local xtheme = CopyTable(HGui.Theme["switch"][text])
            
            ; Se esiste una customizzazione la applico
            If TB.Item.Exists(NewGad.Look, text)
              TB.Set(xtheme, NewGad.Look[text])
              
            Else
              ; Non esiste, non faccio nulla

            EndIf
         
            ; Added on 10/02/2023
            If TB.Item.Exists(options, "angle")
              xtheme.angle = options.angle
            EndIf
         
            xtheme.Area       = NewGad.Area
            xtheme.Window     = NewGad.Window
            xtheme.Name       = NewGad.Name .. suffix
            xtheme.Caption    = options.Caption
            NewGad.Look[text] = HGui.CText:New(xtheme)

            If TB.Item.Exists(NewGad.Look.Icons, icon)
              If NewGad.Look.Icons.AdjText
                 Local icon_name = NewGad.Look.Icons[icon]
                 Local icon_ptr  = GFX.Image.Get(icon_name)
                 Local align     = NewGad.Look.Icons.Alignment
                 If align & #HGUI_ALIGN_LEFT   = #HGUI_ALIGN_LEFT   Then NewGad.look[text]:set({ margins = { left   = NewGad.look[text].margins.left   + icon_ptr.size.w + NewGad.Look.Icons.Gap }})
                 If align & #HGUI_ALIGN_RIGHT  = #HGUI_ALIGN_RIGHT  Then NewGad.look[text]:set({ margins = { right  = NewGad.look[text].margins.right  + icon_ptr.size.w + NewGad.Look.Icons.Gap }})
                 If align & #HGUI_ALIGN_TOP    = #HGUI_ALIGN_TOP    Then NewGad.look[text]:set({ margins = { top    = NewGad.look[text].margins.top    + icon_ptr.size.h + NewGad.Look.Icons.Gap }})
                 If align & #HGUI_ALIGN_BOTTOM = #HGUI_ALIGN_BOTTOM Then NewGad.look[text]:set({ margins = { bottom = NewGad.look[text].margins.bottom + icon_ptr.size.h + NewGad.Look.Icons.Gap }})
              EndIf
           EndIf
        Next
        
      ;::: NEW SCROLLBAR ::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_SCROLLBAR_GADGET
        ; COMPOSITE GADGET
        ; Additional parameters *TriDoc*
        ;    Orientation     #VERTICAL, #HORIZONTAL
        ;    Caption         Cursor text with support for the following tags:
        ;                    {value}, {value.##}, {intvalue}, {rangestart},
        ;                    {rangeend}
        ;    Range           { Minimum, Maximum, Visible }
        ;    Value           Current value
        ;    Outer_Box       Standard options for the outer box (Button)
        ;    Cursor          Standard options for the cursor box (Button)
        ;    TextAngle       Caption rendering angle
        ; Additional actions *TriDoc*
        ;    OnChange        Callback function

        DBG.Console.Out("SCROLLBAR Gadget", Nil, HGui.DebugChannel)
        NewGad.Area = HGui.Area:new({ position = position, size = size, active = False, window = NewGad.window }, NewGad, UserData)

        ;::: PARAMETERS :::::::::::::::::::::::::::::::::::::::::::::::::::::::
        ;--- OnChange ---
         If TB.Item.Exists(options, "onchange") Then NewGad.Actions.OnChange = options.OnChange

        ;--- Orientation ---
         NewGad.Orientation = #HGUI_VERTICAL_LAYOUT
         If TB.Item.Exists(options, "orientation") Then NewGad.Orientation = options.orientation

        ;--- Caption ---
        ; Accept special tags:
        ; {value}, {value.##}, {intvalue}, {rangestart}, {rangeend}
        Local Caption = ""
        If TB.Item.Exists(options, "caption") Then Caption = options.caption

        ;--- Range ---
        ; { LowerValue, HigherValue, CursorRange }
        NewGad.Range = { 1, 100, 20 }
        If TB.Item.Exists(options, "range") Then NewGad.Range = options.range

        ;--- Value ---
        ; Initial cursor's value, must be:
        ; Range[0] <= Value <= (Range[1]-Range[2]+1)
        NewGad.Private.Value = 1
        If TB.Item.Exists(options, "value") Then NewGad.Private.Value = options.value

        If NewGad.Private.Value < NewGad.Range[0]
          NewGad.Private.Value = NewGad.Range[0]
        ElseIf NewGad.Private.Value > (NewGad.Range[1] - NewGad.Range[2] + 1)
          NewGad.Private.Value = (NewGad.Range[1] - NewGad.Range[2] + 1)
        EndIf

        ;--- Outer_Box ---
        ; Outer Box options (Button).                                         :
        Local Look = {
                nskin = HGui.Theme.scrollbar.obox.nskin,
                hskin = HGui.Theme.scrollbar.obox.hskin,
                pskin = HGui.Theme.scrollbar.obox.pskin,
                dskin = HGui.Theme.scrollbar.obox.dskin,
                ntext = HGui.Theme.scrollbar.cbox.nskin,
                htext = HGui.Theme.scrollbar.cbox.htext,
                ptext = HGui.Theme.scrollbar.cbox.ptext,
                dtext = HGui.Theme.scrollbar.cbox.dtext }
        If TB.Item.Exists(options, "look")
          If TB.Item.Exists(options.look, "outerbox") Then Look = TB.Set(Look, options.Look.OuterBox, True)
        EndIf
        Local Box1 = HGui.Gadget:new(#HGUI_BUTTON_GADGET,
                                    { name = NewGad.name .. "_OuterBox",
                                      caption = "",
                                      flags = NewGad.flags,
                                      look = Look,
                                      usecache = NewGad.usecache })
        If TB.Item.Exists(options, "outer_box") Then Box1:set(options.Outer_Box, False)
        Box1.private.Father = NewGad
        NewGad.OuterBox = Box1

        ;--- Spacer ---
        ; This is an invisible items used as spacer to let the cursor box
        ; move along the Outer Box.
        Local Head = HGui.Gadget:new(#HGUI_BOX_GADGET, { look = { nskin = HGui.Theme.Empty.nSkin }, usecache = NewGad.usecache })
        Head.name = NewGad.name .. "_Spacer"
        Head.private.Father = NewGad
        NewGad.Spacer = Head

        ;--- Cursor ---
        ; Cursor's box options (Button).
        Local Look = {
                nskin = HGui.Theme.scrollbar.cbox.nskin,
                hskin = HGui.Theme.scrollbar.cbox.hskin,
                pskin = HGui.Theme.scrollbar.cbox.pskin,
                dskin = HGui.Theme.scrollbar.cbox.dskin,
                ntext = HGui.Theme.scrollbar.cbox.nskin,
                htext = HGui.Theme.scrollbar.cbox.htext,
                ptext = HGui.Theme.scrollbar.cbox.ptext,
                dtext = HGui.Theme.scrollbar.cbox.dtext,
                icons = { alignment = #HGUI_ALIGN_CENTER } }
        If TB.Item.Exists(options, "look")
           If TB.Item.Exists(options.look, "cursorbox") Then Look = TB.Set(Look, options.Look.CursorBox, True)
        EndIf
        Local Box2 = HGui.Gadget:new(#HGUI_BUTTON_GADGET,
                                    { name = NewGad.name .. "_Cursor",
                                      caption = "",
                                      flags = NewGad.flags,
                                      look = Look,
                                      usecache = NewGad.usecache })
        If TB.Item.Exists(options, "cursor") Then Box2:set(options.cursor)
        Box2.Private.IsCursor = True
        Box2.Private.Father   = NewGad
        Box2.CursorHandle     = HGui.Theme.scrollbar.handle
        If TB.Item.Exists(options, "look")
          If TB.Item.Exists(options.look, "handle") Then Box2.CursorHandle = TB.Set(Box2.CursorHandle, options.Look.Handle, True)
        EndIf
        NewGad.Cursor = Box2
        
        ;--- TextAngle ---
        ; Cursor's caption angle.
        If TB.Item.Exists(options, "textangle")
          Box2.look.ntext:set({ angle = options.TextAngle })
          Box2.look.htext:set({ angle = options.TextAngle })
          Box2.look.ptext:set({ angle = options.TextAngle })
          Box2.look.dtext:set({ angle = options.TextAngle })
        EndIf

        ;:: Composite Gadget Building ::
        Local GroupGadgets = { Head, Box2 }
        Local steps          = NewGad.Range[1] - NewGad.Range[0]
        If steps = 0 Then steps = 1
        Local cursorWeight   = NewGad.Range[2] / steps
        Local spacerWeight   = (NewGad.Private.Value - NewGad.Range[0]) / steps

        Box1:layoutSet({ gadgets = GroupGadgets,
                         weights = { spacerWeight, cursorWeight },
                         gap     = 0,
                         type    = NewGad.Orientation,
                         borders = { top = 1, bottom = 1, left = 1, right = 1 }}, False)

        NewGad.init_mode = True
        NewGad:layoutSet({ gadgets = { Box1 },
                           borders = { top = 0, bottom = 0, left = 0, right = 0 }}, False)
        NewGad.init_mode = Nil

        NewGad:Set({ caption = caption }, False)

      ;::: NEW SLIDER ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_SLIDER_GADGET
         ; COMPOSITE GADGET                                                    |
         ; Additional parameters *TriDoc*
         ;    Orientation     #VERTICAL, #HORIZONTAL                           |
         ;    Range           { Minimum, Maximum }                             |
         ;    Value           Current value                                    |
         ;    Outer_Box       Standard options for the outer box (Button)      |
         ;    Cursor          Standard options for the cursor box (Button)     |
         ;    CursorSize      Cursor's weight % of slider size                 |
         ; Additional actions *TriDoc*
         ;    OnChange        Callback function                                |

         DBG.Console.Out("SLIDER Gadget", Nil, HGui.DebugChannel)
         NewGad.Area = HGui.Area:new({ position = position, size = size, active = False, window = NewGad.window }, NewGad, UserData)

         ;::: PARAMETERS :::::::::::::::::::::::::::::::::::::::::::::::::::::::
         ;                                                        :: OnChange ::
         If TB.Item.Exists(options, "actions")
           If TB.Item.Exists(options.actions, "onchange")
             NewGad.Actions.OnChange = options.Actions.OnChange
           EndIf
         EndIf

         ;                                                     :: Orientation ::
         NewGad.Orientation = #HGUI_VERTICAL_LAYOUT
         If TB.Item.Exists(options, "orientation") Then NewGad.Orientation = options.orientation


         ;                                                    :: CursorWeight ::
         NewGad.CursorWeight = 0.05
         If TB.Item.Exists(options, "cursorsize") Then NewGad.CursorWeight = options.CursorSize


         ;                                                           :: Range ::
         ; { LowerValue, HigherValue, CursorRange }                            :
         NewGad.Range = { 1, 100 }
         If TB.Item.Exists(options, "range") Then NewGad.Range = options.range


         ;                                                           :: Value ::
         ; Initial cursor's value, must be:                                    :
         ; Range[0] <= Value <= (Range[1]-Range[2]+1)                          :
         NewGad.Private.Value = 1
         If TB.Item.Exists(options, "value") Then NewGad.Private.Value = options.value

         If NewGad.Private.Value < NewGad.Range[0]
            NewGad.Private.Value = NewGad.Range[0]
         ElseIf NewGad.Private.Value > NewGad.Range[1]
            NewGad.Private.Value = NewGad.Range[1]
         EndIf


         ;                                                       :: Outer_Box ::
         ; Outer Box options (Button).                                         :
         Local Box1 = HGui.Gadget:new(#HGUI_BUTTON_GADGET,
                                     { name = NewGad.name .. "_OuterBox",
                                       caption = "",
                                       look = { nskin = HGui.Theme.Slider.oBox.nskin,
                                                hskin = HGui.Theme.Slider.oBox.hskin,
                                                pskin = HGui.Theme.Slider.oBox.pskin,
                                                dskin = HGui.Theme.Slider.oBox.dskin }})
         If TB.Item.Exists(options, "outer_box") Then Box1:set(options.Outer_Box, False)
         Box1.private.Father = NewGad


         ;                                                          :: Spacer ::
         ; This is an invisible items used as spacer to let the cursor box     |
         ; move along the Outer Box.                                           |
         Local Head = HGui.Gadget:new(#HGUI_BOX_GADGET, { look = { nskin = HGui.Theme.Empty.nSkin }})
         Head.name = NewGad.name .. "_Spacer"
         Head.private.Father = NewGad


         ;                                                          :: Cursor ::
         ; Cursor's box options (Button).                                      :
         Local Box2 = HGui.Gadget:new(#HGUI_BUTTON_GADGET,
                                     { name = NewGad.name .. "_Cursor",
                                       caption = "",
                                       look = { nskin = HGui.Theme.Slider.cBox.nskin,
                                                hskin = HGui.Theme.Slider.cBox.hskin,
                                                pskin = HGui.Theme.Slider.cBox.pskin,
                                                dskin = HGui.Theme.Slider.cBox.dskin,
                                                ntext = HGui.Theme.Slider.cBox.ntext,
                                                htext = HGui.Theme.Slider.cBox.htext,
                                                ptext = HGui.Theme.Slider.cBox.ptext,
                                                dtext = HGui.Theme.Slider.cBox.dtext,
                                                icons = { alignment = #HGUI_ALIGN_CENTER } }})
         If TB.Item.Exists(options, "cursor") Then Box2:set(options.cursor)
         Box2.Private.IsCursor = True
         Box2.Private.Father   = NewGad
         Box2.CursorHandle     = HGui.Theme.Slider.Handle

         ;:: Composite Gadget Building ::
         Local GroupGadgets = { Head, Box2 }

         Local steps          = NewGad.Range[1] - NewGad.Range[0]; + 1
         ;Local spacerWeight   = (NewGad.Private.Value - NewGad.Range[0]) / steps
         Local cursorWeight   = NewGad.CursorWeight
         Local spacerWeight   = HL.Value2Perc({ Newgad.Range[0],
                                                NewGad.Range[1] },
                                                NewGad.Private.Value)*(1-cursorWeight) ;(NewGad.Private.Value - NewGad.Range[0]) / steps

         Box1:layoutSet({ gadgets = GroupGadgets,
                          weights = { spacerWeight, NewGad.cursorWeight },
                          gap     = 0,
                          type    = NewGad.Orientation,
                          borders = { top = 0, bottom = 0, left = 0, right = 0 }}, False)

         NewGad.init_mode = True
         NewGad:layoutSet({ gadgets = { Box1 },
                            borders = { top = 0, bottom = 0, left = 0, right = 0 }}, False)

         NewGad.init_mode = Nil


      ;::: NEW PROGRESSBAR :::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_PROGRESSBAR_GADGET
         ; COMPOSITE GADGET                                                    |
         ; Additional parameters *TriDoc*
         ;    Caption         Cursor text with support for the following tags: |
         ;                    {value}, {value.##}, {intvalue}, {rangestart},   |
         ;                    {rangeend}, {perc}                                   |
         ;    Range           { Minimum, Maximum }                             |
         ;    Value           Current value                                    |
         ;    Outer_Box       Standard options for the outer box (Button)      |
         ;    Cursor          Standard options for the cursor box (Button)     |
         ;    BackText        opzionale, se impostato su True il testo sar√†
         ;                    renderizzato nel container invece che nel cursore
         ;                    ADDED: 01/02/2021

         DBG.Console.Out("PROGRESSBAR Gadget", Nil, HGui.DebugChannel)
         If TB.Item.IsNil(options, "backtext") Then options.backtext = False
         NewGad.backText = options.backText
         
         NewGad.Area = HGui.Area:new({ position = position, size = size, active = False, window = NewGad.window }, NewGad, UserData)

         ;::: PARAMETERS :::::::::::::::::::::::::::::::::::::::::::::::::::::::
         ;                                                         :: Caption ::
         ; Accept special tags:                                                :
         ; {value}, {value.##}, {intvalue}, {rangestart}, {rangeend}, {perc}          :
         Local Caption = ""
         If TB.Item.Exists(options, "caption") Then Caption = options.caption

         ;                                                           :: Range ::
         ; { LowerValue, HigherValue, CursorRange }                            :
         NewGad.Range = { 1, 100 }
         If TB.Item.Exists(options, "range") Then NewGad.Range = options.range

         ;                                                           :: Value ::
         ; Initial cursor's value, must be:                                    :
         ; Range[0] <= Value <= (Range[1]-Range[2]+1)                          :
         NewGad.Private.Value = NewGad.Range[0]
         If TB.Item.Exists(options, "value") Then NewGad.Private.Value = options.value

         If NewGad.Private.Value < NewGad.Range[0]
            NewGad.Private.Value = NewGad.Range[0]
         ElseIf NewGad.Private.Value > NewGad.Range[1]
            NewGad.Private.Value = NewGad.Range[1]
         EndIf

         ;                                                       :: Outer_Box ::
         ; Outer Box options (Button).                                         :
         Local Box1 = HGui.Gadget:new(#HGUI_LABEL_GADGET,
                                     { name = NewGad.name .. "_OuterBox",
                                       caption = "",
                                       look = { nskin = HGui.Theme.Progressbar.oBox.nskin,
                                                ntext = HGui.Theme.Progressbar.cBox.ntext }})
         If TB.Item.Exists(options, "outer_box") Then Box1:set(options.Outer_Box, False)
         Box1.private.Father = NewGad

         ;                                                          :: Cursor ::
         ; Cursor's box options (Button).                                      :
         Local Box2 = HGui.Gadget:new(#HGUI_LABEL_GADGET,
                                     { name = NewGad.name .. "_Cursor",
                                       caption = "",
                                       look = { nskin = HGui.Theme.Progressbar.cBox.nskin,
                                                ntext = HGui.Theme.Progressbar.cBox.ntext }})
         If TB.Item.Exists(options, "cursor") Then Box2:set(options.cursor)
         Box2.Private.Father   = NewGad

         ;:: Composite Gadget Building ::
         Local GroupGadgets = { Box2 }

         ; Corretta la riga qua sotto aggiungendo + 1
         Local steps          = NewGad.Range[1] - NewGad.Range[0] + 1
         Local cursorWeight   = 1
         If steps <> 0 Then cursorWeight = (NewGad.private.value-NewGad.Range[0]) / steps

         Box1:layoutSet({ gadgets = GroupGadgets,
                          weights = { cursorWeight },
                          gap     = 0,
                          type    = #HGUI_HORIZONTAL_LAYOUT,
                          borders = { top = 2, bottom = 2, left = 2, right = 2 }}, False)

         NewGad.init_mode = True
         NewGad:layoutSet({ gadgets = { Box1 },
                            type = #HGUI_HORIZONTAL_LAYOUT,
                            borders = { top = 0, bottom = 0, left = 0, right = 0 }}, False)

         NewGad.init_mode = Nil
         NewGad:Set({ caption = caption }, False)



      ;::: NEW KNOB ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ; Additional parameters *TriDoc*
      ; - CursorSize : Cursor size (>0 and <=1)
      ; - Range : { minValue, maxValue }
      ; - Value : Initial value
      ;
      ; Additional actions
      ; - OnChange
      
      Case #HGUI_KNOB_GADGET
  
         DBG.Console.Out("KNOB Gadget", Nil, HGui.DebugChannel)
         NewGad.Area = HGui.Area:new({ position = position, size = size, active = True, window = NewGad.window,
                                       events = { onmousedown = HGui.gadgetEvent_LMBDown,
                                                  onmouseup   = HGui.gadgetEvent_LMBUp,
                                                  onrightmouseup = HGui.gadgetEvent_RMBUp,
                                                  onmouseover = HGui.gadgetEvent_Over,
                                                  onmouseout  = HGui.gadgetEvent_Out } }, NewGad, UserData)

         ; If no skin has been specified attach the default one
         If TB.Item.IsNil(NewGad.Look, "nskin")
          NewGad.Look.nSkin = HGui.Theme.Knob.nSkin
         EndIf
         NewGad:skinBordersUpdate(NewGad.Look.nSkin)

         ; STYLE
         NewGad.Style = HGui.Theme.Knob.Style

         NewGad.Orientation = #HGUI_HORIZONTAL_LAYOUT

         If TB.Item.Exists(options, "style") Then TB.Set(NewGad.Style, Options.Style, False)


         ;::: PARAMETERS :::::::::::::::::::::::::::::::::::::::::::::::::::::::
         ;                                                        :: OnChange ::
         If TB.Item.Exists(options, "onchange") Then NewGad.Actions.OnChange = options.OnChange

         ;                                                    :: CursorWeight ::
         NewGad.CursorRadius = 0.90
         If TB.Item.Exists(options, "cursorsize") Then NewGad.CursorRadius = options.CursorSize

         ;                                                           :: Range ::
         ; { LowerValue, HigherValue, CursorRange }                            :
         NewGad.Range = { 1, 100 }
         If TB.Item.Exists(options, "range") Then NewGad.Range = options.range

         ;                                                           :: Value ::
         ; Initial cursor's value, must be:                                    :
         ; Range[0] <= Value <= (Range[1]-Range[2]+1)                          :
         NewGad.Private.Value = 1
         If TB.Item.Exists(options, "value") Then NewGad.Private.Value = options.value

         If NewGad.Private.Value < NewGad.Range[0]
            NewGad.Private.Value = NewGad.Range[0]
         ElseIf NewGad.Private.Value > NewGad.Range[1]
            NewGad.Private.Value = NewGad.Range[1]
         EndIf

      ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: NEW TEXT GADGET :::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: 22/06/2020 ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_TEXT_GADGET
        ; Additional parameters *TriDoc*
        ; - gfx : A table to define the text box look (see theme definition)
        ;   .bgColor : Backgroud color
        ;   .fgColor : Foreground color
        ;   .bgCursor : Cursor's background color
        ;   .fgCursor : Cursor's foreground color
        ;   .adjustFontSize : True to automatically adjust the font size to the gadget size
        ; - allowNewLine : True to allow new line/multiline box
        ; - text : Initial text contents
        ; - any other options usuported by the TP Object (NEED MORE DOCS)
        ;
        ; Additional Actions
        ; - OnInputEnd
        ;
        ; Custom Methods *TriDoc*
        ; :GetText()                Shortcut to gad.TextObj:GetText()
        ; :SetText(value)           Shortcut to gad.TextObj:SetText()
        ;
        ; NOTES *TriDoc*
        ;   The textObj is stored in gadObj.textObj

        DBG.Console.Out("TEXT Gadget", Nil, HGui.DebugChannel)
        NewGad.Area = HGui.Area:new(
          { position = position, 
            size     = size, 
            active   = True, 
            window   = NewGad.window,
            events = { onmousedown    = HGui.gadgetEvent_LMBDown,
                       onmouseup      = HGui.gadgetEvent_LMBUp,
                       onrightmouseup = HGui.gadgetEvent_RMBUp,
                       onmouseover    = HGui.gadgetEvent_Over,
                       onmouseout     = HGui.gadgetEvent_Out } 
            }, 
          NewGad, 
          UserData)

          
        ; Setup Skin
        Local s = { "nskin", "hskin", "pskin", "dskin" }
        For i, v In Pairs(s)
          ; If no skin has been specified attach the default theme
          If TB.Item.IsNil(NewGad.Look, v)
            NewGad.Look[v] = HGui.Theme.Text[v]
          EndIf
          NewGad:skinBordersUpdate(NewGad.Look[v])
        Next
                                
        ; Text Object creation & skin
        If IsNil(options) Then options = { }
        Local theme = HGui.Theme.Text.Gfx
        If TB.Item.Exists(options, "gfx")
          theme = CopyTable(theme)
          TB.Set(theme, options.Gfx)
          options.Gfx = theme
        Else
          options.Gfx = HGui.Theme.Text.Gfx
        EndIf
        
        /*
        If TB.Item.IsNil(options, "text")
          options.text = ""
        EndIf
        */

        NewGad.TextObj = TP:NewObject(options)
        NewGad.TextObj.gfx.area = 
          { x = NewGad.Area.Position.x, 
            y = NewGad.Area.Position.y,
            w = NewGad.Area.Size.w,
            h = NewGad.Area.Size.h }

        ; Actions
        NewGad.TextObj.Actions.OnUnactivate = HGui.gadgetEvent_TextOnInputEnd
        NewGad.TextObj._HGuiObject = NewGad
        NewGad.TextObj.Father = NewGad

        ; - OnInputEnd
        If TB.Item.Exists(options, "actions")
          If TB.Item.Exists(options.actions, "oninputend")
            NewGad.Actions.OnInputEnd = options.actions.OnInputEnd
          EndIf
        EndIf
         
        ; METHODS
        
        NewGad.GetText = 
          Function(gad)
            Return(gad.TextObj:GetText())
          EndFunction
        
        NewGad.SetText =
          Function(gad, value)
            gad.TextObj:SetText(value, False)
            gad:Render()
          EndFunction
        
        ;options.OnUnactivate = Function() NewGad:Render(True) EndFunction

      ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      ;::: NEW LISTVIEW ::::::::::::::::::::::::::::::::::::::::: 18.10.2022 ::
      Case #HGUI_LISTVIEW_GADGET
        ; Complex gadget composed by sub gadgets as follow:
        ;
        ; - OuterBox (Box)
        ;   Horizontal
        ;   - Body (Box)
        ;     Vertical
        ;     - TopBox (Box)
        ;       Horizontal
        ;       - Headers (Buttons)
        ;     - ListArea (Box)
        ;   - VScroller (Scroller)
        ;
        ; Additional parameters *TriDoc*
        ; - Data                 A table to specify the gadget contents
        ;   .selected            A table used to specify the selected items (True = selected)
        ;   .alignments          A table used to specify for each column the alignment
        ;   .columnSizes         A table to specify each column size in pixels
        ;   .headers             A table to specify each column title/header
        ;   .items               A table to store the data to show
        ;   .sortOrder           A table to specify for each column the sorting order
        ;   .icons               A table to specify for each record an optional icon
        ;   .columnHandlers      A table to specify for each column a convertion function to display
        ;                        converted/formatted data instead of the raw data.
        ;
        ; - OuterBox_Borders     Distance between main container and its internal gadgets
        ; - VScrollerGap         Distance between contents area and the vertical scroller
        ; - ScrollerSize         Scrollers size in pixels (override the theme)
        ; - HeadersHeight        Height of the column headers (override the theme)
        ; - VerticalGap          Distance between all vertical items (top, body, horizontal scroller)
        ; - Vertical_Borders     Distance between all internal items (top, body, horizontal scroller)
        ; - ColumnsGap           Distance between column headers (override theme)
        ; - ColumnsBorders       Distance between column headers borders
        ; - Borders              Gadget's borders
        ; - VLines               Vertical lines between the columns TRUE|FALSE
        ; - VLinesColor1         Most left line color
        ; - VLinesColor2         Most right line color
        ; - Multiselect          Allow multiple row selection TRUE|FALSE
        ; - FontName             Font name
        ; - FontSizeOffset       Adjust font size, usefull for multiline cells
        ; - FontStyle            Font style
        ; - FontColor            Font color (unselected)
        ; - EntryHeight          Height in pixels of a single row & base font size
        ; - AlternateLines       Alternate lines bg color (TRUE|FALSE)
        ; - HeadersOFF           True to hide column headers
        ; - HScrollerOFF         True to hide the horizontal scroller, le colonne saranno ridimensionate per riempire lo spazio disponibile
        ; - VScrollerOFF         True to hide the vertical scroller
        ; - WheelPageQualifier   Override default page key qualifier (LSHIFT)
        ; - WheelSEQualifier     Override default start/end key qualifier (LCTRL)
        ; - IconsSizeOffset      +/- size offset
        ; - IconsXOffset         +/- position offset
        ; - IconsAsBackground    True/False
        ; - IconsMaximize        True/False
        ; - IconsTextGap         Distance between icon and text
        ; - IconsFixedTextOffset True/False -> IconsTextGap
        ; - ResizeableColumns    True/False -> default True
        ; - Wordwrap             True/False -> Allow wordwrap (default false)
        ;
        ; Additional methods *TriDoc*
        ;   :SelectAll(Refresh)      Select all list items (only for multiselectable items)
        ;   :UnselectAll(Refresh)    Deselect any selected item
        ;   :DeselectAll(Refresh)    -- Same as UnselectAll()
        ;   :RemoveAll(Refresh)      Remove all items from the list
        ;   :RemoveSelected(Refresh) Remove selected items from the list
        ;   :Get()                   Retrieves the item list and the selected list
        ;   :Insert(rec,idx,sel,refresh) Insert an item to the list
        ;   :SetItems(itemsList, refresh) Update the entire data set, it is a
        ;                                 shortcut to :Set({ data = { items = ... }})
        ;   :rebuildLayout()         Rigenera l'intero layout del listview
        ;
        ; Additional Actions *TriDoc*
        ; - OnInsert
        ; - OnChange
        ; - OnSelect
        ; - OnUnselect    / - OnDeselect   are the same
        ;
        ; ---------------------------------------------------------------------
        DBG.Console.Out("New Listview", DBG.Hilight, HGui.DebugChannel)

        ; Check if there are selected items otherwise generate an empty table
        If TB.Item.IsNil(options.data, "selected")
          options.data.selected = {}
          Local count = ListItems(options.data.Items)
          For Local i = 0 To count-1 Do options.data.selected[i] = False
        EndIf
        
        ; Check if there are alignments specified otherwise align all to the left
        If TB.Item.IsNil(options.data, "alignments")
          options.data.alignments = {}
          Local count = ListItems(options.data.Headers)
          For Local i = 0 To count-1 Do options.data.alignments[i] = #HGUI_ALIGN_LEFT
        EndIf
         
         
        NewGad.Wordwrap = False
        If TB.Item.Exists(options, "wordwrap") Then NewGad.Wordwrap = options.Wordwrap
         
        NewGad.ResizeableColumns = True
        If TB.Item.Exists(options, "resizeablecolumns") Then NewGad.ResizeableColumns = options.ResizeableColumns
         
        NewGad.IconsXOffset = 0
        If TB.Item.Exists(options, "iconsxoffset") Then NewGad.IconsXOffset = options.IconsXOffset
         
        NewGad.IconsFixedTextOffset = False
        If TB.Item.Exists(options, "iconsfixedtextoffset") Then NewGad.IconsFixedTextOffset = options.IconsFixedTextOffset
         
        NewGad.IconsAsBackground = False
        If TB.Item.Exists(options, "iconsasbackground") Then NewGad.IconsAsBackground = options.IconsAsBackground
         
        NewGad.IconsMaximize = False
        If TB.Item.Exists(options, "iconsmaximize") Then NewGad.IconsMaximize = options.IconsMaximize
         
        NewGad.IconsSizeOffset = 0
        If TB.Item.Exists(options, "iconssizeoffset") Then NewGad.IconsSizeOffset = options.IconsSizeOffset
         
        NewGad.WheelPageQualifier = "LSHIFT"
        If TB.Item.Exists(options, "wheelpagequalifier") Then NewGad.WheelPageQualifier = options.WheelPageQualifier
         
        NewGad.WheelSEQualifier = "LCONTROL"
        If TB.Item.Exists(options, "wheelsequalifier") Then NewGad.WheelSEQualifier = options.WheelSEQualifier
         
        NewGad.OuterBox_Borders = { top = 0, bottom = 0, left = 0, right = 0 }
        If TB.Item.Exists(options, "outerbox_borders") Then TB.Set(NewGad.OuterBox_Borders, options.OuterBox_Borders, False)
         
        NewGad.OuterBox_Gap = 1
        If TB.Item.Exists(options, "vscrollergap") Then NewGad.OuterBox_Gap = options.VScrollerGap
         
        NewGad.VGap = 0
        If TB.Item.Exists(options, "vgap") Then NewGad.VGap = options.VerticalGap
         
        NewGad.VBorders = { top = 0, bottom = 0, left = 0, right = 0 }
        If TB.Item.Exists(options, "vertical_borders") Then TB.Set(NewGad.VBorders, options.Vertical_Borders, False)
                  
        NewGad.ColumnsBorders = { top = 0, bottom = 0, left = 0, right = 0 }
        If TB.Item.Exists(options, "columns_borders") Then TB.Set(NewGad.ColumnsBorders, options.Columns_Borders, False)
         
        NewGad.Borders = { top = 0, bottom = 0, left = 0, right = 0 }
        If TB.Item.Exists(options, "borders") Then TB.Set(NewGad.Borders, options.Borders, False)
         
        NewGad.Multiselect = True
        If TB.Item.Exists(options, "multiselect") Then NewGad.Multiselect = options.Multiselect
         
        NewGad.HeadersOFF = False
        If TB.Item.Exists(options, "headersoff") Then NewGad.HeadersOFF = options.HeadersOFF
         
        NewGad.HScrollerOFF = False
        If TB.Item.Exists(options, "hscrolleroff") Then NewGad.HScrollerOFF = options.HScrollerOFF
         
        NewGad.VScrollerOFF = False
        If TB.Item.Exists(options, "vscrolleroff") Then NewGad.VScrollerOFF = options.VScrollerOFF
         
        ;--- Themeable at runtime --
        NewGad.IconsTextGap = HGui.Theme.ListView.IconTextGap
        If TB.Item.Exists(options, "iconstextgap") Then NewGad.IconsTextGap = options.IconsTextGap
         
        NewGad.ScrollerSize = HGui.Theme.ListView.Scrollbar.Size
        If TB.Item.Exists(options, "scrollersize") Then NewGad.ScrollerSize = options.ScrollerSize
         
        NewGad.TopBoxSize = HGui.Theme.ListView.HeadersHeight
        If TB.Item.Exists(options, "headersheight") Then NewGad.TopBoxSize = options.HeadersHeight
         
        NewGad.ColumnsGap = HGui.Theme.ListView.ColumnsGap
        If TB.Item.Exists(options, "columnsgap") Then NewGad.ColumnsGap = options.ColumnsGap   
         
        NewGad.VLinesColor1 = HGui.Theme.ListView.VLinesColor1
        If TB.Item.Exists(options, "vlinescolor1") Then NewGad.VLinesColor1 = options.VLinesColor1
         
        NewGad.VLinesColor2 = HGui.Theme.ListView.VLinesColor2
        If TB.Item.Exists(options, "vlinescolor2") Then NewGad.VLinesColor2 = options.VLinesColor2
         
        NewGad.VLines = HGui.Theme.ListView.VerticalLines
        If TB.Item.Exists(options, "vlines") Then NewGad.VLines = options.VLines
         
        NewGad.FontName = HGui.Theme.ListView.Font.Name
        If TB.Item.Exists(options, "fontname") Then NewGad.FontName = options.FontName
         
        NewGad.FontSizeOffset = HGui.Theme.ListView.Font.SizeOffset
        If TB.Item.Exists(options, "fontsizeoffset") Then NewGad.FontSizeOffset = options.FontSizeOffset
         
        NewGad.FontStyle = HGui.Theme.ListView.Font.Style
        If TB.Item.Exists(options, "fontstyle") Then NewGad.FontStyle = options.FontStyle
         
        NewGad.FontColor = HGui.Theme.ListView.Font.Color
        If TB.Item.Exists(options, "fontcolor") Then NewGad.FontColor = options.FontColor
         
        NewGad.EntryHeight = HGui.Theme.ListView.EntryHeight
        If TB.Item.Exists(options, "entryheight") Then NewGad.EntryHeight = options.EntryHeight
         
        NewGad.AlternateLines = HGui.Theme.ListView.AlternateLines
        If TB.Item.Exists(options, "alternatelines") Then NewGad.AlternateLines = options.AlternateLines
         
        NewGad.ListAreaBG1 = HGui.Theme.ListView.BGColors.Odd
        If TB.Item.Exists(options, "bgcolor1") Then NewGad.ListAreaBG1 = options.BGColor1
         
        NewGad.ListAreaBG2 = HGui.Theme.ListView.BGColors.Even
        If TB.Item.Exists(options, "bgcolor2") Then NewGad.ListAreaBG2 = options.BGColor2
         
        NewGad.SelectedFontColor  = HGui.Theme.ListView.Selected.FontColor
        NewGad.SelectedListAreaBG = HGui.Theme.ListView.Selected.BGColor         
        ;---

        ; Copy the data into the columns
        ; NewGad.ListViewData
        ;  .ColumnSizes
        ;  .Headers
        ;  .Alignments (optional)
        ;  .Items
        ;  .Selected
        ;  .SortOrder
        ;  .Icons
        ;  .ColumnHandlers <-- conversion funcs        
        NewGad.Data = CopyTable(options.Data)
        If TB.Item.Exists(options, "icons") Then NewGad.Icons = CopyTable(options.Icons)
        NewGad.FirstVisible = 0

        ; EVENTS
        If TB.Item.Exists(options, "oninsert") Then NewGad.OnInsert = options.OnInsert
        If TB.Item.Exists(options, "onchange") Then NewGad.OnChange = options.OnChange
        If TB.Item.Exists(options, "onselect") Then NewGad.OnSelect = options.OnSelect
        If TB.Item.Exists(options, "onunselect") Then NewGad.OnUnSelect = options.OnUnSelect
        If TB.Item.Exists(options, "ondeselect") Then NewGad.OnUnSelect = options.OnDeselect

        NewGad.Area = HGui.Area:new({ position = position,
                                      size     = size,
                                      active   = False,
                                      window   = NewGad.window }, NewGad, UserData)

        ;:: OuterBox (Box) ::
        ;::::::::::::::::::::
        NewGad.OuterBox = HGui.Gadget:new(#HGUI_BOX_GADGET,
                                         { name = NewGad.name .. "_OuterBox",
                                           look = { nskin = HGui.Theme.ListView.OuterBox.nskin }})
        NewGad.OuterBox:skinBordersUpdate(NewGad.OuterBox.Look.nSkin)
        NewGad.OuterBox.private.Father = NewGad

        ;:: Body (Box) ::
        ;::::::::::::::::
        NewGad.Body = HGui.Gadget:new(#HGUI_BOX_GADGET,
                                     { name = NewGad.name .. "_Body",
                                       look = { nskin = HGui.Theme.ListView.Body.nskin }})
        NewGad.Body:skinBordersUpdate(NewGad.Body.Look.nSkin)
        NewGad.Body.private.Father = NewGad

        ;:: TopBox (Box) ::
        ;::::::::::::::::::
        NewGad.TopBox = HGui.Gadget:new(#HGUI_BOX_GADGET,
                                       { name = NewGad.name .. "_TopBox",
                                         caption = "",
                                         look = { nskin = HGui.Theme.ListView.TopBox.nskin }})

        ;:: Headers (Buttons) ::
        ;:::::::::::::::::::::::
        NewGad.Headers = {}
        Local count = ListItems(NewGad.Data.Headers)

        For Local i = 0 To count-1
          NewGad.Headers[i] = HGui.Gadget:new(
            #HGUI_BUTTON_GADGET,
            { caption = NewGad.Data.Headers[i],
              Look = { nskin = HGui.Theme.ListView.nskin,
                       hskin = HGui.Theme.ListView.hskin,
                       pskin = HGui.Theme.ListView.pskin,
                       dskin = HGui.Theme.ListView.dskin,
                       ntext = HGui.Theme.ListView.ntext,
                       htext = HGui.Theme.ListView.htext,
                       ptext = HGui.Theme.ListView.ptext,
                       dtext = HGui.Theme.ListView.dtext },
              Flags = { Visible = Not(NewGad.HeadersOFF) } 
              })
           ; Setup some custom fields
          NewGad.Headers[i].Father = NewGad
          NewGad.Headers[i].IsListViewHeader = True
          NewGad.Headers[i].ColumnNumber = i
          NewGad.Headers[i].DescendingSort = False
        Next

        ;:: Column Handlers ::
        ;:::::::::::::::::::::
        NewGad.ColumnHandlers = {}
        If TB.Item.IsNil(options.data, "columnhandlers")
          options.data.ColumnHandlers = {}
        EndIf
        
        ; Setup the conversion functions if specified otherwise setup default functions
        Local i, v
        For i, v In Pairs(NewGad.Headers)
          If Not(HaveItem(options.data.ColumnHandlers, i))
            NewGad.ColumnHandlers[i] = Function(value) Return(value) EndFunction
          Else
            NewGad.ColumnHandlers[i] = options.data.ColumnHandlers[i]
          EndIf
        Next
         
        ; Initial data sorting
        If TB.Item.Exists(NewGad.Data, "sortorder")
          Local count = TB.Count(NewGad.Data.sortOrder.Columns)
          For Local i = 0 To count-1 Do NewGad.Data.sortOrder.Descending[i] = Not(NewGad.Data.sortOrder.Descending[i])
          If count > 0
            DisableLineHook()
            TB.Sort(NewGad.Data.Items,
                    NewGad.Data.sortOrder.Descending,
                    NewGad.Data.sortOrder.Columns,
                    { NewGad.Data.Selected })
            EnableLineHook()
          EndIf
          For Local i = 0 To ListItems(NewGad.Data.sortOrder.Columns)-1
            Local col = NewGad.Data.sortOrder.Columns[i]
            NewGad.Headers[col].DescendingSort = NewGad.Data.sortOrder.Descending[i]
          Next
        EndIf

        ; This line below has been commented (18/10/22) because seems useless
        ; If TB.Item.IsNil(NewGad.Look, "ntext") Then NewGad.Look.nText = HGui.Theme.Button.nText
        
        ;:: ListArea (Box) ::
        ;::::::::::::::::::::
        NewGad.ListArea = HGui.Gadget:new(#HGUI_BOX_GADGET,
                                          { name = NewGad.name .. "_ListArea",
                                            look = { nskin = HGui.theme.button.nskin }})
        ; Attaches the events to the contents area
        NewGad.ListArea.Area:set({ active = True, window = NewGad.window,
                                   events = { onmousedown = HGui.listViewContentEvent_LMBDown,
                                              onmouseup   = HGui.listViewContentEvent_LMBUp,
                                              onmouseover = HGui.listViewContentEvent_Over,
                                              onmouseout  = HGui.listViewContentEvent_Out } }, NewGad.ListArea)

        ; If there are custom options then applies them to the Area object
        If TB.Item.Exists(options, "listarea") Then NewGad.ListArea:set(options.ListArea, False)
        
        NewGad.ListArea:skinBordersUpdate(NewGad.ListArea.Look.nSkin)
        NewGad.ListArea.private.Father = NewGad
        NewGad.ListArea.IsListViewContents = True
        
        ;:: VScroller (Scrollbar) ::
        ;:::::::::::::::::::::::::::
        If Not(NewGad.VScrollerOFF)
          ; Vertical scroller enabled
          NewGad.VScroller = HGui.Gadget:new(
            #HGUI_SCROLLBAR_GADGET,
            { name = NewGad.name .. "_VScroller",
              range = { 1, 0, 1 },
              OnChange = HGui.ListView_VScrollerUpdate,
              orientation = #HGUI_VERTICAL_LAYOUT,
              caption = "",
              flags = { visible = Not(NewGad.VScrollerOFF) },
              Look = { OuterBox = HGui.Theme.ListView.Scrollbar.oBox,
              CursorBox = HGui.Theme.ListView.Scrollbar.cBox,
              Handle = HGui.Theme.ListView.Scrollbar.Handle }
              })
              
          ; If there are custom options applies them to the vertical scroller
          If TB.Item.Exists(options, "vscroller") Then NewGad.VScroller:set(options.VScroller, False)
          NewGad.VScroller.private.Father = NewGad
        EndIf
        
        ;:: HScroller (Scrollbar) ::
        ;:::::::::::::::::::::::::::
        If Not(NewGad.HScrollerOFF)
          NewGad.HScroller = HGui.Gadget:new(
            #HGUI_SCROLLBAR_GADGET,
            { name = NewGad.name .. "_HScroller",
              range = { 1, 1, 1 },
              value = 1,
              OnChange = HGui.ListView_HScrollerUpdate,
              orientation = #HGUI_HORIZONTAL_LAYOUT,
              caption = "",
              flags = { visible = Not(NewGad.HScrollerOFF) },
              Look = { OuterBox = HGui.Theme.ListView.Scrollbar.oBox,
              CursorBox = HGui.Theme.ListView.Scrollbar.cBox,
              Handle = HGui.Theme.ListView.Scrollbar.Handle }
              })
              
          ; If there are custom options applies them to the horizontal scrollbar
          If TB.Item.Exists(options, "hscroller") Then NewGad.HScroller:set(options.HScroller, False)
          NewGad.HScroller.private.Father = NewGad
        EndIf
        
        ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        ;::: CUSTOM METHODS :::::::::::::::::::::::::::::::::::::::::::::::::::
        ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        ; :SelectAll(Refresh) -- solo se multiselect = true
        ; ----------------------
        ;  Select all entries and refresh the control, if you set the <refresh>
        ;  to False the control will not be refreshed
        ;  Items will be selected only if Multiselct is True
        NewGad.SelectAll = 
          Function(NewGad, Refresh)
            If Not(NewGad.Multiselect) Then Return()
            If IsNil(Refresh) Then Refresh = True
            For Local i = 0 To ListItems(NewGad.Data.Items)-1
              NewGad.Data.Selected[i] = True
            Next
            If Refresh Then NewGad:Render()
          EndFunction

        ; :UnselectAll(Refresh) --
        ; ------------------------
        ;  Unselect all entries and refresh the control, if you set the <refresh>
        ;  to False the control will not be refreshed
        NewGad.UnselectAll = 
          Function(NewGad, Refresh)
            If IsNil(Refresh) Then Refresh = True
            For Local i = 0 To ListItems(NewGad.Data.Items)-1
              NewGad.Data.Selected[i] = False
            Next
            If Refresh Then NewGad:Render()
        EndFunction

        ; :DesectAll(Refresh) --
        ; ----------------------
        NewGad.DeselectAll = NewGad.UnselectAll
        
        ; :RemoveAll(Refresh) --
        ; ----------------------
        ; Remove all entries
        NewGad.RemoveAll = 
          Function(NewGad, Refresh)
            If IsNil(Refresh) Then Refresh = True
            NewGad.Data.Items = {}
            NewGad.Data.Selected = {}
            If Refresh Then NewGad:Render()
          EndFunction
                           
        ; :RemoveSelected(Refresh) --
        ; ---------------------------
        ; Remove all selected entries from the list.
        NewGad.RemoveSelected = 
          Function(NewGad, Refresh)
            If IsNil(refresh) Then Refresh = True
            For Local i = ListItems(NewGad.Data.Items)-1 To 0 Step -1
              If NewGad.Data.Selected[i]
                RemoveItem(NewGad.Data.Selected, i)
                RemoveItem(NewGad.Data.Items, i)
              EndIf
            Next
            If Refresh Then NewGad:Render()
        EndFunction
                                
        ; :SetItems(Items, Refresh) --
        ; ----------------------------
        ; Shortcut to update the data set
        Newgad.SetItems = 
          Function(NewGad, items, refresh)
            NewGad:Set({ data = { items = items } }, refresh)
          EndFunction
    
        ; :Get() --
        ; ---------
        ; Retrieve informations about the listview
        ; Returns and array with all the items and an array with the item's selected status
        Newgad.Get = 
          Function(NewGad)
            Return(NewGad.Data.Items, NewGad.Data.Selected)
          EndFunction

        ; :Insert(record, index, select, refresh) --
        ; ------------------------------------------
        Function NewGad:Insert(record, index, select, refresh)
          ; Insert the given record at the 'index' position, if no index
          ; is specified it will be inserted at the end of the list.
          ; If select = True this item will be automatically selected
          If IsNil(index) Then index = -1
          If IsNil(select) Then select = False
          If IsNil(refresh) Then refresh = False
          InsertItem(NewGad.Data.Items, record, index)
          InsertItem(NewGad.Data.Selected, False, index)
          If index = -1 Then index = ListItems(NewGad.Data.Items)-1
          If select
            NewGad:set(
              { Data = 
                { Selected = index, Mode = "add" }
                }, False)
          EndIf

          ; Evento OnInsert()
          If TB.Item.Exists(NewGad.Actions, "oninsert")
            NewGad.OnInsert(self, record, index)
          EndIf
          If refresh Then NewGad:Render()
        EndFunction
          
        ;:: Method to assemble the control layout ::
        ;:::::::::::::::::::::::::::::::::::::::::::
        NewGad._firstBuild = True
         
        NewGad.rebuildLayout =
          Function(NewGad)
            Local ScrWidth, ScrHeight = GFX.GetHostSize()
            Local winWidth, WinHeight = NewGad.Window.Size.w, NewGad.Window.Size.h

            ;*** TEST : Setup Right side and vscroller ***     
            Local workSpace = NewGad.Area.Size.w
            ScrollerSizePerc = NewGad.ScrollerSize ; HGui.Theme.ListView.Scrollbar.Size
            If NewGad.VScrollerOFF Then ScrollerSizePerc = 0.0001           
            w1 = workSpace - ScrollerSizePerc
            ScrollerSizePerc = -ScrollerSizePerc/NewGad.Area.Size.w
            w1 = 1 + ScrollerSizePerc
            ;************
            If Not(NewGad.VScrollerOFF)
              NewGad.OuterBox:layoutSet({ gadgets = { NewGad.Body, NewGad.VScroller },
                                          weights = { w1, ScrollerSizePerc },
                                          gap     = NewGad.OuterBox_Gap,
                                          type    = #HGUI_HORIZONTAL_LAYOUT,
                                          borders = NewGad.OuterBox_Borders })

            Else
              NewGad.OuterBox:layoutSet({ gadgets = { NewGad.Body },
                                          weights = { 1 },
                                          gap     = NewGad.OuterBox_Gap,
                                          type    = #HGUI_HORIZONTAL_LAYOUT,
                                          borders = NewGad.OuterBox_Borders })
            EndIf
                 
            ;*** TEST : Setup Headers, contents and hscroller ***
            Local workSpace = NewGad.Area.Size.h
            ScrollerSizePerc = NewGad.ScrollerSize ; HGui.Theme.ListView.Scrollbar.Size
            If NewGad.HScrollerOFF Then ScrollerSizePerc = 0.0001           
            TopBoxSizePerc = Newgad.TopBoxSize ; HGui.Theme.ListView.HeadersHeight
            If NewGad.HeadersOFF Then TopBoxSizePerc = 0.0001
            w1 = workSpace - ScrollerSizePerc - TopBoxSizePerc
            ScrollerSizePerc = -ScrollerSizePerc/NewGad.Area.Size.h
            TopBoxSizePerc   = -TopBoxSizePerc/NewGad.Area.Size.h
            w1 = 1 + ScrollerSizePerc + TopBoxSizePerc
            ;************
      
            If Not(NewGad.HScrollerOff)    
              NewGad.Body:layoutSet({ gadgets = { NewGad.TopBox, NewGad.ListArea, NewGad.HScroller },
                                      weights = { TopBoxSizePerc, w1, ScrollerSizePerc },
                                      gap     = NewGad.VGap,
                                      type    = #HGUI_VERTICAL_LAYOUT,
                                      borders = NewGad.VBorders})
            Else                                 
              NewGad.Body:layoutSet({ gadgets = { NewGad.TopBox, NewGad.ListArea },
                                      weights = { TopBoxSizePerc, w1 },
                                      gap     = NewGad.VGap,
                                      type    = #HGUI_VERTICAL_LAYOUT,
                                      borders = NewGad.VBorders})
            EndIf

            NewGad.TopBox:layoutSet({ gadgets = NewGad.Headers,
                                      weights = NewGad.Data.ColumnSizes,
                                      gap     = NewGad.ColumnsGap,
                                      type    = #HGUI_HORIZONTAL_LAYOUT,
                                      borders = NewGad.ColumnsBorders })

            NewGad:layoutSet({ gadgets = { NewGad.OuterBox },
                               weights = { 1 },
                               gap     = 0,
                               type    = #HGUI_HORIZONTAL_LAYOUT,
                               borders = NewGad.Borders })
          EndFunction
         
          NewGad:rebuildLayout()

        ;NewGad.Init_Mode = Nil


      ;::: NEW TREEVIEW ::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_TREEVIEW_GADGET
        ; Gadget composta con la seguente struttura
        ; - OuterBox (Box)
        ;   Horizontal
        ;   - Body (Box)
        ;     Vertical
        ;     - TopBox (Box)
        ;       Horizontal
        ;       - Headers (Buttons)
        ;     - ListArea (Box)
        ;   - VScroller (Scroller)
        ;
        ; Additonal parameters *TriDoc*
        ; :: Data
        ;   .ColumnSizes
        ;   .Headers
        ;   .Items   <-- campi aggiuntivi per ogni item
        ;     ._Childs (opzionale)
        ;     ._Selected (True|False)
        ;     ._Opened (True|False)
        ;   .SortOrder
        ;   .Alignments
        ;   .columnHandlers
        ; :: OuterBox_Borders : distanze tra il contenitore principale e i gadget interni.
        ; :: VScrollerGap : distanza fra i contenuti e lo scroller verticale
        ; :: ScrollerSize : dimensione in pixel degli scroller
        ; :: ColumnHeight : altezza in pixel della barra delle intestazioni
        ; :: VerticalGap : distanza fra gli elementi verticali (top, body, hscroller)
        ; :: Vertical_Borders : distanza tra i bordi degli elementi interni (top, body, hscroller)
        ; :: ColumnsGap : distanza tra le intestazioni di colonne
        ; :: ColumnsBorders : distanza tra i bordi delle intestazioni di colonna
        ; :: Borders : Bordi dell'intero gadget
        ; :: VLines : vertical lines between the columns TRUE|FALSE
        ; :: VLinesColor1 : most left line color
        ; :: VLinesColor2 : most right line color
        ; :: Multiselect : allow multiple row selection TRUE|FALSE
        ; :: AutoSelectChilds : Auto-select item's childs
        ; :: AutoUnselectChilds : Auto-unselect item's childs
        ; :: FontName : font name
        ; :: FontSizeOffset : adjust font size, usefull for multiline cells
        ; :: FontStyle : font style
        ; :: FontColor : font color (unselected)
        ; :: EntryHeight : height in pixels of a single row & base font size
        ; :: AlternateLines : alternate loine bg color (TRUE|FALSE)
        ; :: OnChange : Callback on treeview selection change (excluding automatic childs selections)
        ; :: OnSelect : Callback on every treeview select (including childs)
        ; :: OnUnselect : Callback on every treeview unselect (including childs)
        ; :: OCStyle : Open/Close style (1=Box, 2=Arrows)
        ; :: SelectGroups : Enable/Disable group selection (default = True)
         
        ; -> HeadersOFF
        ; -> HScrollerOFF
        ; -> VScrollerOFF
        ; -> WheelPageQualifier
        ; -> WheelSEQualifier
        ; -> IconsSizeOffset
        ; -> IconsXOffset
        ; -> IconsAsBackground
        ; -> IconsMaximize
        ; -> IconsTextGap
        ; -> IconsFixedTextOffset
        ; -> ResizeableColumns
        ;
        ; Additional Actions *TriDoc*
        ;   OnChange
        ;   OnSelect
        ;   OnUnselect / OnDeselect
        ;
        ; Additional Methods *TriDoc*
        ; :Get()
        ; :RebuildLayut()
        ; :SelectAll(Refresh)
        ; :UnselectAll(Refresh)
        ; :DeselectAll(Refresh)
        ; :RemoveAll(Refresh)
        ; :RemoveSelected(Refresh)
        ; :SetItems(Items, Refresh)
        ; :Insert(Record, Index, Select, Refresh)
        ; :Remove(Index, refresh)
        ; :OpenNodes(refresh)
        ; :CloseNodes(refresh)
        ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::        
        
        DBG.Console.Out("New Treeview", Nil, HGui.DebugChannel)

        ; Copia i dati delle colonne
        ; NewGad.ListViewData
        ;                    .ColumnSizes
        ;                    .Headers
        ;                    .Items   <-- campi aggiuntivi per ogni item
        ;                          ._Childs (opzionale)
        ;                          ._Selected (True|False)
        ;                          ._Opened (True|False)
        ;                    .SortOrder
        ;
        options.data.realItems = HGui.treeView_ElaborateList(options.data.items)

        ;-----

        ; Check if there are alignments specified otherwise align all to the left
        If TB.Item.IsNil(options.data, "alignments")
          options.data.alignments = {}
          Local count = ListItems(options.data.Headers)
          For Local i = 0 To count-1 Do options.data.alignments[i] = #HGUI_ALIGN_LEFT
        EndIf
        
        NewGad.SelectGroups = True
        If TB.Item.Exists(options, "selectgroups") Then NewGad.SelectGroups = options.SelectGroups
         
        NewGad.ResizeableColumns = True
        If TB.Item.Exists(options, "resizeablecolumns") Then NewGad.ResizeableColumns = options.ResizeableColumns
        
        NewGad.IconsXOffset = 0
        If TB.Item.Exists(options, "iconsxoffset") Then NewGad.IconsXOffset = options.IconsXOffset
        
        NewGad.IconsFixedTextOffset = False
        If TB.Item.Exists(options, "iconsfixedtextoffset") Then NewGad.IconsFixedTextOffset = options.IconsFixedTextOffset
                
        NewGad.IconsAsBackground = False
        If TB.Item.Exists(options, "iconsasbackground") Then NewGad.IconsAsBackground = options.IconsAsBackground
        
        NewGad.IconsMaximize = False
        If TB.Item.Exists(options, "iconsmaximize") Then NewGad.IconsMaximize = options.IconsMaximize
        
        NewGad.IconsSizeOffset = 0
        If TB.Item.Exists(options, "iconssizeoffset") Then NewGad.IconsSizeOffset = options.IconsSizeOffset
        
        NewGad.WheelPageQualifier = "LSHIFT"
        If TB.Item.Exists(options, "wheelpagequalifier") Then NewGad.WheelPageQualifier = options.WheelPageQualifier
        
        NewGad.WheelSEQualifier = "LCONTROL"
        If TB.Item.Exists(options, "wheelsequalifier") Then NewGad.WheelSEQualifier = options.WheelSEQualifier
        
        NewGad.OuterBox_Borders = { top = 0, bottom = 0, left = 0, right = 0 }
        If TB.Item.Exists(options, "outerbox_borders") Then TB.Set(NewGad.OuterBox_Borders, options.OuterBox_Borders, False)
        
        NewGad.OuterBox_Gap = 1
        If TB.Item.Exists(options, "vscrollergap") Then NewGad.OuterBox_Gap = options.VScrollerGap
        
        NewGad.VGap = 0
        If TB.Item.Exists(options, "vgap") Then NewGad.VGap = options.VerticalGap

        NewGad.VBorders = { top = 0, bottom = 0, left = 0, right = 0 }
        If TB.Item.Exists(options, "vertical_borders") Then TB.Set(NewGad.VBorders, options.Vertical_Borders, False)

        NewGad.ColumnsBorders = { top = 0, bottom = 0, left = 0, right = 0 }
        If TB.Item.Exists(options, "columns_borders") Then TB.Set(NewGad.ColumnsBorders, options.Columns_Borders, False)

        NewGad.Borders = { top = 0, bottom = 0, left = 0, right = 0 }
        If TB.Item.Exists(options, "borders") Then TB.Set(NewGad.Borders, options.Borders, False)

        NewGad.Multiselect = False
        If TB.Item.Exists(options, "multiselect") Then NewGad.Multiselect = options.Multiselect

        NewGad.AutoSelectChilds = True
        If TB.Item.Exists(options, "autoselectchilds") Then NewGad.AutoSelectChilds = options.AutoSelectChilds

        NewGad.AutoUnselectChilds = True
        If TB.Item.Exists(options, "autounselectchilds") Then NewGad.AutoUnselectChilds = options.AutoUnselectChilds

        NewGad.HeadersOFF = False
        If TB.Item.Exists(options, "headersoff") Then NewGad.HeadersOFF = options.HeadersOFF

        NewGad.HScrollerOFF = False
        If TB.Item.Exists(options, "hscrolleroff") Then NewGad.HScrollerOFF = options.HScrollerOFF

        NewGad.VScrollerOFF = False
        If TB.Item.Exists(options, "vscrolleroff") Then NewGad.VScrollerOFF = options.VScrollerOFF

        ;--- Themeable at runtime --  
        NewGad.IconsTextGap = HGui.Theme.TreeView.IconTextGap
        If TB.Item.Exists(options, "iconstextgap") Then NewGad.IconsTextGap = options.IconsTextGap

        NewGad.OCStyle = HGui.Theme.TreeView.NodeStyle
        If TB.Item.Exists(options, "nodestyle") Then NewGad.OCStyle = options.NodeStyle

        NewGad.ScrollerSize = HGui.Theme.TreeView.Scrollbar.Size
        If TB.Item.Exists(options, "scrollersize") Then NewGad.ScrollerSize = options.ScrollerSize

        NewGad.TopBoxSize = HGui.Theme.TreeView.HeadersHeight
        If TB.Item.Exists(options, "headersheight") Then NewGad.TopBoxSize = options.HeadersHeight
         
        NewGad.ColumnsGap = HGui.Theme.TreeView.ColumnsGap
        If TB.Item.Exists(options, "columnsgap") Then NewGad.ColumnsGap = options.ColumnsGap

        NewGad.VLinesColor1 = HGui.Theme.TreeView.VLinesColor1
        If TB.Item.Exists(options, "vlinescolor1") Then NewGad.VLinesColor1 = options.VLinesColor1

        NewGad.VLinesColor2 = HGui.Theme.TreeView.VLinesColor2
        If TB.Item.Exists(options, "vlinescolor2") Then NewGad.VLinesColor2 = options.VLinesColor2

        NewGad.VLines = HGui.Theme.ListView.VerticalLines
        If TB.Item.Exists(options, "vlines") Then NewGad.VLines = options.VLines

        NewGad.FontName = HGui.Theme.TreeView.Font.Name
        If TB.Item.Exists(options, "fontname") Then NewGad.FontName = options.FontName

        NewGad.FontSizeOffset = HGui.Theme.TreeView.Font.SizeOffset
        If TB.Item.Exists(options, "fontsizeoffset") Then NewGad.FontSizeOffset = options.FontSizeOffset

        NewGad.FontStyle = HGui.Theme.TreeView.Font.Style
        If TB.Item.Exists(options, "fontstyle") Then NewGad.FontStyle = options.FontStyle

        NewGad.FontColor = HGui.Theme.TreeView.Font.Color
        If TB.Item.Exists(options, "fontcolor") Then NewGad.FontColor = options.FontColor

        NewGad.EntryHeight = HGui.Theme.TreeView.EntryHeight
        If TB.Item.Exists(options, "entryheight") Then NewGad.EntryHeight = options.EntryHeight

        NewGad.AlternateLines = HGui.Theme.TreeView.AlternateLines
        If TB.Item.Exists(options, "alternatelines") Then NewGad.AlternateLines = options.AlternateLines

        NewGad.ListAreaBG1 = HGui.Theme.TreeView.BGColors.Odd
        If TB.Item.Exists(options, "bgcolor1") Then NewGad.ListAreaBG1 = options.BGColor1

        NewGad.ListAreaBG2 = HGui.Theme.TreeView.BGColors.Even
        If TB.Item.Exists(options, "bgcolor2") Then NewGad.ListAreaBG2 = options.BGColor2         

        NewGad.FirstVisible = 0

        NewGad.SelectedFontColor  = HGui.Theme.TreeView.Selected.FontColor
        NewGad.SelectedListAreaBG = HGui.Theme.TreeView.Selected.BGColor
        ;---
        
        NewGad.Data = options.Data
        If TB.Item.Exists(options, "icons") Then NewGad.Icons = CopyTable(options.Icons)         

        If TB.Item.Exists(options, "onchange") Then NewGad.OnChange = options.OnChange
        If TB.Item.Exists(options, "onselect") Then NewGad.OnSelect = options.OnSelect
        If TB.Item.Exists(options, "onunselect") Then NewGad.OnUnSelect = options.OnUnSelect
        If TB.Item.Exists(options, "ondeselect") Then NewGad.OnUnSelect = options.OnDeselect
;        If TB.Item.Exists(options, "oninsert") Then NewGad.OnInsert = options.OnInsert

         NewGad.Area = HGui.Area:new({ position = position,
                                       size     = size,
                                       active   = False,
                                       window   = NewGad.window }, NewGad, UserData)

        ;:: OuterBox (Box) ::
        ;::::::::::::::::::::
        NewGad.OuterBox = HGui.Gadget:new(#HGUI_BOX_GADGET,
                                         { name = NewGad.name .. "_OuterBox",
                                           look = { nskin = HGui.Theme.TreeView.OuterBox.nskin }})
        NewGad.OuterBox:skinBordersUpdate(NewGad.OuterBox.Look.nSkin)
        NewGad.OuterBox.private.Father = NewGad

        ;:: Body (Box) ::
        ;::::::::::::::::
        NewGad.Body = HGui.Gadget:new(#HGUI_BOX_GADGET,
                                     { name = NewGad.name .. "_Body",
                                       look = { nskin = HGui.Theme.TreeView.Body.nskin }})
        NewGad.Body:skinBordersUpdate(NewGad.Body.Look.nSkin)
        NewGad.Body.private.Father = NewGad

        ;:: TopBox (Box) ::
        ;::::::::::::::::::
        NewGad.TopBox = HGui.Gadget:new(#HGUI_BOX_GADGET,
                                       { name = NewGad.name .. "_TopBox",
                                         caption = "",
                                         look = { nskin = HGui.Theme.TreeView.TopBox.nskin }})

        ;:: Headers (Buttons) ::
        ;:::::::::::::::::::::::
        NewGad.Headers = {}
        Local count = ListItems(NewGad.Data.Headers)

        For Local i = 0 To count-1
          NewGad.Headers[i] = HGui.Gadget:new(
            #HGUI_BUTTON_GADGET,
            { caption = NewGad.Data.Headers[i],
              Look = { nskin = HGui.Theme.TreeView.nskin,
                       hskin = HGui.Theme.TreeView.hskin,
                       pskin = HGui.Theme.TreeView.pskin,
                       dskin = HGui.Theme.TreeView.dskin,
                       ntext = HGui.Theme.TreeView.ntext,
                       htext = HGui.Theme.TreeView.htext,
                       ptext = HGui.Theme.TreeView.ptext,
                       dtext = HGui.Theme.TreeView.dtext },
              Flags = { Visible = Not(NewGad.HeadersOFF) }
              })
          
          ; Setup some custom fields
          NewGad.Headers[i].Father = NewGad
          NewGad.Headers[i].IsListViewHeader = True
          NewGad.Headers[i].ColumnNumber = i
          NewGad.Headers[i].DescendingSort = False
        Next

        ;:: Column Handlers ::
        ;:::::::::::::::::::::
        NewGad.ColumnHandlers = {}
        If TB.Item.IsNil(options.data, "columnhandlers")
          options.data.ColumnHandlers = {}
        EndIf
        
        ; Setup the conversion functions if specified otherwise setup default functions
        Local i, v
        For i, v In Pairs(NewGad.Headers)
          If Not(HaveItem(options.data.ColumnHandlers, i))
            NewGad.ColumnHandlers[i] = Function(value) Return(value) EndFunction
          Else
            NewGad.ColumnHandlers[i] = options.data.ColumnHandlers[i]
          EndIf
        Next
         
        ; Initial data sorting
        If TB.Item.Exists(NewGad.Data, "sortorder")
          Local count = TB.Count(NewGad.Data.sortOrder.Columns)
          If count > 0
            For Local i = 0 To count-1
              Local col = NewGad.Data.sortOrder.Columns[i]
              NewGad.Headers[col].DescendingSort = Not(NewGad.Data.sortOrder.Descending[i])
              HGui.treeView_RecursiveSort(NewGad.Headers[NewGad.Data.sortOrder.Columns[i]])
            Next
          EndIf
        EndIf

        ; This line below has been commented (21/10/22) because seems useless
        ; If TB.Item.IsNil(NewGad.Look, "ntext") Then NewGad.Look.nText = HGui.Theme.Button.nText

        ;:: ListArea (Box) ::
        ;::::::::::::::::::::
        NewGad.ListArea = HGui.Gadget:new(#HGUI_BOX_GADGET,
                                          { name = NewGad.name .. "_ListArea",
                                            look = { nskin = HGui.theme.button.nskin }})
        ; Attaches the events to the contents area
        NewGad.ListArea.Area:set({ active = True, window = NewGad.window,
                                   events = { onmousedown = HGui.treeViewContentEvent_LMBDown,
                                              onmouseup   = HGui.treeViewContentEvent_LMBUp,
                                              onmouseover = HGui.treeViewContentEvent_Over,
                                              onmouseout  = HGui.treeViewContentEvent_Out } }, NewGad.ListArea)

        ; If there are custom options then applies them to the Area object
        If TB.Item.Exists(options, "listarea") Then NewGad.ListArea:set(options.ListArea, False)
        NewGad.ListArea:skinBordersUpdate(NewGad.ListArea.Look.nSkin)
        NewGad.ListArea.private.Father = NewGad
        NewGad.ListArea.IsListViewContents = True
        
        ;:: VScroller (Scrollbar) ::
        ;:::::::::::::::::::::::::::
        If Not(NewGad.VScrollerOFF)
          ; Vertical scroller enabled
          NewGad.VScroller = HGui.Gadget:new(
            #HGUI_SCROLLBAR_GADGET,
            { name = NewGad.name .. "_VScroller",
              range = { 1, 0, 1 },
              OnChange = HGui.treeView_VScrollerUpdate,
              orientation = #HGUI_VERTICAL_LAYOUT,
              caption = "",
              Look = { OuterBox = HGui.Theme.TreeView.Scrollbar.oBox,
                       CursorBox = HGui.Theme.TreeView.Scrollbar.cBox,
                       Handle = HGui.Theme.TreeView.Scrollbar.Handle }
              })

          ; If there are custom options applies them to the vertical scroller
          If TB.Item.Exists(options, "vscroller") Then NewGad.VScroller:set(options.VScroller, False)
          NewGad.VScroller.private.Father = NewGad
        EndIf
         
        ;:: HScroller (Scrollbar) ::
        ;:::::::::::::::::::::::::::
        If Not(NewGad.HScrollerOFF) 
          NewGad.HScroller = HGui.Gadget:new(
            #HGUI_SCROLLBAR_GADGET,
            { name = NewGad.name .. "_HScroller",
              range = { 1, 1, 1 },
              value = 1,
              OnChange = HGui.treeView_HScrollerUpdate,
              orientation = #HGUI_HORIZONTAL_LAYOUT,
              caption = "",
              Look = { OuterBox = HGui.Theme.TreeView.Scrollbar.oBox,
                       CursorBox = HGui.Theme.TreeView.Scrollbar.cBox,
                       Handle = HGui.Theme.TreeView.Scrollbar.Handle }
              })
              
          ; If there are custom options applies them to the horizontal scrollbar
          If TB.Item.Exists(options, "hscroller") Then NewGad.HScroller:set(options.HScroller, False)
          NewGad.HScroller.private.Father = NewGad
        EndIf

        ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        ;::: CUSTOM METHODS :::::::::::::::::::::::::::::::::::::::::::::::::::
        ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        
        ; :CloseNodes(refresh)
        ; Close all nodes
        ; ------------------------------------------
        NewGad.CloseNodes =
          Function(refresh)
            If IsNil(refresh) Then refresh = False

            Local clo
            clo = 
              Function(node)
                If TB.Item.Exists(node, "childs")
                  Local k, j
                  For k, j In Pairs(node.childs)
                    clo(j)
                  Next
                  node._opened = False
                EndIf
              EndFunction
              
            Local i, v
            For i, v In Pairs(NewGad.Data.RealItems)
              clo(v)
            Next
            
            NewGad.Data.realItems = HGui.treeView_ElaborateList(NewGad.Data.Items)
            
            ; This is needed to update the vertical scroller
            Local totalItems = ListItems(NewGad.Data.realItems)
            Local totalVisible = Int(NewGad.ListArea.Area.Size.h/NewGad.EntryHeight)
            NewGad.VScroller:set({ Value = NewGad.VScroller.Private.Value, Range = { 0, totalItems-1, totalVisible-1 }}, True)

            If refresh Then NewGad:Render()
            
          EndFunction
        
        ; :OpenNodes(refresh)
        ; Open all nodes
        ; ------------------------------------------
        NewGad.OpenNodes =
          Function(refresh)
            If IsNil(refresh) Then refresh = False

            Local opn
            opn = 
              Function(node)
                If TB.Item.Exists(node, "childs")
                  Local k, j
                  For k, j In Pairs(node.childs)
                    opn(j)
                  Next
                  node._opened = True
                EndIf
              EndFunction
              
            Local i, v
            For i, v In Pairs(NewGad.Data.RealItems)
              opn(v)
            Next
            
            NewGad.Data.realItems = HGui.treeView_ElaborateList(NewGad.Data.Items)
            
            ; This is needed to update the vertical scroller
            Local totalItems = ListItems(NewGad.Data.realItems)
            Local totalVisible = Int(NewGad.ListArea.Area.Size.h/NewGad.EntryHeight)
            NewGad.VScroller:set({ Value = NewGad.VScroller.Private.Value, Range = { 0, totalItems-1, totalVisible-1 }}, True)

            If refresh Then NewGad:Render()
            
          EndFunction
          
        ; :Remove(index, refresh)
        ; Remove one item from the given position, if the item has
        ; childs they will be removed too.
        ; This method is only valid to remove first-level items.
        ; ------------------------------------------
        NewGad.Remove =
          Function(Newgad, index, refresh)
            ; Remove the given record at the 'index' position, if no index
            ; is specified it will be removed at the end of the list.
            If IsNil(index) Then index = -1
            If IsNil(refresh) Then refresh = False
            
            RemoveItem(NewGad.Data.Items, index)
            NewGad.Data.realItems = HGui.treeView_ElaborateList(NewGad.Data.Items)
            
            ; This is needed to update the vertical scroller
            Local totalItems = ListItems(NewGad.Data.realItems)
            Local totalVisible = Int(NewGad.ListArea.Area.Size.h/NewGad.EntryHeight)
            NewGad.VScroller:set({ Value = NewGad.VScroller.Private.Value, Range = { 0, totalItems-1, totalVisible-1 }}, True)

            If refresh Then NewGad:Render()
            
          EndFunction
        
        ; :Insert(record, index, select, refresh) -- select is bool
        ; Insert one item in the given position, the item can hold
        ; subitems in the field 'childs'.
        ; This method is only valid to insert first-level items.
        ; ------------------------------------------
        NewGad.Insert =
          Function(NewGad, record, index, select, refresh)
            ; Insert the given record at the 'index' position, if no index
            ; is specified it will be inserted at the end of the list.
            ; If select = True this item will be automatically selected
            If IsNil(index) Then index = -1
            If IsNil(select) Then select = False
            If IsNil(refresh) Then refresh = False
            If Not(NewGad.Multiselect) And select
              NewGad:DeselectAll(refresh)
            EndIf
            If NewGad.AutoSelectChilds And TB.Item.Exists(record, "childs") And select
              Local i, v
              For i, v In Pairs(record.childs)
                v._selected = True
              Next
            EndIf
              
            If select Then record._selected = True
            InsertItem(NewGad.Data.Items, record, index)
            NewGad.Data.realItems = HGui.treeView_ElaborateList(NewGad.Data.Items)
            
            ; This is needed to update the vertical scroller
            Local totalItems = ListItems(NewGad.Data.realItems)
            Local totalVisible = Int(NewGad.ListArea.Area.Size.h/NewGad.EntryHeight)
            NewGad.VScroller:set({ Value = NewGad.VScroller.Private.Value, Range = { 0, totalItems-1, totalVisible-1 }}, True)

            If refresh Then NewGad:Render()
          EndFunction

        ; :SelectAll(Refresh) -- only if multiselect = true
        ; ----------------------
        NewGad.SelectAll = 
          Function(NewGad, Refresh)
            If Not(NewGad.Multiselect) Then Return()
            If IsNil(Refresh) Then Refresh = True
            
            ; Defines a recursive function to scan the items tree
            Local select
            select = Function(item, recursive)
                       item._selected = True
                       If TB.Item.Exists(item, "childs")
                         If recursive And TB.Count(item.childs) > 0
                           Local i, v
                           For i, v In Pairs(item.childs)
                             select(v, recursive)
                           Next
                         EndIf
                       EndIf
                     EndFunction

            For Local i = 0 To ListItems(NewGad.Data.Items)-1
              select(self.Data.Items[i], NewGad.AutoSelectChilds)
            Next
            If Refresh Then NewGad:Render()
          EndFunction

        ; :UnselectAll(Refresh)
        ; ---------------------
        NewGad.UnselectAll = 
          Function(NewGad, Refresh)
            If IsNil(Refresh) Then Refresh = True
            
            ; Defines a recursive function to scan the items tree
            Local deselect
            deselect = Function(item, recursive)
                       item._selected = False
                       If TB.Item.Exists(item, "childs")
                         If recursive And TB.Count(item.childs) > 0
                           Local i, v
                           For i, v In Pairs(item.childs)
                             deselect(v, recursive)
                           Next
                         EndIf
                       EndIf
                     EndFunction

            For Local i = 0 To ListItems(NewGad.Data.Items)-1
              deselect(NewGad.Data.Items[i], True)
            Next
            If Refresh Then NewGad:Render()
          EndFunction

        ; :DesectAll(Refresh) --
        ; ----------------------
        NewGad.DeselectAll = NewGad.UnselectAll

        ; :RemoveAll(Refresh) --
        ; ----------------------
        ; Remove all entries
        NewGad.RemoveAll = 
          Function(NewGad, Refresh)
            If IsNil(Refresh) Then Refresh = True
            NewGad.Data.Items = {}
            NewGad.Data.RealItems = {}
            
            ; This is needed to update the vertical scroller
            Local totalItems = ListItems(NewGad.Data.realItems)
            Local totalVisible = Int(NewGad.ListArea.Area.Size.h/NewGad.EntryHeight)
            NewGad.VScroller:set({ Value = NewGad.VScroller.Private.Value, Range = { 0, totalItems-1, totalVisible-1 }}, True)

            If Refresh Then NewGad:Render()
          EndFunction

        ; :RemoveSelected(Refresh) --
        ; ---------------------------
        ; Remove all selected entries from the list.
        NewGad.RemoveSelected = 
          Function(NewGad, Refresh)
            If IsNil(Refresh) Then Refresh = True
            
            ; Defines a recursive function to scan the items tree
            Local remove
            remove = Function(items)
                       Local i, v
                       For i, v In Pairs(items)
                         Local godeep = False
                         If TB.Item.Exists(v, "_selected")
                           If v._selected
                             RemoveItem(items, i)
                           Else
                             godeep = True
                           EndIf
                        
                         EndIf
                         If TB.Item.Exists(v, "childs") And godeep
                           remove(items[i].childs)
                           If TB.Count(items[i].childs) = 0
                            items[i].childs = Nil
                           EndIf
                         EndIf
                       Next
                     EndFunction

            remove(NewGad.Data.Items)
            
            NewGad.Data.realItems = HGui.treeView_ElaborateList(NewGad.Data.Items)
            
            ; This is needed to update the vertical scroller
            Local totalItems = ListItems(NewGad.Data.realItems)
            Local totalVisible = Int(NewGad.ListArea.Area.Size.h/NewGad.EntryHeight)
            NewGad.VScroller:set({ Value = NewGad.VScroller.Private.Value, Range = { 0, totalItems-1, totalVisible-1 }}, True)

            If Refresh
              NewGad:Render()
            EndIf
        EndFunction

        ; :SetItems(Items, Refresh) --
        ; ----------------------------
        ; Shortcut to update the data set
        Newgad.SetItems = 
          Function(NewGad, items, refresh)
            NewGad:Set({ data = { items = items } }, refresh)
          EndFunction

        ; :Get() --
        ; ---------
        ; Retrieve informations about the treeview
        Newgad.Get = Function(NewGad)
                       Return(NewGad.Data.Items, NewGad.Data.Selected)
                     EndFunction

        ;:: Method to assemble the control layout ::
        ;:::::::::::::::::::::::::::::::::::::::::::
        NewGad._firstBuild = True
        NewGad.rebuildLayout = 
          Function(NewGad)
            Local ScrWidth, ScrHeight = GFX.GetHostSize()
            Local winWidth, WinHeight = NewGad.Window.Size.w, NewGad.Window.Size.h
            
            ;*** TEST : Setup Right side and vscroller ***     
            Local workSpace = NewGad.Area.Size.w
            ScrollerSizePerc = NewGad.ScrollerSize ;HGui.Theme.TreeView.Scrollbar.Size
            If NewGad.VScrollerOFF Then ScrollerSizePerc = 0.0001           
            w1 = workSpace - ScrollerSizePerc
            ScrollerSizePerc = -ScrollerSizePerc/NewGad.Area.Size.w
            w1 = 1 + ScrollerSizePerc
            ;************
            If Not(NewGad.VScrollerOFF)
              NewGad.OuterBox:layoutSet({ gadgets = { NewGad.Body, NewGad.VScroller },
                                          weights = { w1, ScrollerSizePerc },
                                          gap     = NewGad.OuterBox_Gap,
                                          type    = #HGUI_HORIZONTAL_LAYOUT,
                                          borders = NewGad.OuterBox_Borders })
            Else
              NewGad.OuterBox:layoutSet({ gadgets = { NewGad.Body },
                                          weights = { 1 },
                                          gap     = NewGad.OuterBox_Gap,
                                          type    = #HGUI_HORIZONTAL_LAYOUT,
                                          borders = NewGad.OuterBox_Borders })
            EndIf
            
            ;*** TEST : Setup Headers, contents and hscroller ***
            Local workSpace = NewGad.Area.Size.h
            ScrollerSizePerc = NewGad.ScrollerSize ; HGui.Theme.TreeView.Scrollbar.Size
            If NewGad.HScrollerOFF Then ScrollerSizePerc = 0.0001           
            TopBoxSizePerc = NewGad.TopBoxSize ; HGui.Theme.TreeView.HeadersHeight
            If NewGad.HeadersOFF Then TopBoxSizePerc = 0.0001
            w1 = workSpace - ScrollerSizePerc - TopBoxSizePerc
            ScrollerSizePerc = -ScrollerSizePerc/NewGad.Area.Size.h
            TopBoxSizePerc   = -TopBoxSizePerc/NewGad.Area.Size.h
            w1 = 1 + ScrollerSizePerc + TopBoxSizePerc
            ;************

            If Not(NewGad.HScrollerOff)         
              NewGad.Body:layoutSet({ gadgets = { NewGad.TopBox, NewGad.ListArea, NewGad.HScroller },
                                      weights = { TopBoxSizePerc, w1, ScrollerSizePerc },
                                      gap     = NewGad.VGap,
                                      type    = #HGUI_VERTICAL_LAYOUT,
                                      borders = NewGad.VBorders})
            Else                                 
              NewGad.Body:layoutSet({ gadgets = { NewGad.TopBox, NewGad.ListArea },
                                      weights = { TopBoxSizePerc, w1 },
                                      gap     = NewGad.VGap,
                                      type    = #HGUI_VERTICAL_LAYOUT,
                                      borders = NewGad.VBorders})
            EndIf
            
            NewGad.TopBox:layoutSet({ gadgets = NewGad.Headers,
                                      weights = NewGad.Data.ColumnSizes,
                                      gap     = NewGad.ColumnsGap,
                                      type    = #HGUI_HORIZONTAL_LAYOUT,
                                      borders = NewGad.ColumnsBorders })

            NewGad:layoutSet({ gadgets = { NewGad.OuterBox },
                               weights = { 1 },
                               gap     = 0,
                               type    = #HGUI_HORIZONTAL_LAYOUT,
                               borders = NewGad.Borders })
          EndFunction
          
          NewGad:rebuildLayout()
          
        ;NewGad.Init_Mode = Nil


      ;::: NEW DROPDOWN ::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_DROPDOWN_GADGET
         ; COMPOSITE GADGET                                                    |
         ;    Button
         ;
         ; Additional parameters *TriDocs*
         ; :: Value : Initial value
         ; :: Column : Columns associated with the button
         ; :: Data : Dropdown items ->
         ;                    .ColumnSizes
         ;                    .Headers
         ;                    .Items
         ;                    .Selected
         ;                    .SortOrder
         ; Addtional Actions *TriDocs*
         ; :: OnSelect : Callback when an item is selected

         ; CUSTOM METHODS *TriDocs*
         ; :SelectItem(Index, Refresh)
         ; :Get()
         
         
         DBG.Console.Out("DROPDOWN Gadget", Nil, HGui.DebugChannel)
         NewGad.Area = HGui.Area:new({ position = position, size = size, active = False, window = NewGad.window }, NewGad, UserData)

         ;::: PARAMETERS :::::::::::::::::::::::::::::::::::::::::::::::::::::::
         ;                                                        :: OnSelect ::
         If TB.Item.Exists(options, "onselect") Then NewGad.Actions.OnSelect = options.OnSelect

         NewGad.Column = 0
         If TB.Item.Exists(options, "column")
            NewGad.Column = options.column
         EndIf

         NewGad.Value = ""
         If TB.Item.Exists(options, "value")
            If GetType(options.value) = #STRING Or GetType(options.value) = #TABLE
               NewGad.Value = Options.Value
            ElseIf GetType(options.value) = #NUMBER
               NewGad.Value = Options.data.items[options.value][NewGad.column]
            EndIf
         EndIf

         ; Save its very own theme at this time
         NewGad.Theme = HGui.Theme.DropDown

         NewGad.Data = {} 
         If TB.Item.Exists(options, "data") Then NewGad.Data = options.data

         NewGad.ComboButton = HGui.Gadget:New(#HGUI_BUTTON_GADGET,
            { Caption = NewGad.Value,
              Look = { nskin = HGui.Theme.DropDown.nskin,
                       hskin = HGui.Theme.DropDown.hskin,
                       pskin = HGui.Theme.DropDown.pskin,
                       dskin = HGui.Theme.DropDown.dskin,
                       ntext = HGui.Theme.DropDown.ntext,
                       htext = HGui.Theme.DropDown.htext,
                       ptext = HGui.Theme.DropDown.ptext,
                       dtext = HGui.Theme.DropDown.dtext },

              Actions = { OnPushed = HGui.DropDown_Open }, window = mywin })

         NewGad.ComboButton.Father = NewGad
         NewGad.IsCombo = True

         ;:: METHODS ::
         ; :Get()
         ; Always returns the 
         ; - index
         ; - items list
         ; - associated column
         ; if the index is a string then a value not listed is present in the combo box
         NewGad.Get =
          Function(NewGad)
            If GetType(NewGad.Value) = #TABLE
              Return(NewGad.Value[NewGad.Column], NewGad.Data.Items, NewGad.Column)
              
            Else
              Return(NewGad.Value, NewGad.Data.Items, NewGad.Column)
              
            EndIf
            
          EndFunction
          
         ; :SetActiveItem(index, refresh)
         NewGad.SelectItem =
          Function(NewGad, Index, Refresh)
            ; COMBO BOX
            ; VALUE
            ; -> Index
            ; -> String
            If GetType(Index) = #NUMBER
              If Index >= 0 And Index < ListItems(NewGad.Data.Items)
                ; Ok, set it up
                NewGad.ComboButton:set({ status = #HGUI_NORMAL_STATE, caption = NewGad.Data.Items[Index][NewGad.Column] }, True)
                NewGad.Value = Index
                
              Else
                ; Out of range, do nothing
                
              EndIf
              
            Else
              ; No checks on strings, just set the control       
              NewGad.ComboButton:set({ status = #HGUI_NORMAL_STATE, caption = Index }, True)
              
            EndIf
            
          EndFunction

         NewGad:layoutSet({ gadgets = { NewGad.ComboButton },
                            weights = { 1 },
                            gap     = 0,
                            type    = #HGUI_HORIZONTAL_LAYOUT,
                            borders = { Top = 0, Bottom = 0, Left = 0, Right = 0 } })



      ;::: NEW IMAGE :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_IMAGE_GADGET
         ; COMPOSITE GADGET                                                    |
         ; Box
    
         ; Additional parameters *TriDocs*
         ; - source : source image file
         ; - mode : resize mode -> 1=FitMin, 2=FitMax, 3=Scale, 4=Stretch
         ; - fadein : True/False to apply a fade in effect when the image is displayed
         ; - scale : w & h fields to resize the image to the given dimensions
         ; - smooth : True/False to set if smoothness should be used when resizing
         ; - offset : x & y fields to set the image offset
         ; - alpha : a value for the alpha channel or #NONE
         ; - align : Hollywood constant to set the image alignment
         ; - borderColor : color of the borders
         ; - borders : top, bottom, left & right fields to set the image borders
         ; ---------------------------------------------------
         
         DBG.Console.Out("IMAGE Gadget", Nil, HGui.DebugChannel)
         NewGad.Area = HGui.Area:new({ position = position, size = size, active = False, window = NewGad.window }, NewGad, UserData)

         ;::: PARAMETERS :::::::::::::::::::::::::::::::::::::::::::::::::::::::
         ;                                                        :: OnChange ::
         NewGad.Source = "" ; brush or filename
         If TB.Item.Exists(options, "source") Then NewGad.Source = options.Source

         NewGad.Mode = 1 ; 1=FitMin, 2=FitMax, 3=Scale, 4=Stretch
         If TB.Item.Exists(options, "mode") Then NewGad.Mode = options.Mode

         NewGad.FadeIn = False
         If TB.Item.Exists(options, "fadein") Then NewGad.FadeIn = options.FadeIn
         
         NewGad.Scale = { w = 1, h = 1 }
         If TB.Item.Exists(options, "scale") Then NewGad.Scale = TB.Set(NewGad.Scale, Options.Scale, True)

         NewGad.Smooth = True
         If TB.Item.Exists(options, "smooth") Then NewGad.Smooth = options.Smooth
         
         NewGad.Offset = { x = 0, y = 0 }
         If TB.Item.Exists(options, "offset")
            If TB.Item.Exists(options.Offset, "x") Then NewGad.Offset.x = options.Offset.x
            If TB.Item.Exists(options.Offset, "y") Then NewGad.Offset.y = options.Offset.y
         EndIf

         NewGad.Alpha = #NONE
         If TB.Item.Exists(options, "alpha") Then NewGad.Alpha = options.Alpha

         NewGad.Align = #CENTER
         If TB.Item.Exists(options, "align") Then NewGad.Align = options.Align

         ; ATTENZIONE: Il border color viene ignorato, ma andrebbe applicato
         ; alla nSkin del sysrequest
         
         NewGad.BorderColor = HGui.Theme.SysRequest.ImageBorder
         If TB.Item.Exists(options, "bordercolor") Then NewGad.BorderColor = options.BorderColor

         NewGad.Borders = { Top = 1, Bottom = 1, Left = 1, Right = 1 }
         If TB.Item.Exists(options, "borders") Then NewGad.Borders = TB.Set(NewGad.Borders, Options.Borders, True)

         ; Container
         NewGad.Container = HGui.Gadget:new(#HGUI_BOX_GADGET,
                              { name = NewGad.name .. "_Container",
                                look = { nskin = HGui.Theme.SysRequest.nskin }})
         NewGad.Container:skinBordersUpdate(NewGad.Container.Look.nSkin)
         NewGad.Container.private.Father = NewGad
         NewGad.Container.FadeIn = NewGad.FadeIn
         
         NewGad:layoutSet({ gadgets = { NewGad.Container },
                            weights = { 1 },
                            gap     = 0,
                            type    = #HGUI_HORIZONTAL_LAYOUT,
                            borders = { Top = 0, Bottom = 0, Left = 0, Right = 0 } })


      ;::::::::::::::::::::::::::::::::::::::::::::.:::::::::::::::::::::::::::::
      ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Default
         DBG.Console.Out("Unrecognized gadget type <" .. NewGad.type .. ">, creation failed.", DBG.Error, HGui.DebugChannel)
         DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
         Return(False)

   EndSwitch



   ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
   ;::: BACKGROUND HANDLING ::::::::::::::::::::::::::::::::::::::::::::::::::::
   ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
   /*
   If NewGad.Background
      If NewGad.UseCache
         NewGad.background = { Type = GFX.SkinBGType_Private,
                               BGStruct = { Brush = Nil, X = NewGad.area.Position.x, Y = NewGad.area.Position.y, W = NewGad.area.Size.w, H = NewGad.area.Size.h },
                               Offset = { x = 0, y = 0, w = 0, h = 0 } }
      Else
         NewGad.background = { Type = GFX.SkinBGType_Private,
                               BGStruct = { Brush = Nil, X = NewGad.area.Position.x, Y = NewGad.area.Position.y, W = NewGad.area.Size.w, H = NewGad.area.Size.h },
                               Offset = { x = 0, y = 0, w = 0, h = 0 } }
      EndIf
   Else
      NewGad.Background = Nil
   EndIf
   */

   ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
   ;::: ACTIVE AREAS :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
   ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

   If NewGad.area.active
      If(NewGad.flags.enabled = #HGUI_DISABLED Or NewGad.flags.visible = #HGUI_HIDDEN) Then DisableButton(NewGad.area.private.button)
   EndIf

   If NewGad.usecache Then NewGad:cacheBuild()
   If HGui.AutoRendering Then NewGad:render()

   DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
   InsertItem(HGui.Gadgets, NewGad)
   Return(NewGad)

EndFunction

Function HGui.gadgetEvent_LMBDown(msg) ; *TriDoc*
/*---------------------------------------------------------
HGui.gadgetEvent_LMBDown(msg)

Internal function called whenever a gadget receives a <Left Mouse Button Down>
event.
---------------------------------------------------------*/
   Local Gadget = msg.userdata.area.object
   DBG.Console.Out("[ HGui.gadgetEvent_LMBDown ] : Gadget <" .. Gadget.Name .. "> LMB Down event.", DBG.OpenFunc, HGui.DebugChannel)

   If Not(HGui.EventHandling)
      DBG.Console.Out("Event ignored, <EventHandling> is switched off.", DBG.Warning, HGui.DebugChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
      Return(False)
   EndIf
   
   If TB.Item.Exists(HGui, "modalwindow")
    If Gadget.Window <> HGui.ModalWindow
      DBG.Console.Out("Event ignored, modal window active, event coming from another source...", DBG.Warning, HGui.DebugChannel)
      Return(False)
    EndIf
  EndIf

   HGui.Tip.Close()

   If TB.Item.Exists(HGui, "activetext")
    DBG.Console.Out("Unactivating text object...", Nil, HGui.DebugChannel)
    If Not(HGui.ActiveText.Father.IsKilled)
      HGui.ActiveText:Unactivate()
      HGui.ActiveText = Nil
    Else
      DBG.Console.Out("  Text object is killed, no need to unactivate it...", DBG.Warning, HGui.DebugChannel)
      HGui.ActiveText = Nil
    EndIf
   EndIf

   Switch Gadget.type
      ;:: KNOB :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_KNOB_GADGET
            HGui.ScrollBarDragging = True
            HGui.MouseInsideCursor = True
            InstallEventHandler({ OnMouseMove = HGui.gadgetEvent_DragScrollbarCursor }, Gadget)
            HGui.ScrollBarObject = Gadget
            Gadget.CursorOffset = MouseX() - Gadget.Area.Position.x
            HGui.gadgetEvent_DragScrollbarCursor({x=MouseX(), y=MouseY(), Userdata=Gadget})

      ;:: BUTTON :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_BUTTON_GADGET
         If Gadget.Status = #HGUI_HILIGHTED_STATE
            Gadget.Status = #HGUI_PUSHED_STATE
            Gadget:Render()

            ;                                                     :: DRAGGING ::
            If IsKeyDown(HGui.DragKey) And Gadget.Flags.Draggable
               Gadget:Drag()
               DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
               Return(True)
            EndIf

            ;::: IT'S LISTVIEW HEADER ? ::::::::::::::::::::::::::::::::::::::::
            If TB.Item.Exists(Gadget, "father")
              If Gadget.Father.Type = #HGUI_LISTVIEW_GADGET Or
                 Gadget.Father.Type = #HGUI_TREEVIEW_GADGET
                If Gadget.Father.ResizeableColumns
                  Local g = Gadget.Area
                  Local mx, my = MouseX(), MouseY()

                  Local colnum = -1
                  For i, v In IPairs(Gadget.Father.Headers)
                    If v = Gadget
                      colnum = i
                      Break()
                    EndIf
                  Next 
                  
                  mx = mx - Gadget.Father.Headers[ColNum].Look.Offset.x
                  Local offsetLeft = Abs(g.position.x-mx)
                  Local offsetRight = Abs(g.position.x+g.size.w-mx)
                  If offsetLeft <= HGui.LVResizeColumnOffset
                    ; Ridimensiona a sinistro se la colonna √® > 0
                    If Gadget.Father.Headers[0] = Gadget
                      ; DebugPrint("PRIMA COLONNA, Impossibile ridimensionare.")
                    Else
                      ; DebugPrint("Ridimensiona lato sinistro")
                      HGui.LVResizeColumnMode = True
                      HGui.LVResizeSide       = "left"
                      HGui.LVResizeGadget     = Gadget
                      HGui.LVResizeColNumber  = ColNum
                      HGui.LVResizeSizes      = CopyTable(Gadget.Father.Data.ColumnSizes)
                      For i, v In IPairs(HGui.LVResizeSizes)
                        If v < 1.01
                          HGui.LVResizeSizes[i] = Int(v * Gadget.Father.Area.Size.w)
                        EndIf
                        v = v + Gadget.Father.Headers[i].Look.Offset.x
                      Next
                      HGui.LVMousePos         = { x = mx + Gadget.Father.Headers[ColNum].Look.Offset.x, y = my }
                      
                      ; Crea uno sprite per la barra verticale
                      Local starty = HGui.LVResizeGadget.Area.Position.y
                      Local endy   = HGui.LVResizeGadget.Father.ListArea.Area.Position.y + HGui.LVResizeGadget.Father.ListArea.Area.Size.h
                      Local height = endy-starty
                      Local bid = CreateBrush(Nil, 2, height, #BLACK)
                      GFX.OutputDevice.Select(#BRUSH, bid, #SELMODE_COMBO)
                        Line(0, 0, 0, height, HGui.LVResizeLineColor1)
                        Line(1, 0, 1, height, HGui.LVResizeLineColor2)
                      GFX.OutputDevice.EndSelect()
                      HGui.LVSprite = CreateSprite(Nil, #BRUSH, bid)
                      FreeBrush(bid)

                      InstallEventHandler({ OnMouseMove = HGui._ListView_ResizeColumn })

                    EndIf
                  ElseIf offsetRight <= HGui.LVResizeColumnOffset
                    ; Ridimensiona a destra se la colonna √® < ultima
                    ;If Gadget.Father.Headers[ListItems(Gadget.Father.Headers)-1] = Gadget
                      ; DebugPrint("ULTIMA COLONNA, Impossibile ridimensionare.")
                    ;Else
                      ; DebugPrint("Ridimensiona lato destro")
                      HGui.LVResizeColumnMode = True
                      HGui.LVResizeSide       = "right"
                      HGui.LVResizeGadget     = Gadget
                      HGui.LVResizeColNumber  = ColNum
                      HGui.LVResizeSizes      = CopyTable(Gadget.Father.Data.ColumnSizes)
                      For i, v In IPairs(HGui.LVResizeSizes) 
                        If v < 1.01
                          HGui.LVResizeSizes[i] = Int(v * Gadget.Father.Area.Size.w)
                        EndIf
                        v = v + Gadget.Father.Headers[i].Look.Offset.x
                      Next
                      HGui.LVMousePos         = { x = mx + Gadget.Father.Headers[ColNum].Look.Offset.x, y = my }
                      InstallEventHandler({ OnMouseMove = HGui._ListView_ResizeColumn })
                      
                      ; Crea uno sprite per la barra verticale
                      Local starty = HGui.LVResizeGadget.Area.Position.y
                      Local endy   = HGui.LVResizeGadget.Father.ListArea.Area.Position.y + HGui.LVResizeGadget.Father.ListArea.Area.Size.h
                      Local height = endy-starty
                      Local bid = CreateBrush(Nil, 2, height, #BLACK)
                      GFX.OutputDevice.Select(#BRUSH, bid, #SELMODE_COMBO)
                        Line(0, 0, 0, height, HGui.LVResizeLineColor1)
                        Line(1, 0, 1, height, HGui.LVResizeLineColor2)
                      GFX.OutputDevice.EndSelect()
                      HGui.LVSprite = CreateSprite(Nil, #BRUSH, bid)
                      FreeBrush(bid)
                      
                    ;EndIf
                  EndIf                
                EndIf
              EndIf
            
            ;::: IT'S SCROLLBAR'S CURSOR ? :::::::::::::::::::::::::::::::::::::
            ElseIf Gadget.private.iscursor
               Local Cursor   = Gadget
               Local Father   = Cursor.private.Father
               Local OuterBox = Father.Childs.Gadgets[0]
               Local Spacer   = Father.Childs.Gadgets[0].Childs.Gadgets[0]

               HGui.ScrollBarDragging = True
               HGui.MouseInsideCursor = True
               InstallEventHandler({ OnMouseMove = HGui.gadgetEvent_DragScrollbarCursor }, Gadget)
               HGui.ScrollBarObject = Gadget

               If Father.Orientation = #HGUI_HORIZONTAL_LAYOUT
                  Father.CursorOffset = MouseX() - Cursor.Area.Position.x
               ElseIf Father.Orientation = #HGUI_VERTICAL_LAYOUT
                  Father.CursorOffset = MouseY() - Cursor.Area.Position.y
               EndIf

            ;::: IT'S A SCROLLBAR'S CONTAINER ? ::::::::::::::::::::::::::::::::
            ElseIf TB.Item.Exists(Gadget.private, "father")
               Local Father = Gadget.private.Father
               If Father.Type = #HGUI_SCROLLBAR_GADGET
                  Local Cursor = Father.childs.gadgets[0].childs.gadgets[1]
                  Local Direction = 0
                  If Father.Orientation = #HGUI_HORIZONTAL_LAYOUT
                     Local middle = Cursor.Area.Size.w / 2 + Cursor.Area.Position.x
                     If MouseX() < middle
                        Direction = -1
                     Else
                        Direction = 1
                     EndIf
                  ElseIf Father.Orientation = #HGUI_VERTICAL_LAYOUT
                     Local middle = Cursor.Area.Size.h / 2 + Cursor.Area.Position.y
                     If MouseY() < middle
                        Direction = -1
                     Else
                        Direction = 1
                     EndIf
                  EndIf

                  ; MOVE THE CURSOR
                  Local previousValue = Father.Private.Value
                  Local Value = Father.Private.Value + Direction * Father.Range[2]
                  Father:set({ Value = Value, caption = IIF(Father.Caption <> "", Father.Caption, Nil) }, True)
                  If TB.Item.Exists(Father.Actions, "onchange")
                     Father.Actions.OnChange(Father, Father.Private.Value, previousValue)
                  EndIf

               ElseIf Father.Type = #HGUI_SLIDER_GADGET
                  Local Cursor = Father.childs.gadgets[0].childs.gadgets[1]
                  Local Direction = 0
                  If Father.Orientation = #HGUI_HORIZONTAL_LAYOUT
                     Local middle = Cursor.Area.Size.w / 2 + Cursor.Area.Position.x
                     If MouseX() < middle
                        Direction = -1
                     Else
                        Direction = 1
                     EndIf
                  ElseIf Father.Orientation = #HGUI_VERTICAL_LAYOUT
                     Local middle = Cursor.Area.Size.h / 2 + Cursor.Area.Position.y
                     If MouseY() < middle
                        Direction = -1
                     Else
                        Direction = 1
                     EndIf
                  EndIf

                  ; MOVE THE CURSOR
                  Local previousValue = Father.Private.Value
                  Local Value = Father.Private.Value + Direction ;* Father.Range[2]
                  ;If Father.Type = #HGUI_SCROLLBAR_GADGET
                  ;   Father:set({ Value = Value, caption = IIF(Father.Caption <> "", Father.Caption, Nil) }, True)
                  ;ElseIf Father.Type = #HGUI_SLIDER_GADGET
                     Father:set({ Value = Value }, True)
                     If TB.Item.Exists(Father.Actions, "onchange")
                        Father.Actions.OnChange(Father, Father.Private.Value, previousValue)
                     EndIf
                  ;EndIf
               EndIf

            EndIf

            ;                                                :: ON DOWN SOUND ::
            If TB.Item.Exists(Gadget.Sounds, "ondown")
               If IsSamplePlaying(Gadget.Sounds.OnDown) Then StopSample(Gadget.Sounds.OnDown)
               PlaySample(Gadget.Sounds.OnDown)
            EndIf

            ;                                                :: ON DOWN EVENT ::
            If TB.Item.Exists(Gadget.Actions, "ondown")
               DBG.Console.Out("::: Executing <OnDown> callback function :::", Nil, HGui.DebugChannel)
               Gadget.Actions.OnDown(Gadget)
               DBG.Console.Out("::: Done. :::", DBG.CloseFunc, HGui.DebugChannel)
               Return(True)
            EndIf

         Else
            DBG.Console.Out("Event not handled for <" .. Gadget.Status .. "> gadget's status.", DBG.Warning, HGui.DebugChannel)
            DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
            Return(False)
         EndIf


      ;:: TEXT :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_TEXT_GADGET
         If Gadget.Status = #HGUI_HILIGHTED_STATE
            Gadget.Status = #HGUI_PUSHED_STATE
            Gadget:Render()

            ;                                                     :: DRAGGING ::
            If IsKeyDown(HGui.DragKey) And Gadget.Flags.Draggable
               Gadget:Drag()
               DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
               Return(True)
            EndIf

            ;                                                :: ON DOWN SOUND ::
            If TB.Item.Exists(Gadget.Sounds, "ondown")
               If IsSamplePlaying(Gadget.Sounds.OnDown) Then StopSample(Gadget.Sounds.OnDown)
               PlaySample(Gadget.Sounds.OnDown)
            EndIf

            ;                                                :: ON DOWN EVENT ::
            If TB.Item.Exists(Gadget.Actions, "ondown")
               DBG.Console.Out("::: Executing <OnDown> callback function :::", Nil, HGui.DebugChannel)
               Gadget.Actions.OnDown(Gadget)
               DBG.Console.Out("::: Done. :::", DBG.CloseFunc, HGui.DebugChannel)
               Return(True)
            EndIf

         Else
            DBG.Console.Out("Event not handled for <" .. Gadget.Status .. "> gadget's status.", DBG.Warning, HGui.DebugChannel)
            DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
            Return(False)
         EndIf

      ;:: CANVAS :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_CANVAS_GADGET
        ;                                                    :: ON DOWN EVENT ::
        If TB.Item.Exists(Gadget.Actions, "ondown")
           DBG.Console.Out("::: Executing <OnDown> callback function :::", Nil, HGui.DebugChannel)
           Gadget.Actions.OnDown(Gadget)
           DBG.Console.Out("::: Done. :::", DBG.CloseFunc, HGui.DebugChannel)
           Return(True)
        EndIf

      ;:: SWITCH :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_SWITCH_GADGET
         ;--| Gadget Status : HILIGHTED |---------------------------------------
         If Gadget.Status = #HGUI_HILIGHTED_STATE
            Gadget.PrevStatus = #HGUI_HILIGHTED_STATE
            Gadget.Status = #HGUI_PUSHED_STATE
            Gadget:Render()

            ;                                                     :: DRAGGING ::
            If IsKeyDown(HGui.DragKey) And Gadget.Flags.Draggable
               Gadget:Drag()
               DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
               Return(True)
            EndIf

            ;                                                :: ON DOWN SOUND ::
            If TB.Item.Exists(Gadget.Sounds, "ondown")
               If IsSamplePlaying(Gadget.Sounds.OnDown) Then StopSample(Gadget.Sounds.OnDown)
               PlaySample(Gadget.Sounds.OnDown)
            EndIf

            ;                                                :: ON DOWN EVENT ::
            If TB.Item.Exists(Gadget.Actions, "ondown")
               DBG.Console.Out("::: Executing <OnDown> callback function :::", Nil, HGui.DebugChannel)
               Gadget.Actions.OnDown(Gadget)
               DBG.Console.Out("::: Done. :::", DBG.CloseFunc, HGui.DebugChannel)
               Return(True)
            EndIf

         ;--| Gadget Status : HPUSHED |-----------------------------------------
         ElseIf Gadget.Status = #HGUI_HPUSHED_STATE
            If Gadget.private.Grouped
               If Gadget.private.SubType = #HGUI_GTYPE_RADIO
                  Return()  ; loggare messaggio (occhio all'evento pushed-out che fa casino)
               EndIf
            EndIf

            Gadget.PrevStatus = #HGUI_HPUSHED_STATE
            Gadget.Status = #HGUI_PUSHED_STATE
            Gadget:Render()

            ;                                                     :: DRAGGING ::
            If IsKeyDown(HGui.DragKey) And Gadget.Flags.Draggable
               Gadget:Drag()
               DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
               Return(True)
            EndIf

            ;                                                :: ON DOWN SOUND ::
            If TB.Item.Exists(Gadget.Sounds, "ondown")
               If IsSamplePlaying(Gadget.Sounds.OnDown) Then StopSample(Gadget.Sounds.OnDown)
               PlaySample(Gadget.Sounds.OnDown)
            EndIf

            ;                                                :: ON DOWN EVENT ::
            If TB.Item.Exists(Gadget.Actions, "ondown")
               DBG.Console.Out("::: Executing <OnDown> callback function :::", Nil, HGui.DebugChannel)
               Gadget.Actions.OnDown(Gadget)
               DBG.Console.Out("::: Done. :::", DBG.CloseFunc, HGui.DebugChannel)
               Return(True)
            EndIf

         Else
            DBG.Console.Out("Event not handled for <" .. Gadget.Status .. "> gadget's status.", DBG.Warning, HGui.DebugChannel)
            DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
            Return(False)
         EndIf


      ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Default
         DBG.Console.Out("Unknown gadget class <" .. Gadget.type .. ">,  failed to handle this event.", DBG.Error, HGui.DebugChannel)
         DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
         Return(False)

   EndSwitch

   DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
   Return(True)

EndFunction

Function HGui._ListView_ResizeColumn() ; *TriDoc*
/*---------------------------------------------------------
HGui._ListView_ResizeColumn()

Internal function used to handle the ListView/TreeView columns resizing.
---------------------------------------------------------*/

  SelectDisplay(HGui.LVResizeGadget.Window.Private.HWId, True)
  Local mx, my = MouseX(), MouseY()
  
  Local dx = mx - HGui.LVMousePos.x

  HGui.LVMousePos.x = mx
  ;MovePointer(mx, HGui.LVMousePos.y)
  
  Local starty
  If Not(HGui.LVResizeGadget.Father.hScrollerOFF)
    If HGui.LVResizeSide = "left" And dx <> 0

      HGui.LVResizeSizes[HGui.LVResizeColNumber-1] = HGui.LVResizeSizes[HGui.LVResizeColNumber-1] + dx

      starty = HGui.LVResizeGadget.Area.Position.y    
      DisplaySprite(HGui.LVSprite, mx, starty)
      
    ElseIf HGui.LVResizeSide = "right" And dx <> 0
    
      HGui.LVResizeSizes[HGui.LVResizeColNumber] = HGui.LVResizeSizes[HGui.LVResizeColNumber] + dx

      starty = HGui.LVResizeGadget.Area.Position.y    
      DisplaySprite(HGui.LVSprite, mx, starty)
      
    EndIf
    
  Else
    If HGui.LVResizeSide = "left" And dx <> 0
      HGui.LVResizeSizes[HGui.LVResizeColNumber-1] = HGui.LVResizeSizes[HGui.LVResizeColNumber-1] + dx
      HGui.LVResizeSizes[HGui.LVResizeColNumber] = HGui.LVResizeSizes[HGui.LVResizeColNumber] - dx
      starty = HGui.LVResizeGadget.Area.Position.y    
      DisplaySprite(HGui.LVSprite, mx, starty)
      
    ElseIf HGui.LVResizeSide = "right" And dx <> 0
      If TB.Item.Exists(HGui.LVResizeSizes, HGui.LVResizeColNumber+1)
        HGui.LVResizeSizes[HGui.LVResizeColNumber] = HGui.LVResizeSizes[HGui.LVResizeColNumber] + dx
        HGui.LVResizeSizes[HGui.LVResizeColNumber+1] = HGui.LVResizeSizes[HGui.LVResizeColNumber+1] - dx
        starty = HGui.LVResizeGadget.Area.Position.y    
        DisplaySprite(HGui.LVSprite, mx, starty)
      EndIf

    EndIf

  EndIf

EndFunction

Function HGui.gadgetEvent_LMBUp(msg) ; *TriDoc*
/*---------------------------------------------------------
HGui.gadgetEvent_LMBUp(msg)

Internal function called whenever a gadget receives a <Left Mouse Button Up> event.
---------------------------------------------------------*/
   Local Gadget = msg.userdata.area.object
   DBG.Console.Out("[ HGui.gadgetEvent_LMBUp ] : Gadget <" .. Gadget.Name .. "> LMB Up event.", DBG.OpenFunc, HGui.DebugChannel)

   If Not(HGui.EventHandling)
      DBG.Console.Out("Event ignored, <EventHandling> is switched off.", DBG.Warning, HGui.DebugChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
      Return(False)
   EndIf

   If TB.Item.Exists(HGui, "modalwindow")
    If Gadget.Window <> HGui.ModalWindow
      DBG.Console.Out("Event ignored, modal window active, event coming from another source...", DBG.Warning, HGui.DebugChannel)
      Return(False)
    EndIf
  EndIf
   
   HGui.Tip.Close()
   
   ;::: THERE WAS A SCROLLBAR'S CURSOR DRAGGING RUNNING ? ::::::::::::::::::::::
   ;: If so, terminate it.                                                     :
   If HGui.ScrollBarDragging
      HGui.ScrollBarDragging = False
      InstallEventHandler({ OnMouseMove = 0 })

      If TB.Item.Exists(HGui, "scrollbarobject")
         If HGui.MouseInsideCursor
            HGui.ScrollBarObject.Status = #HGUI_HILIGHTED_STATE
         Else
            HGui.ScrollBarObject.Status = #HGUI_NORMAL_STATE
         EndIf

         HGui.ScrollBarObject:Render()
         HGui.ScrollBarObject = Nil
      EndIf
   EndIf

   Switch Gadget.type
      ;:: KNOB
      Case #HGUI_KNOB_GADGET

      ;:: BUTTON :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_BUTTON_GADGET
         If Gadget.Status = #HGUI_PUSHED_STATE
            Gadget.Status = #HGUI_HILIGHTED_STATE
            Gadget:Render()

            ;                                                  :: ON UP SOUND ::
            If TB.Item.Exists(Gadget.Sounds, "onpushed")
               If IsSamplePlaying(Gadget.Sounds.OnPushed) Then StopSample(Gadget.Sounds.OnPushed)
               PlaySample(Gadget.Sounds.OnPushed)
            EndIf

            ;                                                  :: ON UP EVENT ::
            If TB.Item.Exists(Gadget.Actions, "onpushed")
               DBG.Console.Out("::: Executing <OnPushed> callback function :::", Nil, HGui.DebugChannel)
               Gadget.Actions.OnPushed(Gadget)
               DBG.Console.Out("::: Done. :::", Nil, HGui.DebugChannel)
               ;Return(True)
            EndIf
                       
            ; CHECK LINKS
            For i, v In Pairs(Gadget.Private.Links)
              Switch v.target.type
                Case #HGUI_TEXT_GADGET
                  Switch v.action
                    Case "+/-"
                      ; BUTTON -> TEXT ( + / - )
                      ; Read text value
                      Local value = ToNumber(v.target.textobj.text)
                      ; Perform the change
                      value = Limit(value + v.params.value, v.params.range[0], v.params.range[1])
                      ; Update the target
                      v.target:set({ TextObj = { text = ToString(value) } }, True)
                      
                  EndSwitch
              EndSwitch
            Next

            ; :: IT'S A LISTVIEW/TREEVIEW HEADER?
            If TB.Item.Exists(Gadget, "islistviewheader")
               If Gadget.DescendingSort = False
                  Gadget.DescendingSort = True
               Else
                  Gadget.DescendingSort = False
               EndIf

               If Gadget.Father.Type = #HGUI_LISTVIEW_GADGET
                  DisableLineHook()
                  TB.Sort(Gadget.Father.Data.Items,
                          Gadget.DescendingSort,
                          Gadget.ColumnNumber,
                          { Gadget.Father.Data.Selected })
                  HGui.ListView_ContentsUpdate(Gadget.Father)
                  EnableLineHook()
                  
               ElseIf Gadget.Father.Type = #HGUI_TREEVIEW_GADGET
                  HGui.treeView_RecursiveSort(Gadget)
                  /*
                  TB.Sort(Gadget.Father.Data.realItems,
                          Gadget.DescendingSort,
                          Gadget.ColumnNumber)
                          */
                  HGui.treeView_ContentsUpdate(Gadget.Father)
               EndIf
            EndIf

         Else
            DBG.Console.Out("Event not handled for <" .. Gadget.Status .. "> gadget's status.", DBG.Warning, HGui.DebugChannel)
            DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
            Return(False)
         EndIf


      ;:: TEXT :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_TEXT_GADGET
         If Gadget.Status = #HGUI_PUSHED_STATE
            Gadget.Status = #HGUI_HILIGHTED_STATE
            Gadget:Render()

            ;                                                  :: ON UP SOUND ::
            If TB.Item.Exists(Gadget.Sounds, "onpushed")
               If IsSamplePlaying(Gadget.Sounds.OnPushed) Then StopSample(Gadget.Sounds.OnPushed)
               PlaySample(Gadget.Sounds.OnPushed)
            EndIf

            ;                                                  :: ON UP EVENT ::
            If TB.Item.Exists(Gadget.Actions, "onpushed")
               DBG.Console.Out("::: Executing <OnPushed> callback function :::", Nil, HGui.DebugChannel)
               Gadget.Actions.OnPushed(Gadget)
               DBG.Console.Out("::: Done. :::", Nil, HGui.DebugChannel)
            EndIf

            ; :: ACTIVATE TEXT CONTROL ::
            HGui.ActiveText = Gadget.TextObj
            Gadget.TextObj:Activate()

         Else
            DBG.Console.Out("Event not handled for <" .. Gadget.Status .. "> gadget's status.", DBG.Warning, HGui.DebugChannel)
            DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
            Return(False)
         EndIf

      ;:: CANVAS :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_CANVAS_GADGET
        ;                                                  :: ON PUSHED EVENT ::
        If TB.Item.Exists(Gadget.Actions, "onpushed")
           DBG.Console.Out("::: Executing <OnPushed> callback function :::", Nil, HGui.DebugChannel)
           Gadget.Actions.OnPushed(Gadget)
           DBG.Console.Out("::: Done. :::", DBG.CloseFunc, HGui.DebugChannel)
           Return(True)
        EndIf

      ;:: SWITCH :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_SWITCH_GADGET
         ;---| Gadget Status : PUSHED (was HILIGHTED) |-------------------------
         If Gadget.Status = #HGUI_PUSHED_STATE And Gadget.PrevStatus = #HGUI_HILIGHTED_STATE
            Gadget.Status = #HGUI_HPUSHED_STATE

            ;---| GROUP Check |---
            If Gadget.private.Grouped
               If Gadget.private.SubType = #HGUI_GTYPE_RADIO
                  ;---| Switch off all the brothers |---
                  Local brothers = Gadget.private.brothers
                  For Local i = 0 To ListItems(brothers) - 1
                     If brothers[i].Type = #HGUI_SWITCH_GADGET
                        brothers[i]:Set({ Value = 0 }, True)
                     EndIf
                  Next
               EndIf
            EndIf

            Gadget.private.Value = 1
            Gadget:Render()

            ;                                                  :: ON UP SOUND ::
            If TB.Item.Exists(Gadget.Sounds, "onpushed")
               If IsSamplePlaying(Gadget.Sounds.OnPushed) Then StopSample(Gadget.Sounds.OnPushed)
               PlaySample(Gadget.Sounds.OnPushed)
            EndIf

            ;                                                  :: ON UP EVENT ::
            If TB.Item.Exists(Gadget.Actions, "onpushed")
               DBG.Console.Out("::: Executing <OnPushed> callback function :::", Nil, HGui.DebugChannel)
               Gadget.Actions.OnPushed(Gadget)
               DBG.Console.Out("::: Done. :::", DBG.CloseFunc, HGui.DebugChannel)
               Return(True)
            EndIf

         ;---| Gadget Status : PUSHED (was HPUSHED) |---------------------------
         ElseIf Gadget.Status = #HGUI_PUSHED_STATE And Gadget.PrevStatus = #HGUI_HPUSHED_STATE

            Gadget.Status = #HGUI_HILIGHTED_STATE
            Gadget.private.Value = 0
            Gadget:Render()

            ;                                                  :: ON UP SOUND ::
            If TB.Item.Exists(Gadget.Sounds, "onpushed")
               If IsSamplePlaying(Gadget.Sounds.OnPushed) Then StopSample(Gadget.Sounds.OnPushed)
               PlaySample(Gadget.Sounds.OnPushed)
            EndIf

            ;                                                  :: ON UP EVENT ::
            If TB.Item.Exists(Gadget.Actions, "onpushed")
               DBG.Console.Out("::: Executing <OnPushed> callback function :::", Nil, HGui.DebugChannel)
               Gadget.Actions.OnPushed(Gadget)
               DBG.Console.Out("::: Done. :::", DBG.CloseFunc, HGui.DebugChannel)
               Return(True)
            EndIf

         Else
            DBG.Console.Out("Event not handled for <" .. Gadget.Status .. "> gadget's status.", DBG.Warning, HGui.DebugChannel)
            DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
            Return(False)
         EndIf


      ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Default
         DBG.Console.Out("Unknown gadget class <" .. Gadget.type .. ">,  failed to handle this event.", DBG.Error, HGui.DebugChannel)
         DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
         Return(False)

   EndSwitch

   DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
   Return(True)

EndFunction

Function HGui.gadgetEvent_TextOnInputEnd(textObj, content) ; *TriDoc*
/*---------------------------------------------------------
HGui.gadgetEvent_TextOnInputEnd(textObj, content)

Internal function used to handle the input end callback on a text box gadget.
---------------------------------------------------------*/
  Local Gadget = textObj._HGuiObject
  
  ; Callback
  If TB.Item.Exists(Gadget.Actions, "oninputend")
    Gadget.Actions.OnInputEnd(Gadget, content)
  EndIf
  
  Gadget:Render(True)
  
EndFunction

Function HGui.gadgetEvent_Over(msg) ; *TriDoc*
/*---------------------------------------------------------
HGui.gadgetEvent_Over(msg)

Internal function called whenever a gadget receives a <Mouse Over> event.
---------------------------------------------------------*/
   Local Gadget = msg.userdata.area.object
   DBG.Console.Out("[ HGui.gadgetEvent_Over ] Gadget <" .. Gadget.Name .. "> Mouse Over event.", DBG.OpenFunc, HGui.DebugChannel)

   If Not(HGui.EventHandling)
      DBG.Console.Out("Event ignored, EventHandling is switched off.", DBG.Warning, HGui.DebugChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
      Return(False)
   EndIf

   If TB.Item.Exists(HGui, "modalwindow")
    If Gadget.Window <> HGui.ModalWindow
      DBG.Console.Out("Event ignored, modal window active, event coming from another source...", DBG.Warning, HGui.DebugChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
      Return(False)
    EndIf
  EndIf
   
  ; Se sto draggando un cursore di una scrollbar ignoro altri eventi
  If HGui.ScrollBarDragging
    Return(False)
  EndIf
  
   ; Gestione menu contestuali
   ; - quando un gadget viene evidenziato i menu contestuali della
   ; relativa finestra devono essere disabilitati per non generare doppi
   ; eventi.
   Gadget.Window.IgnoreRMBUp = True
   
   ; Vediamo se con questo risolvo il bug della scrollbar con cursore che rimane
   ; appiccicato al mouse
   
   ; Se esiste un gadget attivo devo disattivarlo prima
   If TB.Item.Exists(HGui, "activegadget")
    HGui.gadgetEvent_Out({ userdata = { area = { object = HGui.ActiveGadget }}}, True)
   EndIf
   
   Switch Gadget.type
      ;:: KNOB
      Case #HGUI_KNOB_GADGET

      ;:: BUTTON :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_BUTTON_GADGET
         If Gadget.Status = #HGUI_NORMAL_STATE
            If IsLeftMouse()
               If TB.Item.Exists(HGui, "pushedout_gadget")
                  If HGui.PushedOut_Gadget = Gadget
                     Gadget.Status = #HGUI_PUSHED_STATE
                     HGui.PushedOut_Gadget = Nil
                     Gadget:Render()
                     DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
                     Return()
                  EndIf
               Else
                  ;Return()
               EndIf
            EndIf
            Gadget.Status = #HGUI_HILIGHTED_STATE
            Gadget:Render()

            ;                                                :: ON OVER SOUND ::
            If TB.Item.Exists(Gadget.Sounds, "onover")
               If IsSamplePlaying(Gadget.Sounds.OnOver) Then StopSample(Gadget.Sounds.OnOver)
               PlaySample(Gadget.Sounds.OnOver)
            EndIf

            ;                                                :: ON OVER EVENT ::
            If TB.Item.Exists(Gadget.Actions, "onover")
               DBG.Console.Out("::: Executing <OnOver> callback function :::", Nil, HGui.DebugChannel)
               Gadget.Actions.OnOver(Gadget)
               ;DBG.Console.Out("::: Done. :::", DBG.CloseFunc, HGui.DebugChannel)
               ;Return(True)
            EndIf
            
         Else
            DBG.Console.Out("Event not handled for <" .. Gadget.Status .. "> gadget's status.", DBG.Warning, HGui.DebugChannel)
            DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
            Return(False)
         EndIf

      ;:: TEXT :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_TEXT_GADGET
         If Gadget.Status = #HGUI_NORMAL_STATE
            If IsLeftMouse()
               If TB.Item.Exists(HGui, "pushedout_gadget")
                  If HGui.PushedOut_Gadget = Gadget
                     Gadget.Status = #HGUI_PUSHED_STATE
                     HGui.PushedOut_Gadget = Nil
                     Gadget:Render()
                     DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
                     Return()
                  EndIf
               Else
                  ;Return()
               EndIf
            EndIf
            Gadget.Status = #HGUI_HILIGHTED_STATE
            Gadget:Render()

            ;                                                :: ON OVER SOUND ::
            If TB.Item.Exists(Gadget.Sounds, "onover")
               If IsSamplePlaying(Gadget.Sounds.OnOver) Then StopSample(Gadget.Sounds.OnOver)
               PlaySample(Gadget.Sounds.OnOver)
            EndIf

            ;                                                :: ON OVER EVENT ::
            If TB.Item.Exists(Gadget.Actions, "onover")
               DBG.Console.Out("::: Executing <OnOver> callback function :::", Nil, HGui.DebugChannel)
               Gadget.Actions.OnOver(Gadget)
               DBG.Console.Out("::: Done. :::", DBG.CloseFunc, HGui.DebugChannel)
               Return(True)
            EndIf

         Else
            DBG.Console.Out("Event not handled for <" .. Gadget.Status .. "> gadget's status.", DBG.Warning, HGui.DebugChannel)
            DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
            Return(False)
         EndIf

      ;:: SWITCH :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_SWITCH_GADGET

         If Gadget.Status = #HGUI_NORMAL_STATE
            ;---| NORMAL STATE |------------------------------------------------
            If IsLeftMouse()
               If TB.Item.Exists(HGui, "pushedout_gadget")
                  If HGui.PushedOut_Gadget = Gadget
                     Gadget.Status = #HGUI_PUSHED_STATE
                     HGui.PushedOut_Gadget = Nil
                     Gadget:Render()
                     DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
                     Return()
                  EndIf
               Else
                  ;Return()
               EndIf
            EndIf
            Gadget.Status = #HGUI_HILIGHTED_STATE
            Gadget:Render()

            ;                                                :: ON OVER SOUND ::
            If TB.Item.Exists(Gadget.Sounds, "onover")
               If IsSamplePlaying(Gadget.Sounds.OnOver) Then StopSample(Gadget.Sounds.OnOver)
               PlaySample(Gadget.Sounds.OnOver)
            EndIf

            ;                                                :: ON OVER EVENT ::
            If TB.Item.Exists(Gadget.Actions, "onover")
               DBG.Console.Out("::: Executing <OnOver> callback function :::", Nil, HGui.DebugChannel)
               Gadget.Actions.OnOver(Gadget)
               DBG.Console.Out("::: Done. :::", DBG.CloseFunc, HGui.DebugChannel)
               Return(True)
            EndIf

         ElseIf Gadget.Status = #HGUI_NPUSHED_STATE
            ;---| NPUSHED STATE |-----------------------------------------------
            If IsLeftMouse()
               If TB.Item.Exists(HGui, "pushedout_gadget")
                  If HGui.PushedOut_Gadget = Gadget
                     Gadget.Status = #HGUI_PUSHED_STATE
                     HGui.PushedOut_Gadget = Nil
                     Gadget:Render()
                     DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
                     Return()
                  EndIf
               Else
                  ;Return()
               EndIf
            EndIf
            Gadget.Status = #HGUI_HPUSHED_STATE
            Gadget:Render()

            ;                                                :: ON OVER SOUND ::
            If TB.Item.Exists(Gadget.Sounds, "onover")
               If IsSamplePlaying(Gadget.Sounds.OnOver) Then StopSample(Gadget.Sounds.OnOver)
               PlaySample(Gadget.Sounds.OnOver)
            EndIf

            ;                                                :: ON OVER EVENT ::
            If TB.Item.Exists(Gadget.Actions, "onover")
               DBG.Console.Out("::: Executing <OnOver> callback function :::", Nil, HGui.DebugChannel)
               Gadget.Actions.OnOver(Gadget)
               DBG.Console.Out("::: Done. :::", DBG.CloseFunc, HGui.DebugChannel)
               Return(True)
            EndIf

         Else
            DBG.Console.Out("Event not handled for <" .. Gadget.Status .. "> gadget's status.", DBG.Warning, HGui.DebugChannel)
            DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
            Return(False)
         EndIf



      ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Default
         DBG.Console.Out("Unknown gadget class <" .. Gadget.type .. ">,  failed to handle this event.", DBG.Error, HGui.DebugChannel)
         DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
         Return(False)

   EndSwitch

   If TB.Item.Exists(Gadget, "tip")
      Local xpos = GetAttribute(#DISPLAY, Gadget.window.private.HWId, #ATTRXPOS) + GetAttribute(#DISPLAY, Gadget.window.private.HWId, #ATTRBORDERLEFT)
      Local ypos = GetAttribute(#DISPLAY, Gadget.window.private.HWId, #ATTRYPOS) + GetAttribute(#DISPLAY, Gadget.window.private.HWId, #ATTRBORDERTOP)
      HGui.Tip.TimeoutID = SetTimeout(Nil, HGui.Tip.Open, 2000, { position = { x = xpos, y = ypos }, Tip = Gadget.Tip, win=Gadget.window })
   EndIf

   ;=== Added this section to set the active gadget for MouseWheel handling routines ===
   HGui.ActiveGadget = Gadget
   ;===
   
   DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
   Return(True)

EndFunction

Function HGui.gadgetEvent_Out(msg, Quiet) ; *TriDoc*
/*---------------------------------------------------------
HGui.gadgetEvent_Out(msg, Quiet)

Internal function called whenever a gadget receives a <Mouse Out> event.
---------------------------------------------------------*/
  If IsNil(Quiet) Then Quiet = False
  
   Local Gadget = msg.userdata.area.object
   DBG.Console.Out("[ HGui.gadgetEvent_Out ] Gadget <" .. Gadget.Name .. "> Mouse Out event.", DBG.OpenFunc, HGui.DebugChannel)

   HGui.Tip.Close()

   If Not(HGui.EventHandling)
      DBG.Console.Out("Event ignored, EventHandling is switched off.", DBG.Warning, HGui.DebugChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
      Return(False)
   EndIf  
   
   If TB.Item.Exists(HGui, "modalwindow")
    If Gadget.Window <> HGui.ModalWindow
      DBG.Console.Out("Event ignored, modal window active, event coming from another source...", DBG.Warning, HGui.DebugChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
      Return(False)
    EndIf
  EndIf
   
   ; Gestione menu contestuali
   ; - quando un gadget torna normale i menu contestuali della
   ; relativa finestra devono essere riabilitati per non generare doppi
   ; eventi.
   Gadget.Window.IgnoreRMBUp = False
   
   Switch Gadget.type
      ;:: KNOB
      Case #HGUI_KNOB_GADGET

      ;:: BUTTON :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_BUTTON_GADGET
         If Gadget.Status = #HGUI_HILIGHTED_STATE
            Gadget.Status = #HGUI_NORMAL_STATE
            Gadget:Render(Nil, Nil, Quiet) ; Serve per riportare lo stato normale
                                           ; quando c'√® un gadget evidenziato in
                                           ; un'altra finestra

            ;                                                 :: ON OUT SOUND ::
            If TB.Item.Exists(Gadget.Sounds, "onout")
               If IsSamplePlaying(Gadget.Sounds.OnOut) Then StopSample(Gadget.Sounds.OnOut)
               PlaySample(Gadget.Sounds.OnOut)
            EndIf

            ;                                                 :: ON OUT EVENT ::
            If TB.Item.Exists(Gadget.Actions, "onout")
               DBG.Console.Out("::: Executing <OnOut> callback function :::", Nil, HGui.DebugChannel)
               Gadget.Actions.OnOut(Gadget)
               DBG.Console.Out("::: Done. :::", DBG.CloseFunc, HGui.DebugChannel)
               Return(True)
            EndIf
            
         ElseIf Gadget.Status = #HGUI_PUSHED_STATE
            If Not(Gadget.Private.IsCursor)
               Gadget.Status = #HGUI_NORMAL_STATE
               Gadget:Render()
               HGui.PushedOut_Gadget = Gadget
            EndIf

         Else
            DBG.Console.Out("Event not handled for <" .. Gadget.Status .. "> gadget's status.", DBG.Warning, HGui.DebugChannel)
            DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
            Return(False)
         EndIf

      ;:: TEXT :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_TEXT_GADGET
         If Gadget.Status = #HGUI_HILIGHTED_STATE
            Gadget.Status = #HGUI_NORMAL_STATE
            Gadget:Render()

            ;                                                 :: ON OUT SOUND ::
            If TB.Item.Exists(Gadget.Sounds, "onout")
               If IsSamplePlaying(Gadget.Sounds.OnOut) Then StopSample(Gadget.Sounds.OnOut)
               PlaySample(Gadget.Sounds.OnOut)
            EndIf

            ;                                                 :: ON OUT EVENT ::
            If TB.Item.Exists(Gadget.Actions, "onout")
               DBG.Console.Out("::: Executing <OnOut> callback function :::", Nil, HGui.DebugChannel)
               Gadget.Actions.OnOut(Gadget)
               DBG.Console.Out("::: Done. :::", DBG.CloseFunc, HGui.DebugChannel)
               Return(True)
            EndIf

         ElseIf Gadget.Status = #HGUI_PUSHED_STATE
            If Not(Gadget.Private.IsCursor)
               Gadget.Status = #HGUI_NORMAL_STATE
               Gadget:Render()
               HGui.PushedOut_Gadget = Gadget
            EndIf

         Else
            DBG.Console.Out("Event not handled for <" .. Gadget.Status .. "> gadget's status.", DBG.Warning, HGui.DebugChannel)
            DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
            Return(False)
         EndIf

      ;:: SWITCH :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Case #HGUI_SWITCH_GADGET
         If Gadget.Status = #HGUI_HILIGHTED_STATE
            ;---| HILIGHTED STATE |---------------------------------------------
            Gadget.Status = #HGUI_NORMAL_STATE
            Gadget:Render()

            ;                                                 :: ON OUT SOUND ::
            If TB.Item.Exists(Gadget.Sounds, "onout")
               If IsSamplePlaying(Gadget.Sounds.OnOut) Then StopSample(Gadget.Sounds.OnOut)
               PlaySample(Gadget.Sounds.OnOut)
            EndIf

            ;                                                :: ON DOWN EVENT ::
            If TB.Item.Exists(Gadget.Actions, "onout")
               DBG.Console.Out("::: Executing <OnOut> callback function :::", Nil, HGui.DebugChannel)
               Gadget.Actions.OnOut(Gadget)
               DBG.Console.Out("::: Done. :::", DBG.CloseFunc, HGui.DebugChannel)
               Return(True)
            EndIf

         ElseIf Gadget.Status = #HGUI_HPUSHED_STATE
            ;---| HPUSHED STATE |-----------------------------------------------
            Gadget.Status = #HGUI_NPUSHED_STATE
            Gadget:Render()

            ;                                                 :: ON OUT SOUND ::
            If TB.Item.Exists(Gadget.Sounds, "onout")
               If IsSamplePlaying(Gadget.Sounds.OnOut) Then StopSample(Gadget.Sounds.OnOut)
               PlaySample(Gadget.Sounds.OnOut)
            EndIf

            ;                                                :: ON DOWN EVENT ::
            If TB.Item.Exists(Gadget.Actions, "onout")
               DBG.Console.Out("::: Executing <OnOut> callback function :::", Nil, HGui.DebugChannel)
               Gadget.Actions.OnOut(Gadget)
               DBG.Console.Out("::: Done. :::", DBG.CloseFunc, HGui.DebugChannel)
               Return(True)
            EndIf

         ElseIf Gadget.Status = #HGUI_PUSHED_STATE
            If Gadget.private.Value = 1
               Gadget.Status = #HGUI_NPUSHED_STATE
               Gadget:Render()
               HGui.PushedOut_Gadget = Gadget
            ElseIf Gadget.private.Value = 0
               Gadget.Status = #HGUI_NORMAL_STATE
               Gadget:Render()
               HGui.PushedOut_Gadget = Gadget
            EndIf

         Else
            DBG.Console.Out("Event not handled for <" .. Gadget.Status .. "> gadget's status.", DBG.Warning, HGui.DebugChannel)
            DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
            Return(False)
         EndIf


      ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Default
         DBG.Console.Out("Unknown gadget class <" .. Gadget.type .. ">,  failed to handle this event.", DBG.Error, HGui.DebugChannel)
         DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
         Return(False)

   EndSwitch

   ;=== Added this section to set the active gadget for MouseWheel handling routines ===
   HGui.ActiveGadget = Nil
   ;===
   
   DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
   Return(True)

EndFunction

Function HGui.listViewContentEvent_LMBDown(msg) ; *TriDoc* *Incomplete*
/*---------------------------------------------------------
HGui.listViewContentEvent_LMBDown(msg)

This function is called when a ListView gadget receive a left mouse click down
on its body.
-----------------------------------------------------------
NOTES
  NOT YET AVAILABLE, but the event is detected.
---------------------------------------------------------*/

EndFunction

Function HGui.treeViewContentEvent_LMBDown(msg) ; *TriDoc* *Incomplete*
/*---------------------------------------------------------
HGui.treeViewContentEvent_LMBDown(msg)

This function is called when a TreeView gadget receive a left mouse click down
on its body.
-----------------------------------------------------------
NOTES
  NOT YET AVAILABLE, but the event is detected.
---------------------------------------------------------*/

EndFunction

Function HGui.canvasEvent_Over(msg) ; *TriDoc*
/*---------------------------------------------------------
HGui.canvasEvent_Over(msg)

Internal function used to manage the mouse pointer inside a canvass gadget.
---------------------------------------------------------*/
   Local Gadget = msg.userdata.area.object
   ;=== Added this section to set the active gadget for MouseWheel handling routines ===
   HGui.ActiveGadget = Gadget
   ;===
    InstallEventHandler({ OnMouseMove = HGui.windowEvent_MouseMove }, Gadget)

EndFunction

Function HGui.canvasEvent_Out(msg) ; *TriDoc*
/*---------------------------------------------------------
HGui.canvasEvent_Out(msg)

Internal function used to handle the mouse pointer when exits from a canvas gadget.
---------------------------------------------------------*/
   Local Gadget = msg.userdata.area.object
   ;=== Added this section to set the active gadget for MouseWheel handling routines ===
   HGui.ActiveGadget = Nil
   ;===
   InstallEventHandler({ OnMouseMove = 0 })

EndFunction

Function HGui.listViewContentEvent_LMBUp(msg) ; *TriDoc*
/*---------------------------------------------------------
HGui.listViewContentEvent_LMBUp(msg)

Internal function used to handle the listView items selection using the
left mouse button up event.
---------------------------------------------------------*/
   Local Gadget = msg.userdata.area.object

   If TB.Item.Exists(HGui, "modalwindow")
    If Gadget.Window <> HGui.ModalWindow
      DBG.Console.Out("Event ignored, modal window active, event coming from another source...", DBG.Warning, HGui.DebugChannel)
      Return(False)
    EndIf
  EndIf

   GFX.OutputDevice.Select(#DISPLAY, msg.userdata.area.object.window.private.HWId)   
   Local relX = MouseX()-Gadget.Area.Position.x
   Local relY = MouseY()-gadget.Area.Position.y
   Local item = Int(relY / Gadget.private.Father.EntryHeight) + Gadget.private.Father.FirstVisible
   GFX.OutputDevice.EndSelect()

   If item < 0 Then Return()

   If item < ListItems(Gadget.private.Father.Data.Items)
      If Gadget.private.Father.Multiselect
        Local selected, unselected = False, False
         If Gadget.private.Father.Data.Selected[item]
            Gadget.private.Father.Data.Selected[item] = False
            unselected = True
         Else
            Gadget.private.Father.Data.Selected[item] = True
            Gadget.private.Father.Data.LastSelected = item
            selected = True
         EndIf
         HGui.ListView_ContentsUpdate(Gadget.private.Father)
         If TB.Item.Exists(Gadget.private.Father, "onchange")
            Gadget.private.Father.OnChange(Gadget.private.Father, Gadget.private.Father.Data.Items, Gadget.private.Father.Data.Selected, Item)
         EndIf
         If TB.Item.Exists(Gadget.private.Father, "onselect") And selected
           Gadget.private.Father.OnSelect(Gadget.private.Father, Gadget.private.Father.Data.Items, Gadget.private.Father.Data.Selected, Item)
         EndIf
         If TB.Item.Exists(Gadget.private.Father, "onunselect") And unselected
           Gadget.private.Father.OnUnselect(Gadget.private.Father, Gadget.private.Father.Data.Items, Gadget.private.Father.Data.Selected, Item)
         EndIf
      Else
         If Gadget.private.Father.Data.Selected[item]
            ; permetto la disattivazione?
         Else
            For Local i = 0 To ListItems(Gadget.private.Father.Data.Selected)-1
               Gadget.private.Father.Data.Selected[i] = False
            Next
            Gadget.private.Father.Data.Selected[item] = True
            Gadget.private.Father.Data.LastSelected = item
            HGui.ListView_ContentsUpdate(Gadget.private.Father)
            If TB.Item.Exists(Gadget.private.Father, "onchange")
              Gadget.private.Father.OnChange(Gadget.private.Father, Gadget.private.Father.Data.Items, Gadget.private.Father.Data.Selected, Item)
            ElseIf TB.Item.Exists(Gadget.private.Father, "onselect")
              Gadget.private.Father.OnSelect(Gadget.private.Father, Gadget.private.Father.Data.Items, Gadget.private.Father.Data.Selected, Item)
            EndIf
         EndIf
      EndIf
   EndIf

EndFunction

Function HGui.treeView_SelectChilds(Parent, Item) ; *TriDoc*
/*---------------------------------------------------------
HGui.treeView_SelectChilds(Parent, Item)

Internal function used to handle the treeView children selection
---------------------------------------------------------*/
  DBG.Console.Out("[ HGui.treeView_SelectChilds() ]", DBG.OpenFunc)
  If TB.Item.Exists(Item, "childs")
    Local count = ListItems(Item.Childs) - 1
    For Local i = 0 To count
      Item.Childs[i]._Selected = True
      If TB.Item.Exists(Parent, "onselect")
        Local real = {}
        If TB.Item.Exists(parent.data.realItems, item)
          real = Parent.Data.realItems[item]
        EndIf
        Parent.OnSelect(Parent, Parent.Data.realItems, real, item)
      EndIf
      HGui.treeView_SelectChilds(Parent, Item.Childs[i])
    Next
  EndIf
  
  DBG.Console.Out(Nil, DBG.CloseFunc)

EndFunction

Function HGui.treeView_UnSelectChilds(Parent, Item) ; *TriDoc*
/*---------------------------------------------------------
HGui.treeView_UnSelectChilds(Parent, Item)

Internal function used to handle the treeView children deselection
---------------------------------------------------------*/
  DBG.Console.Out("[ HGui.treeView_UnSelectChilds ]", DBG.OpenFunc)

  If TB.Item.Exists(Item, "childs")
    Local count = ListItems(Item.Childs) - 1
    For Local i = 0 To count
      Item.Childs[i]._Selected = False
      If TB.Item.Exists(Parent, "onunselect")
        Parent.OnUnselect(Parent, Parent.Data.realItems, Parent.Data.realItems[item], item)
      EndIf
      HGui.treeView_UnSelectChilds(Parent, Item.Childs[i])
    Next
  EndIf
  
  DBG.Console.Out(Nil, DBG.CloseFunc)
EndFunction

Function HGui.treeViewContentEvent_LMBUp(msg) ; *TriDoc*
/*---------------------------------------------------------
HGui.treeViewContentEvent_LMBUp(msg)

Internal function used to handle the treeView items selection using the
left mouse button up event.
---------------------------------------------------------*/

  DBG.Console.Out("[ HGui.treeViewContentEvent_LMBUp() ]", DBG.OpenFunc)
  
  Local Gadget = msg.userdata.area.object
  
   If TB.Item.Exists(HGui, "modalwindow")
    If Gadget.Window <> HGui.ModalWindow
      DBG.Console.Out("Event ignored, modal window active, event coming from another source...", DBG.Warning, HGui.DebugChannel)
      Return(False)
    EndIf
  EndIf
  
  GFX.OutputDevice.Select(#DISPLAY, msg.userdata.area.object.window.private.HWId)
  Local relX = MouseX()-Gadget.Area.Position.x
  Local relY = MouseY()-gadget.Area.Position.y
  Local item = Int(relY / Gadget.private.Father.EntryHeight) + Gadget.private.Father.FirstVisible
  Local signOffset = Gadget.private.Father.EntryHeight
  GFX.OutputDevice.EndSelect()

  DBG.Console.Out("Click on item " .. item)
  
  If item < ListItems(Gadget.private.Father.Data.realItems)
    Local sItem = Gadget.private.Father.Data.realItems[item]
    If relX < signOffset*(sItem._Ident+1)+Gadget.private.Father.Headers[0].Look.Offset.x
      DBG.Console.Out("Click on fold/unfold area.")
      If TB.Item.Exists(sItem, "childs")
        DBG.Console.Out("Switching fold/unfold status")
        sItem._Opened = Not(sItem._Opened)
        Gadget.private.Father.Data.realItems = HGui.treeView_ElaborateList(Gadget.private.Father.Data.Items)

        HGui.treeView_ContentsUpdate(Gadget.private.Father)

        ; VScroller si autoimposta
        Local totalItems = ListItems(Gadget.private.Father.Data.realItems)
        Local totalVisible = Int(Gadget.private.Father.ListArea.Area.Size.h/Gadget.private.Father.EntryHeight)

        Gadget.private.Father.VScroller:set({ Value = Gadget.private.Father.VScroller.Private.Value, Range = { 0, totalItems-1, totalVisible-1 }}, True)
;Gadget.private.Father.VScroller:Render()

        DBG.Console.Out(Nil, DBG.CloseFunc)
        Return()
      EndIf
    EndIf

    ; DebugPrint("SG:" .. Gadget.private.Father.SelectGroups)
    If Not(Gadget.private.Father.SelectGroups) And TB.Item.Exists(Gadget.private.Father.Data.realItems[item], "childs")
      If ListItems(Gadget.private.Father.Data.realItems[item].childs) > 0
        DBG.Console.Out("Cannot select group items.", Nil)
        DBG.Console.Out(Nil, DBG.CloseFunc)
        Return()
      EndIf
    EndIf
    
    If Gadget.private.Father.Multiselect
      If Gadget.private.Father.Data.realItems[item]._Selected
        Gadget.private.Father.Data.realItems[item]._Selected = False
        If Gadget.private.Father.AutoUnselectChilds Then HGui.treeView_UnSelectChilds(Gadget.private.Father, Gadget.private.Father.Data.realItems[item])
        If TB.Item.Exists(Gadget.private.Father, "onunselect")
          Gadget.private.Father.OnUnselect(Gadget.private.Father, Gadget.private.Father.Data.realItems, Gadget.private.Father.Data.realItems[item], item)
        EndIf

      Else
        Gadget.private.Father.Data.realItems[item]._Selected = True
        If Gadget.private.Father.AutoSelectChilds Then HGui.treeView_SelectChilds(Gadget.private.Father, Gadget.private.Father.Data.realItems[item])
        If TB.Item.Exists(Gadget.private.Father, "onselect")
          Gadget.private.Father.OnSelect(Gadget.private.Father, Gadget.private.Father.Data.realItems, Gadget.private.Father.Data.realItems[item], item)
        EndIf

      EndIf
      HGui.treeView_ContentsUpdate(Gadget.private.Father)
      If TB.Item.Exists(Gadget.private.Father, "onchange")
        Gadget.private.Father.OnChange(Gadget.private.Father, Gadget.private.Father.Data.realItems, Gadget.private.Father.Data.realItems[item], item)
      EndIf
  
    Else
      If Gadget.private.Father.Data.realItems[item]._Selected
        For Local i = 0 To ListItems(Gadget.private.Father.Data.realItems)-1
          Gadget.private.Father.Data.realItems[i]._Selected = False
          HGui.treeView_UnSelectChilds(Gadget.private.Father, Gadget.private.Father.Data.realItems[item])
          If TB.Item.Exists(Gadget.private.Father, "onunselect")
            Gadget.private.Father.OnUnSelect(Gadget.private.Father, Gadget.private.Father.Data.realItems, Gadget.private.Father.Data.realItems[item], item)
          EndIf
        Next

        Gadget.private.Father.Data.realItems[item]._Selected = True
        HGui.treeView_SelectChilds(Gadget.private.Father, Gadget.private.Father.Data.realItems[item])
        If TB.Item.Exists(Gadget.private.Father, "onunselect")
          Gadget.private.Father.OnUnSelect(Gadget.private.Father, Gadget.private.Father.Data.realItems, Gadget.private.Father.Data.realItems[item], item)
        EndIf
        HGui.treeView_ContentsUpdate(Gadget.private.Father)
        If TB.Item.Exists(Gadget.private.Father, "onchange")
          Gadget.private.Father.OnChange(Gadget.private.Father, Gadget.private.Father.Data.realItems, Gadget.private.Father.Data.realItems[item], item)
        EndIf

      Else
        ; All items must be deselected
        For Local i = 0 To ListItems(Gadget.private.Father.Data.realItems)-1
          Gadget.private.Father.Data.realItems[i]._Selected = False
          HGui.treeView_UnSelectChilds(Gadget.private.Father, Gadget.private.Father.Data.realItems[i])
          If TB.Item.Exists(Gadget.private.Father, "onunselect")
            Gadget.private.Father.OnUnSelect(Gadget.private.Father, Gadget.private.Father.Data.realItems, Gadget.private.Father.Data.realItems[i], item)
          EndIf
        Next

        Gadget.private.Father.Data.realItems[item]._Selected = True
        If Gadget.private.Father.AutoSelectChilds Then HGui.treeView_SelectChilds(Gadget.private.Father, Gadget.private.Father.Data.realItems[item])
        If TB.Item.Exists(Gadget.private.Father, "onselect")
          Gadget.private.Father.OnSelect(Gadget.private.Father, Gadget.private.Father.Data.realItems, Gadget.private.Father.Data.realItems[item], item)
        EndIf

        HGui.treeView_ContentsUpdate(Gadget.private.Father)
        If TB.Item.Exists(Gadget.private.Father, "onchange")
          Gadget.private.Father.OnChange(Gadget.private.Father, Gadget.private.Father.Data.realItems)
        EndIf
      EndIf
    EndIf
  EndIf
  
  DBG.Console.Out(Nil, DBG.CloseFunc)
EndFunction

Function HGui.listViewContentEvent_Out(msg) ; *TriDoc*
/*---------------------------------------------------------
HGui.listViewContentEvent_Out(msg)

Internal function called when the mouse pointer exits from a listView gadget body.
---------------------------------------------------------*/
   Local Gadget = msg.userdata.area.object
   ;=== Added this section to set the active gadget for MouseWheel handling routines ===
   HGui.ActiveGadget = Nil
   ;===
EndFunction

Function HGui.treeViewContentEvent_Out(msg) ; *TriDoc*
/*---------------------------------------------------------
HGui.treeViewContentEvent_Out(msg)

Internal function called when the mouse pointer exits from a treeView gadget body.
---------------------------------------------------------*/
   Local Gadget = msg.userdata.area.object
   ;=== Added this section to set the active gadget for MouseWheel handling routines ===
   HGui.ActiveGadget = Nil
   ;===
EndFunction

Function HGui.listViewContentEvent_Over(msg) ; *TriDoc*
/*---------------------------------------------------------
HGui.listViewContentEvent_Over(msg)

Internal function called when the mouse pointer enters in a listView gadget body.
---------------------------------------------------------*/
   Local Gadget = msg.userdata.area.object
   ;=== Added this section to set the active gadget for MouseWheel handling routines ===
   HGui.ActiveGadget = Gadget.private.Father
   ;===

EndFunction

Function HGui.treeViewContentEvent_Over(msg) ; *TriDoc*
/*---------------------------------------------------------
HGui.treeViewContentEvent_Over(msg)

Internal function called when the mouse pointer enters in a treeView gadget body.
---------------------------------------------------------*/
   Local Gadget = msg.userdata.area.object
   ;=== Added this section to set the active gadget for MouseWheel handling routines ===
   HGui.ActiveGadget = Gadget.private.Father
   ;===

EndFunction

Function HGui.Menu_Close() ; *TriDoc*
/*-------------------------------------------------------------------
HGui.Menu_Close()

This function closes any opened drop-down menu.
------------------------------------------------------------------*/
  Local parentWindow, closed = {}, False
   For Local i = ListItems(HGui.MenuWindows)-1 To 0 Step -1
      ;HGui.MenuWindows[i]:Activate()
      If TB.Item.Exists(HGui.MenuWindows[i], "parentwindow")
        parentWindow = HGui.MenuWindows[i].ParentWindow
      EndIf
      HGui.MenuWindows[i]:Free()
      closed = True
   Next
   
   HGui.MenuWindows = {}
   If TB.Item.Exists(parentWindow, "activate") And closed
     parentWindow:Activate()
   EndIf
EndFunction

Function HGui.Menu_PrebuiltItem(Menu) ; *TriDoc*
/*-------------------------------------------------------------------
HGui.Menu_PrebuiltItem(Menu)

Internal function used to prebuild a menu layout.
---------------------------------------------------------------------
INPUT
  Menu : A table describing the menu structure.

OUTPUT
  Root : Returns the 'root' gadget (with all the children) that will be attached to a window.
------------------------------------------------------------------*/
  ; Root gadget creation
  Menu.Params.Root.Window = Menu.Params.Window
  Local root = HGui.Gadget:New(Menu.Params.Root.Type, Menu.Params.Root.Params)
  Local childs = {}
  For Local g = 0 To ListItems(Menu.Params.Childs)-1
    Menu.Params.Childs[g].Params.Window = Menu.Params.Window
    childs[g] = HGui.Gadget:New(Menu.Params.Childs[g].Type, Menu.Params.Childs[g].Params)
    childs[g].MenuDef = Menu.Params.Childs[g]
    childs[g].MenuRoot = Menu
  Next
  
  ; Crazione layout
  Local weights, gap, borders, columns, rows
  If TB.Item.Exists(Menu.Params, "gap")
    gap = Menu.Params.Gap
  EndIf
  If TB.Item.Exists(Menu.Params, "weights")
    weights = Menu.Params.Weights
  EndIf
  If TB.Item.Exists(Menu.Params, "borders")
    borders = Menu.Params.Borders
  EndIf
  If TB.Item.Exists(Menu.Params, "columns")
    columns = Menu.Params.columns
  EndIf
  If TB.Item.Exists(Menu.Params, "rows")
    rows = Menu.Params.rows
  EndIf
  
  Local setup = 
  root:layoutSet({ gadgets = childs,
                   weights = weights,
                   gap = gap,
                   columns = columns,
                   rows = rows,
                   type = Menu.params.layout,
                   borders = borders
                   }, True )

  Return(root)

EndFunction

Function HGui.Menu_FindItem(Menu, ItemName) ; *TriDoc*
/*-------------------------------------------------------------------
itemDef = HGui.Menu_FindItem(Menu, ItemName)

Returns the menu item's definition in a menu definition table
---------------------------------------------------------------------
INPUT
  Menu     : Menu definition table
  ItemName : Item name to search

OUTPUT
  itemDef : Nil if the item was'nt found or the item definition table
------------------------------------------------------------------*/
  Local i, v
  For i, v In IPairs(Menu)
    If TB.Item.Exists(v, "params")
      If TB.Item.Exists(v.Params, "name")
        If v.Params.Name = ItemName
          Return(v)
        EndIf
      ElseIf TB.Item.Exists(v.Params, "childs") And v.Type = #HGUI_PREBUILT_GROUP
        Local result = HGui.Menu_FindItem(v.Params.Childs, ItemName)
        If Not(IsNil(result)) Then Return(result)
      EndIf
    ElseIf TB.Item.Exists(v, "submenu")
      Local result = HGui.Menu_FindItem(v.SubMenu, ItemName)
      If Not(IsNil(result)) Then Return(result)
    EndIf
  Next

  Return(Nil)
  
EndFunction

Function HGui.Menu_Selected(msg) ; *TriDoc*
/*-------------------------------------------------------------------
HGui.Menu_Selected(msg)

Callback function called when a menu item has been selected by the user.
---------------------------------------------------------------------
INPUT
  msg : The message generated by the event handler.
------------------------------------------------------------------*/
  Local Gadget  = msg
  Local MenuDef = Gadget.MenuDef
  Local subMenuTheme = HGui.Theme.SubMenu

  ; Callback function
  If TB.Item.Exists(MenuDef, "callback")
    MenuDef.Callback(Gadget)
  EndIf

  ; Subitems?
  If TB.Item.Exists(MenuDef, "submenu")
    If ListItems(MenuDef.SubMenu) > 0
      ; Open a submenu & enter opened men√π mode
      Local Menu    = MenuDef.SubMenu
      Local Count   = ListItems(Menu)-1
      Local Gadgets = {}
      Local Sizes   = {}
      Local wHeight = 0
      Local wWidth  = 0

      ; Calcolo dimensioni
      SetFont(#SANS, subMenuTheme.Height, { Engine = #FONTENGINE_INBUILT }); + subMenuTheme.FontOffset) 
      For Local i = 0 To Count
        If TB.Item.Exists(Menu[i], "size")
          Sizes[i] = Menu[i].Size
        Else
          Sizes[i] = subMenuTheme.Height + subMenuTheme.Gap
        EndIf

        wHeight = wHeight + Sizes[i] ;+ HGui.Theme.SubMenu.Gap

        If TB.Item.Exists(Menu[i].Params, "caption")
          Local tw = GFX.Text.GetWidth(Menu[i].Params.Caption .. "...") + subMenuTheme.Borders.Left + subMenuTheme.Borders.Right
          wWidth = Max(wWidth, tw)
        EndIf
      Next
         
      If TB.Item.Exists(Menu, "menuwidth") Then wWidth = Menu.MenuWidth

      ;[TODO] : commentato perch√® per ora non e√® utilizzato
      ; nel layout e mi causa problemi quando ho un solo elemento
      ; nel sottomenu
      ; wHeight = wHeight - subMenuTheme.Borders.Top - subMenuTheme.Borders.Bottom

      For Local i = 0 To ListItems(Sizes)-1
        Sizes[i] = Sizes[i]/wHeight
      Next
         
      ; corregge eventuali arrotandamenti
      Local total, pixels = 0, 0
      For Local i = 0 To ListItems(Sizes)-1 Do total = total+Sizes[i]
      If total <> 1 Then pixels = (total-1)*wHeight

      ; Chiude eventuali sottomen√π
      Local pos = -1
      For Local i = 0 To ListItems(HGui.MenuWindows)-1
        If HGui.MenuWindows[i] = Gadget.Window
          pos = i
          Break
        EndIf
      Next

      For Local i = pos+1 To ListItems(HGui.MenuWindows)-1
        ;HGui.MenuWindows[i]:Close()
        HGui.MenuWindows[i]:Free()
        RemoveItem(HGui.MenuWindows, i)
      Next

      ; Creazione finestra
      Local xpos, ypos = Gadget.Area.Position.x, Gadget.Area.Position.y
      xpos = xpos + Gadget.Window.Position.x + GetAttribute(#DISPLAY, Gadget.Window.Private.HWId, #ATTRBORDERLEFT) + Gadget.Area.Size.w - HGui.Theme.SubMenu.MenuHOverlap
      ypos = ypos + Gadget.Window.Position.y + GetAttribute(#DISPLAY, Gadget.Window.Private.HWId, #ATTRBORDERTOP) - HGui.Theme.SubMenu.MenuVOverlap
      MenuWindow = HGui.Window:new({ bgcolor = HGui.Theme.SubMenu.BGColor,
                                    ;events = { OnDeactivate = HGui.DropDown_Close },
                                    name = "::Menu::" .. HL.GetRndName(),
                                    flags = { hidefromtaskbar = True, borderless = True, moveable = False, resizeable = False },
                                    position = { x = xpos, y = ypos },
                                    size = { w = wWidth, h = wHeight+pixels*2 } })
      MenuWindow.IsMenu = True
      MenuWindow.ParentWindow = Gadget.Window

      InsertItem(HGui.MenuWindows, MenuWindow)

      ; Creazione Gadget
      HGui.SetAutoRendering(False)
      For Local i = 0 To Count
        ; *** ricordarsi della gestione dei sottomen√π ***
        ; Applica il tema di default
        Local defTheme = CopyTable(subMenuTheme.ItemsLook)
        If TB.Item.Exists(Menu[i].Params, "look")
          TB.Merge(defTheme, Menu[i].Params.Look, True)
        EndIf
        Menu[i].Params.Look = defTheme
        For i, v In Pairs(Menu[i].Params.Look)
          If TB.Item.Exists(v, "font") Then v.Font.Size = subMenuTheme.Height + subMenuTheme.FontOffset
        Next
        Menu[i].Params.Window = MenuWindow
        
        If Menu[i].Type <> #HGUI_PREBUILT_GROUP
          Gadgets[i] = HGui.Gadget:New(Menu[i].Type, Menu[i].Params)
        Else
          Gadgets[i] = HGui.Menu_PrebuiltItem(Menu[i])
        EndIf
        
        If TB.Item.Exists(Menu[i], "submenu")
          If ListItems(Menu[i].SubMenu) > 0 Then Gadgets[i]:Set({ Caption = Menu[i].Params.Caption ..  "..." }, False)
        EndIf
        Gadgets[i].MenuDef = Menu[i]
        Gadgets[i].MenuRoot = Menu
        Gadgets[i].ParentWindow = Gadget.Window
        If TB.Item.IsNil(Menu[i].Params, "actions")
          Gadgets[i].Actions.OnPushed = HGui.Menu_Selected
        ElseIf TB.Item.IsNil(Menu[i].Params.Actions, "onpushed")
          Gadgets[i].Actions.OnPushed = HGui.Menu_Selected
        EndIf
      Next
      
      ; Creazione del layout
      HGui.SetAutoRendering(True)
      MenuWindow.Root:Free()
      MenuWindow.root = HGui.Gadget:new(#HGUI_BOX_GADGET, { window = MenuWindow, name = HL.GetRndName(), look = { nskin = HGui.theme.SubMenu.RootSkin }, size = { w = MenuWindow.size.w - 1, h = MenuWindow.size.h - 1 }, usecache = MenuWindow.CacheRoot } )
      MenuWindow.root.private.IsRoot = True
      MenuWindow.Root:layoutSet({ gadgets = Gadgets,
                                  weights = Sizes,
                                  gap = 0,;HGui.Theme.SubMenu.Gap,
                                  borders = { top = subMenuTheme.Borders.Top, bottom = subMenuTheme.Borders.Bottom, left = subMenuTheme.Borders.Left, right = subMenuTheme.Borders.Right } }, True )

      HGui.SetAutoRendering(True)
      MenuWindow:Activate()
      SelectDisplay(MenuWindow.Private.HWId)
      InstallEventHandler({ OnMouseMove = HGui.Menu_MouseMoved })
      MenuWindow:Render()
    EndIf
  Else
    ; Non ci sono sottomen√π, chiudo tutto
    HGui.Menu_Close()
  EndIf

EndFunction

Function HGui.Menu_MouseMoved(msg) ; *TriDoc*
/*-------------------------------------------------------------------
HGui.Menu_MouseMoved(msg)

Identify and activate the display/window where the mouse pointer is
positioned.
---------------------------------------------------------------------
INPUT
  msg : Message generated by the OnMouseMove event.

NOTES
  Internal function used to pop to front the menu window where the mouse pointer is located.
------------------------------------------------------------------*/
  ; Identifica su quale finestra si trova il mouse

  ; Devo trasformare le coordinate locali in coordinate globali
  ; Adesso sono relative alla finestra attiva che √® HGui.ActiveWindow
  Local globX = msg.X + HGui.ActiveWindow.Position.x
  Local globY = msg.Y + HGui.ActiveWindow.Position.y

  ; Adesso verifica le finestre di men√π
  Local i, v
  For i, v In Pairs(HGui.MenuWindows)
    If globX >= v.Position.x And globX <= v.Position.x+v.Size.w-HGui.Theme.SubMenu.HorizontalOverlap*2
      If globY >= v.Position.y And globY <= v.Position.y+v.Size.h
        SelectDisplay(v.Private.HWId)
        ; La cerca in WinOrder e la porta in testa
        For Local k = 0 To ListItems(HGui.WinOrder)-1
          If HGui.WinOrder[k] = v
            HGui.WinOrder[0], HGui.WinOrder[k] = HGui.WinOrder[k], HGui.WinOrder[0]
            Break()
          EndIf
        Next
        Break()
      EndIf
    EndIf
  Next

EndFunction

Function HGui.Menu_Open(msg) ; *TriDoc*
/*-------------------------------------------------------------------
HGui.Menu_Open(msg)

Opens a menu described by the 'msg' table.
---------------------------------------------------------------------
INPUT
  msg : A gadget with attached the menu structure to open.

NOTES
  See the appendix for more details and examples.
------------------------------------------------------------------*/
  DBG.Console.Out(".Menu_Open()", DBG.OpenFunc, HGui.WChannel)
  
  Local Gadget = msg
  Local MenuDef = Gadget.MenuDef

  ; Chiude menu precedenti
  HGui.Menu_Close()

  ; Callback function
  If TB.Item.Exists(MenuDef, "callback")
    MenuDef.Callback(Gadget)
  EndIf

  ; Subitems? (Also used by Contextual Menus)
  If TB.Item.Exists(MenuDef, "submenu")
    If ListItems(MenuDef.SubMenu) > 0
      ; Open a submenu & enter opened men√π mode
      Local Menu = MenuDef.SubMenu
      Local Count = ListItems(Menu)-1
      Local Gadgets = {}
      Local Sizes = {}
      Local wHeight = 0
      Local wWidth = 0

      SetFont(#SANS, HGui.Theme.SubMenu.Height - HGui.Theme.SubMenu.FontOffset, { Engine = #FONTENGINE_INBUILT })
      ;SetFontStyle(#BOLD+#ANTIALIAS)
      For Local i = 0 To Count
        If TB.Item.Exists(Menu[i], "size")
          Sizes[i] = Menu[i].Size
        Else
          Sizes[i] = HGui.Theme.SubMenu.Height + HGui.Theme.SubMenu.Gap
        EndIf

        wHeight = wHeight + Sizes[i] ; + HGui.Theme.SubMenu.Gap

        If TB.Item.Exists(Menu[i].Params, "caption")
          Local tw = GFX.Text.GetWidth(Menu[i].Params.Caption .. "...") + HGui.Theme.SubMenu.Borders.Left + HGui.Theme.SubMenu.Borders.Right
          wWidth = Max(wWidth, tw)
        EndIf
            
      Next
         
      If TB.Item.Exists(Menu, "menuwidth")
        wWidth = Menu.menuWidth
      EndIf
         
      Local subMenuTheme = HGui.Theme.subMenu
      wHeight = wHeight - subMenuTheme.Borders.Top - subMenuTheme.Borders.Bottom
         
      For Local i = 0 To ListItems(Sizes)-1
        Sizes[i] = Sizes[i]/wHeight
      Next
      ; corregge eventuali arrotandamenti
      Local total, pixels = 0, 0
/*
          For Local i = 0 To ListItems(Sizes)-1 Do total = total+Sizes[i]
          If total <> 1 Then pixels = (total-1)*wHeight
*/
      ; Creazione finestra
      Local xpos, ypos = Gadget.Area.Position.x, Gadget.Area.Position.y
      xpos = xpos + Gadget.Window.Position.x + GetAttribute(#DISPLAY, Gadget.Window.Private.HWId, #ATTRBORDERLEFT)
      ypos = ypos + Gadget.Window.Position.y + GetAttribute(#DISPLAY, Gadget.Window.Private.HWId, #ATTRBORDERTOP) + Gadget.Area.Size.h

      MenuWindow = HGui.Window:new({ bgcolor = HGui.Theme.SubMenu.BGColor,
                                     ;events = { OnMouseMove = HGui.Menu_MouseMoved },
                                     name = "::Menu::" .. HL.GetRndName(),
                                     flags = { borderless = True, moveable = False, resizeable = False, HideFromTaskBar = True },
                                     position = { x = xpos, y = ypos },
                                     size = { w = wWidth, h = wHeight+pixels*2 } })

      MenuWindow.IsMenu = True
      MenuWindow.ParentWindow = Gadget.Window
      InsertItem(HGui.MenuWindows, MenuWindow)
      InstallEventHandler({ OnMouseMove = HGui.Menu_MouseMoved })


      ; Creazione Gadget
      HGui.SetAutoRendering(False)
      For Local i = 0 To Count
        ; *** ricordarsi della gestione dei sottomen√π ***
        Menu[i].Params.Look   = CopyTable(HGui.Theme.SubMenu.ItemsLook)
        For i, v In Pairs(Menu[i].Params.Look)
          If TB.Item.Exists(v, "font") Then v.Font.Size = HGui.Theme.SubMenu.Height + HGui.Theme.SubMenu.FontOffset
        Next
        Menu[i].Params.Window = MenuWindow
            
        If Menu[i].Type <> #HGUI_PREBUILT_GROUP
          Gadgets[i] = HGui.Gadget:New(Menu[i].Type, Menu[i].Params)
        Else
          Gadgets[i] = HGui.Menu_PrebuiltItem(Menu[i])
        EndIf
            
;            Gadgets[i] = HGui.Gadget:New(Menu[i].Type, Menu[i].Params)
        If TB.Item.Exists(Menu[i], "submenu")
          If ListItems(Menu[i].SubMenu) > 0 Then Gadgets[i]:Set({ Caption = Menu[i].Params.Caption ..  " ..." }, False)
        EndIf
        Gadgets[i].MenuDef = Menu[i]
        Gadgets[i].ParentWindow = Gadget.Window
        If TB.Item.IsNil(Menu[i].Params, "actions")
          Gadgets[i].Actions.OnPushed = HGui.Menu_Selected
        ElseIf TB.Item.IsNil(Menu[i].Params.Actions, "onpushed")
          Gadgets[i].Actions.OnPushed = HGui.Menu_Selected
        EndIf

      Next

      ; Creazione del layout
      MenuWindow.Root:Free()
      MenuWindow.root = HGui.Gadget:new(#HGUI_BOX_GADGET, { window = MenuWindow, name = HL.GetRndName(), look = { nskin = HGui.theme.SubMenu.RootSkin }, size = { w = MenuWindow.size.w - 1, h = MenuWindow.size.h - 1 }, usecache = MenuWindow.CacheRoot } )
      MenuWindow.root.private.IsRoot = True

      MenuWindow.Root:layoutSet({ gadgets = Gadgets,
                                  weights = Sizes,
                                  type =  #HGUI_VERTICAL_LAYOUT,
                                  gap = 0,;HGui.Theme.SubMenu.Gap,
                                  borders = { top = HGui.Theme.SubMenu.Borders.Top, bottom = HGui.Theme.SubMenu.Borders.Bottom, left = HGui.Theme.SubMenu.Borders.Left, right = HGui.Theme.SubMenu.Borders.Right } }, True )

      HGui.SetAutoRendering(True)
      MenuWindow:Render()

    EndIf
  EndIf

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.WChannel)
  
EndFunction

Function HGui.treeView_ElaborateList(itemsList, ident) ; *TriDoc*
/******************************************************************************
realItems = HGui.treeView_ElaborateList(itemsList, ident)

Process gadget's data to prepare the real items list of the visible items.
---------------------------------------------------------------------
INPUT
  itemsList : Table of the tree list items
  ident : Internal parameter used to keep track of the identation

OUTPUT
  realItems : Table of the processed, visible items
******************************************************************************/
  If HL.IsNil(ident) Then ident = 0

  Local realItems = {}
  Local count = ListItems(itemsList)

  For Local i = 0 To count-1
    Local item = itemsList[i]
    If TB.Item.IsNil(item, "._ident") Then Item._Ident = ident
    InsertItem(realItems, item)
    If TB.Item.IsNil(item, "_selected") Then item._Selected = False
    If TB.Item.IsNil(item, "_opened") Then item._Opened = False
    If item._opened = True And TB.Item.Exists(item, "childs")
      subItems = HGui.treeView_ElaborateList(item.Childs, Ident+1)
      Local scount = ListItems(subItems)
      item._childCount = scount
      For Local k = 0 To scount-1 Do InsertItem(realItems, subItems[k])
    Else
      item._childCount = 0
    EndIf

  Next

  Return(realItems)

EndFunction

Function HGui.DropDown_Selected(father, items, selected, lastitem) ; *TriDoc*
/*-------------------------------------------------------------------
HGui.DropDown_Selected(father, items, selected, lastitem)

This INTERNAL function is called when an item of an opened DropDown menu has been selected by the user.
It calls the Father.Father.OnSelect action passing a table with the following informations:
  DropDown : Father.Father item
  ListView : Father item
  Items : The list of Items
  selectedId : The selected item index
  selectedItem : The selected item value
---------------------------------------------------------------------
INPUT
  father    : Father object (the holder of the DropDown menu)
  items     : All items listed in the DropDown menu
  selected  : The selected item list
  lastitems : The selected item
-------------------------------------------------------------------*/

   HGui.DropDown.Window:free()
   Local ass_col = Father.Father.Column

   Father.Father.Value = LastItem
   Father.Father.Private.Value = LastItem
   Father.Father.ComboButton:set({ status = #HGUI_NORMAL_STATE, caption = Items[LastItem][ass_col] }, True)
   Father.Father.Data.Selected[LastItem] = False

   If TB.Item.Exists(Father.Father.Actions, "onselect")
      Father.Father.Actions.OnSelect({ DropDown = Father.Father, ListView = Father, Items = Items, SelectedID = LastItem, SelectedItem = Items[LastItem] })
   EndIf

EndFunction

Function HGui.DropDown_Close() ; *TriDoc*
/*---------------------------------------------------------
HGui.DropDown_Close()

Close and release any opened drop-down window/menu.
---------------------------------------------------------*/
  HGui.DropDown.Window:free()

EndFunction

Function HGui.DropDown_Open(msg) ; *TriDoc*
/*---------------------------------------------------------
HGui.DropDown_Open(msg)

Open a new drop-down window/menu using the <msg> table to define its properties.
-----------------------------------------------------------
INPUT
  msg : The gadget object

NOTES
  Please note that this function is used INTERNALLY by HGui to handle DropDown menus but you still can use it for your own purposes.
  
ATTENTION
  Since each dropdown can have its very own theme the list should read the gadget's theme stored in:
    msg.Father.Theme
---------------------------------------------------------*/
  DBG.Console.Out(".DropDown_Open()", DBG.OpenFunc, HGui.DebugChannel)

  Local theme = msg.Father.Theme
   
  Local scrw, scrh = GFX.GetHostSize()
  Local VScrollerOFF = True
  Local borders = theme.WindowBorders

  ; Calculate window sizes
  ;Local fontDef = HGui.Theme.DropDown.LVFont ; <=== THEME ===
  ;SetFont(fontdef.name, fontdef.size, { Engine = #FONTENGINE_INBUILT, Cache = True })
  ;SetFontStyle(fontdef.style)
  ;Local fh = fontdef.size+theme.listExtra ; <=== THEME ===

  Local Father = msg.Father
  Local count = ListItems(Father.Data.Items)
  Local w, h = 0, count * ( theme.EntryHeight ) ; <=== THEME ===

  Local w = 0
  For Local k = 0 To ListItems(Father.Data.ColumnSizes)-1
    w = w + Father.Data.ColumnSizes[k]
  Next

  Local xpos, ypos = msg.Area.Position.x, msg.Area.Position.y
  xpos = xpos + msg.Window.Position.x + GetAttribute(#DISPLAY, Father.Window.Private.HWId, #ATTRBORDERLEFT)
  ypos = ypos + msg.Window.Position.y + GetAttribute(#DISPLAY, Father.Window.Private.HWId, #ATTRBORDERTOP) + msg.Area.Size.h

  ; Verifica che la posizione non superi i 3/4 dello schermo
  If ypos > scrh/3*2
    ; Lo supera, quindi oriento la lista verso l'alto
    ypos = ypos - h - msg.Area.Size.h

    ; Controlla che non abbiamo superato il margine alto
    If ypos < 0
      ; Superato: rettifico la dimensione
      Local delta = Abs(ypos)
      ypos = 0
      h = h-delta
      VScrollerOFF = False
    Else
         ; Va bene cos√¨
  
    EndIf

  Else
    ; Va bene l'orientamento verso il basso
    ; Verifica se il limite inferiore viene superato
    If ypos+h > scrh
      ; Lo supera, rettifico la dimensione
      Local delta = (ypos+h) - scrh
      Local h = h-delta
      VScrollerOFF = False
    Else
      ; Va bene cos√¨
 
    EndIf
  
  EndIf

  ; Create the DropDown window
  HGui.DropDown.Window = HGui.Window:new(
    { bgcolor = theme.WindowBGColor,
      events = { OnDeactivate = HGui.DropDown_Close },
      flags = { borderless = True, moveable = False },
      position = { x = xpos, y = ypos },
      size = { w = w + 4, h = h + 4 } })

  ; Create Listview gadget to contain the items
  If TB.Item.IsNil(msg.Father.Data, "selected")
    msg.Father.Data.Selected = {}
  
  EndIf
  
  For Local i = 0 To ListItems(msg.Father.Data.Items)-1 Do msg.Father.Data.Selected[i] = False
  
  HGui.SetAutoRendering(False)
  HGui.DropDown.Gadget = HGui.Gadget:new(#HGUI_LISTVIEW_GADGET,
    { name           = "*OPENED_DROPDOWN*",
      window         = HGui.DropDown.Window,
      headersOFF     = True,
      HScrollerOFF   = True,
      VScrollerOFF   = VScrollerOFF,
      EntryHeight    = fh,
      OnChange       = HGui.DropDown_Selected,
      data           = msg.Father.Data,
      EntryHeight    = theme.EntryHeight,
      AlternateLines = theme.AlternateLines,
      FontName       = theme.LVFont.Name,
      FontSizeOffset = theme.LVFont.SizeOffset,
      FontStyle      = theme.LVFont.Style,
      FontColor      = theme.LVFont.Color,
      BGColor1       = theme.LVBGColors.odd,
      BGColor2       = theme.LVBGColors.even } )

  HGui.DropDown.Gadget.Father = Father

  HGui.DropDown.Window.Root:layoutSet(
    { gadgets = { HGui.DropDown.Gadget },
      weights = { 1 },
      gap = 0,
      borders = { top = borders, bottom = borders, left = borders, right = borders } }, True )

  HGui.SetAutoRendering(True)
  HGui.DropDown.Window:render()

  HGui.DropDown.IsOpen = True

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)

  Return(True)

EndFunction

Function HGui.gadgetEvent_DragScrollbarCursor(msg) ; *TriDoc*
/*---------------------------------------------------------
HGui.gadgetEvent_DragScrollbarCursor(msg)

Internal function used to handle the scrollbar's cursor dragging operation, this function is invoked by the OnMouseMove event.
---------------------------------------------------------*/
  ; THIS IS A TEMPORARY FIX BECASUE SOMETIMES SEEMS THAT THIS
  ; FUNC IS STILL CALLED EVEN IF THE HANDLER HAS BEEN REMOVED
  If Not(HGui.ScrollBarDragging)
    Return()
    
  EndIf
    
  Local Cursor   = msg.userdata
  Local Father, OuterBox, Spacer, WorkArea
  If TB.Item.Exists(Cursor.private, "father") ; --> SLIDER o SCROLLER
    Father   = Cursor.Private.Father
    OuterBox = Father.Childs.Gadgets[0]
    Spacer   = Father.Childs.Gadgets[0].Childs.Gadgets[0]
    WorkArea = { xstart = OuterBox.Area.Position.x, ystart = OuterBox.Area.Position.y }
    WorkArea.xend = WorkArea.xstart + OuterBox.Area.Size.w
    WorkArea.yend = WorkArea.ystart + OuterBox.Area.Size.h
  Else                                        ; --> KNOB
    Father = Cursor
  EndIf

  Local Value
  Local xMouse = msg.x
  Local yMouse = msg.y

  Local steps
  If TB.Item.Exists(Cursor, "type")
    If Cursor.Type = #HGUI_KNOB_GADGET
      steps = Cursor.Range[1] - Cursor.Range[0] + 1
    EndIf
  EndIf

  If TB.Item.Exists(Father, "type")
    If Father.Type = #HGUI_SCROLLBAR_GADGET
      steps = Father.Range[1] - Father.Range[0]; + 1
    ElseIf Father.Type = #HGUI_SLIDER_GADGET
      steps = Father.Range[1] - Father.Range[0] + 1
    EndIf

  EndIf

  Local pixelSize, newValue
  Local multiplier = 1
  If Father.Type = #HGUI_SLIDER_GADGET
    multiplier = 1 - Father.cursorWeight
  EndIf

  If steps = 0
    Return()
  EndIf

  If Father.Type = #HGUI_KNOB_GADGET
    pixelSize = steps / Father.Area.Size.w / multiplier
    unitSize  = Father.Area.Size.w / steps
    newValue = (xMouse - 0 - father.area.position.x)*pixelsize + Father.Range[0]
  Else
    If Father.Orientation = #HGUI_HORIZONTAL_LAYOUT
       pixelSize = steps / OuterBox.Area.Size.w / multiplier
       unitSize  = OuterBox.Area.Size.w / steps
       newValue = (xMouse - father.cursoroffset - father.area.position.x)*pixelsize + Father.Range[0]
    ElseIf Father.Orientation = #HGUI_VERTICAL_LAYOUT
       pixelSize = steps / OuterBox.Area.Size.h / multiplier
       unitSize  = OuterBox.Area.Size.h / steps
       newValue = (yMouse - father.cursoroffset - father.area.position.y)*pixelsize + Father.Range[0]
      EndIf
   EndIf

  Local previousValue = Father.private.Value

  If Father.Type = #HGUI_SCROLLBAR_GADGET
    Father:set({ value = newValue, caption = IIf(Father.Caption <> "", Father.Caption, Nil) }, True)
  ElseIf Father.Type = #HGUI_SLIDER_GADGET
    Father:set({ value = newValue }, True)
  ElseIf Father.Type = #HGUI_KNOB_GADGET
    Father:set({ value = newValue }, True)
  EndIf
  
  If TB.Item.Exists(Father.Actions, "onchange")
    Father.Actions.OnChange(Father, Father.Private.Value, previousValue)
  EndIf

  ; Gestisce il mouse all'interno/esterno del cursore
  If xMouse <= Cursor.Area.Position.x + Cursor.Area.Size.w And
     xMouse >= Cursor.Area.Position.x And
     yMouse <= Cursor.Area.Position.y + Cursor.Area.Size.h And
     yMouse >= Cursor.Area.Position.y

    HGui.MouseInsideCursor = True
  Else
    HGui.MouseInsideCursor = False
  EndIf
   
  
EndFunction

/* ****************************************************************************
   END CLASS
   ****************************************************************************/

Function HGui.Gadget:RestoreBG() ; SDOC, NOT YET AVAILABLE
/*-------------------------------------------------------------------
SKIP DOCS
HGui.Gadget:RestoreBG()

Restores the custom gadget's background
---------------------------------------------------------------------
NOTES
  *** NOT AVAILABLE IN THIS VERSION ***
-------------------------------------------------------------------*/
  DBG.Console.Out("[HGui.Gadget:restorebg]: restoring the gadget <" .. self.name .. "> background...")

  If TB.Item.IsNil(self, "background")
    DBG.Console.Out("   [-WARN-] No background defined for this object.")
    Return(False)
  EndIf
  If TB.Item.Exists(self.background.bgstruct, "brush")
    DisplayBrush(self.background.bgstruct.brush, self.area.position.x, self.area.position.y)
  EndIf

  Return(True)
  
EndFunction





/* ****************************************************************************
   CLASS HGui.CText
   ****************************************************************************/
;    Stringhe di formattazione speciali supportate da CText
;    Alignment : Begin of line -> {:align-l:}, {:align-r:}, {:align-c:}
;    FontSize  : Begin of line -> {:font++:}, {:font--:}, {:font=xxx:}
;    BGColor   : {:bgcolor=aarrggbbz:} Full Line bg, z = round level
;    BBColor   : {:bbcolor=aarrggbbz:} Only text bg, z = round level

HGui.CText = {}
HGui.CText.Name = Nil               ; Object Name
HGui.CText.First_Line = 1           ; First line to display
HGui.CText.Caption = {}             ; Object's text contents
HGui.CText.Wordwrap = False         ; Text wordwrap
HGui.CText.Window = Nil             ; Attached window
HGui.CText.Interline = 0            ; Additional interline in pixels
HGui.CText.Angle = 0                ; Text angle
HGui.CText.Encoding = HGui.TextEncoding ; #ENCODING_ISO8859_1 ; Text Encoding
HGui.CText.Vert_Adjust = 0          ; Vertical adjustment in pixels
HGui.CText.Font = {}                ; Font definition
HGui.CText.Font.Name = #SANS          ; Font Name
HGui.CText.Font.Size = 16             ; Font Size
HGui.CText.Font.Style = #ANTIALIAS    ; Font Style
HGui.CText.Font.Color = $000000       ; Font Color
HGui.CText.Font.Align = #HGUI_ALIGN_CENTER ; Font Alignment
HGui.CText.Effects = {}             ; Font effects
HGui.CText.Effects.Edge = {}          ; Edge effect definition
HGui.CText.Effects.Edge.Type = #NONE    ; Effect type
HGui.CText.Effects.Edge.Size = 1        ; Edge height
HGui.CText.Effects.Edge.Color1 = $44444444 ; Color 1
HGui.CText.Effects.Edge.Color2 = $44ffffff ; Color 2
HGui.CText.Effects.Shadow = {}        ; Shadow effect definition
HGui.CText.Effects.Shadow.Type = #NONE  ; Effect type
HGui.CText.Effects.Shadow.Distance = 2  ; Shadow distance
HGui.CText.Effects.Shadow.Color = $55000000 ; Shadow color
HGui.CText.Margins = {}             ; Text margins
HGui.CText.Margins.Top = 0            ; Top margin
HGui.CText.Margins.Bottom = 0         ; Bottom margin
HGui.CText.Margins.Left = 0           ; Left margin
HGui.CText.Margins.Right = 0          ; Right margin
HGui.CText.Area = Nil               ; Associated Area Object

/*
HGui.CText =
   { name        = Nil,                            ;| Object name              |
     first_line  = 1,                              ;| First visible line       |
     caption     = {},                             ;| Text Caption             |
     wordwrap    = False,                          ;| Wordwrap                 |
     window      = Nil,                            ;| Linked window            |
     interline   = 0,                              ;| Interline height         |
     angle       = 0,                              ;| Rotation angle           |
     encoding    = #ENCODING_ISO8859_1,            ;| Text encoding            |
     vert_adjust = 0,                              ;| Vertical adjustmemt      |
     font        =                                 ;| Font Definition          |
        { name  = #SANS,                           ;| Font name                |
          size  = 16,                              ;| Font size                |
          style = #ANTIALIAS,                      ;| Font style               |
          color = $000000,                         ;| Foreground color         |
          align = #HGUI_ALIGN_CENTER },            ;| Alignment                |
     effects     =                                 ;| Special effects          |
        { edge =                                   ;| Edge effect definition   |
           { type   = #NONE,                       ;| Effect type              |
             size   = 1,                           ;| Effect size              |
             color1 = $44444444,                   ;| Color 1                  |
             color2 = $44FFFFFF },                 ;| Color 2                  |
          shadow =                                 ;| Shadow effect            |
             { type     = #NONE,                   ;| Shadow type              |
               distance = 2,                       ;| Distance                 |
               color    = $55000000 } },           ;| Shadow color             |
     margins     =                                 ;| Text margins             |
        { top    = 0,                              ;| Top margin               |
          bottom = 0,                              ;| Bottom margin            |
          left   = 0,                              ;| Left margin              |
          right  = 0 },                            ;| Right margin             |
     area        = Nil                             ;| Linked area              |
     }
*/


Function HGui.CText:new(options) ; *TriDoc* *
/*-------------------------------------
CTextObj = HGui.CText:new(options)

Create a new CText object shaped by the table <options>

INPUT
 options : A table with the the required options, basically it follow the structure of the area object and you can selectively specify which item/value you want to ovveride.
   name : Object name, must be unique or Nil to let the system assign one for you.
   caption : The text to display, can be a string or a table of strings (one entry is one line)
   first_line : First line to display
   interline : Additional interline value, can be negative too, expressed in pixels.
   vert_adjust : Vertical adjustment for the rendering
   wordwrap : Wordwrap switch, TRUE to enable word wrapping.
   angle : Text rotation angle in degrees.
   font : Font description table
     name : Font name, it can be also a font constant
     size : Font size in pixels
     style : Font style (Hollywood style constants)
     color : Text color
     align : Text alignment, can beone or a combination of the following constants: #HGUI_ALIGN_LEFT, #HGUI_ALIGN_RIGHT, #HGUI_ALIGN_TOP, #HGUI_ALIGN_BOTTOM, #HGUI_ALIGN_HCENTER, #HGUI_ALIGN_VCENTER, #HGUI_ALIGN_CENTER
   effects : Text effects definition
     edge : Edge effect
       type : Effect type, can be one of the following constants: #NONE (Switch off the effect), #HGUI_TEXTEDGE_FLAT (Flat edge around the text), #HGUI_TEXTEDGE_RAISED (Raised effect), #HGUI_TEXTEDGE_RECESSED (Recessed effect)
       size : Border's size in pixels
       color1 : Color1 is used for: Border color of the FLAT fx, Light edges for the RAISED fx, Dark edges for the RECESSED fx
       color2 : Color2 is used for: Dark edges for the RAISED fx, Light edges for the RECESSED fx
     shadow : Text shadow effect
       type : Shadow type/direction, can be one of the following constants: #NONE (Switch off the effect), #SHDWNORTH, #SHDWNORTHEAST, #SHDWEAST, #SHDWSOUTHEAST, #SHDWSOUTH, #SHDWSOUTHWEST, #SHDWWEST, #SHDWNORTHWEST
       distance : Shadow distance in pixels
       color : Shadow color
   margins : Text margins table
     top : Top margin in pixels
     bottom : Bottom margin in pixels
     left : Left margin in pixels
     right : Right margin in pixels
   window : The window this CText belongs to, can be the window's name or a window object, if not specified the area will be linked to the currently active window.
   area : An HGui.Area object where the CText will be rendered. You can specify an existing Area object or a new one will be built for you. You have to specify in the options the <position> table nad the <size> table to allow the system to build the HGui.Area for you. <position> must have the <x> and <y> fields, and <size> must have the <w> and <h> fields.

OUTPUT
  CTextObject : The created object
---------------------------------------*/
  DBG.Console.Out(".CText:new()", DBG.OpenFunc, HGui.CTextChannel)

  Local NewCT = CopyTable(self)
  ; [NOTE] : Ma qua sotto in TB.Set() nooooo??

  ;::: NAME
  If TB.Item.Exists(options, "name")
    Local gad = HGui.cTextFindByName(options.name)
    If GetType(gad) = #TABLE
      DBG.Console.Out("Already assigned name '" .. options.name .. "'.", DBG.Error, HGui.CTextChannel)
      DBG.Console.Out(Nil, DBG.CloseFunc, HGui.CTextChannel)
      Return(False)
      
    Else
      NewCT.name = options.name
      
    EndIf
    
  Else
    NewCT.name = HL.GetRndName()
    DBG.Console.Out("Automatic assigned name: " .. NewCT.name, Nil, HGui.CTextChannel)
    
  EndIf

  ;::: CAPTION
  If TB.Item.Exists(options, "caption")
    If GetType(options.caption) = #STRING
      NewCT.caption = { options.caption }
      
    Else
      NewCT.caption = options.caption
      
    EndIf

  EndIf

  ;::: FIRST_LINE
  If TB.Item.Exists(options, "first_line")
    Local lines = TB.Count(NewCT.caption)
    If options.first_line > lines
      NewCT.first_line = lines
      
    Else
      NewCT.fisrt_line = options.first_line
      
    EndIf
    
  EndIf

  ;::: INTERLINE
  If TB.Item.Exists(options, "interline"  ) Then NewCT.interline   = options.interline

  ;::: VERT_ADJUST
  If TB.Item.Exists(options, "vert_adjust") Then NewCT.vert_adjust = options.vert_adjust

  ;::: WORDWRAP
  If TB.Item.Exists(options, "wordwrap"   ) Then NewCT.wordwrap    = options.wordwrap

  ;::: ANGLE
  If TB.Item.Exists(options, "angle"      ) Then NewCT.angle       = options.angle

  ;::: FONT
  If TB.Item.Exists(options, "font")
    If TB.Item.Exists(options.font, "name" ) Then NewCT.font.name  = options.font.name
    If TB.Item.Exists(options.font, "size" ) Then NewCT.font.size  = options.font.size
    If TB.Item.Exists(options.font, "style") Then NewCT.font.style = options.font.style
    If TB.Item.Exists(options.font, "color") Then NewCT.font.color = options.font.color
    If TB.Item.Exists(options.font, "align") Then NewCT.font.align = options.font.align
  EndIf

  ;::: EFFECTS
  If TB.Item.Exists(options, "effects")
    If TB.Item.Exists(options.effects, "edge")
      If TB.Item.Exists(options.effects.edge, "type" ) Then NewCT.effects.edge.type  = options.effects.edge.type
      If TB.Item.Exists(options.effects.edge, "size" ) Then NewCT.effects.edge.size  = options.effects.edge.size
      If TB.Item.Exists(options.effects.edge, "color1") Then NewCT.effects.edge.color1 = options.effects.edge.color1
      If TB.Item.Exists(options.effects.edge, "color2") Then NewCT.effects.edge.color2 = options.effects.edge.color2
    EndIf
    
    If TB.Item.Exists(options.effects, "shadow")
      If TB.Item.Exists(options.effects.shadow, "type"    ) Then NewCT.effects.shadow.type     = options.effects.shadow.type
      If TB.Item.Exists(options.effects.shadow, "distance") Then NewCT.effects.shadow.distance = options.effects.shadow.distance
      If TB.Item.Exists(options.effects.shadow, "color"   ) Then NewCT.effects.shadow.color    = options.effects.shadow.color
    EndIf
    
  EndIf

  ;::: MARGINS
  If TB.Item.Exists(options, "margins")
    If TB.Item.Exists(options.margins, "top"   ) Then NewCT.margins.top    = options.margins.top
    If TB.Item.Exists(options.margins, "bottom") Then NewCT.margins.bottom = options.margins.bottom
    If TB.Item.Exists(options.margins, "left"  ) Then NewCT.margins.left   = options.margins.left
    If TB.Item.Exists(options.margins, "right" ) Then NewCT.margins.right  = options.margins.right
  EndIf

  ;::: WINDOW
  If TB.Item.Exists(options, "window")
    Switch GetType(options.window)
      Case #STRING
        Local win = HGui.windowFindByName(options.window)
        If GetType(win) = #TABLE
          SelectDisplay(win.private.HWId, True)
          NewCT.window = win
          
        Else
          DBG.Console.Out("The window <" .. options.window .. "> does not exists.", DBG.Error, HGui.CTextChannel)
          DBG.Console.Out(Nil, DBG.CloseFunc, HGui.CTextChannel)
          Return(False)
          
        EndIf

      Case #TABLE
        SelectDisplay(options.window.private.HWId, True)
        NewCT.window = options.window

      Default
        DBG.Console.Out("Specified <window> is not recognized.", DBG.Error, HGui.CTextChannel)
        DBG.Console.Out(Nil, DBG.CloseFunc, HGui.CTextChannel)
        Return(False)

    EndSwitch

  Else
    NewCT.window = HGui.ActiveWindow
    SelectDisplay(NewCT.window.private.HWId)

  EndIf

  ;::: GRAPHIC AREA
  If TB.Item.Exists(options, "area")
    NewCT.area = options.area
    
  Else
    Local position = { x = 0, y = 0 }
    Local size     = { w = 120, h = 120 }
    If TB.Item.Exists(options, "position")
      If TB.Item.Exists(options.position, "x") Then position.x = options.position.x
      If TB.Item.Exists(options.position, "y") Then position.y = options.position.y
    EndIf
    
    If TB.Item.Exists(options, "size")
      If TB.Item.Exists(options.size, "w") Then size.w = options.size.w
      If TB.Item.Exists(options.size, "h") Then size.h = options.size.h
    EndIf
    
    NewCT.area = HGui.area:new({ position = position, size = size, active = False, window = NewCT.window })
  EndIf

  HGui.CTexts[NewCT] = NewCT

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.CTextChannel)
  Return(NewCT)

EndFunction

Function HGui.CText:set(options, ignoreCaption) ; *TriDoc* *
/*-------------------------------------
HGui.CText:set(options, ignoreCaption)

Set the object properties using the given <options> table.

INPUT
  options : Options table to change (refers to the HGui.CText:new() method for
  the available arguments).
---------------------------------------*/
  Local Rebuild = False
  Local ChangeArea = False

  If TB.Item.Exists(options, "ntext")  Then options = options.ntext
  If TB.Item.Exists(options, "htext")  Then options = options.htext
  If TB.Item.Exists(options, "ptext")  Then options = options.ptext
  If TB.Item.Exists(options, "dtext")  Then options = options.dtext
  If TB.Item.Exists(options, "nptext") Then options = options.nptext
  If TB.Item.Exists(options, "hptext") Then options = options.hptext
   
  If IsNil(ignoreCaption) Then ignoreCaption = False
   
  ;::: CAPTION ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "caption") And Not(ignoreCaption)
    If GetType(options.caption) = #STRING
      self.caption = { options.caption }

    Else
      self.caption = options.caption

    EndIf

    Rebuild = True

  EndIf

  ;::: FIRST_LINE :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "first_line")
    Local lines = ListItems(self.caption)
    If options.first_line > lines
       self.first_line = lines

    ElseIf options.first_line < 1
      self.first_line = 1
    
    Else
      self.first_line = options.first_line
    
    EndIf
    
    Rebuild = True

  EndIf

  ;::: INTERLINE ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "interline") And Not(ignoreCaption)
    self.interline = options.interline
    Rebuild = True

  EndIf

  ;::: VERT_ADJUST ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "vert_adjust") And Not(ignoreCaption)
    self.vert_adjust = options.vert_adjust
    Rebuild = True

  EndIf

  ;::: WORDWRAP :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "wordwrap") And Not(ignoreCaption)
    self.wordwrap = options.wordwrap
    Rebuild = True

  EndIf

  ;::: ANGLE ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "angle") And Not(ignoreCaption)
    self.angle = options.angle
    Rebuild = True

  EndIf

  ;::: FONT :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "font")
    If TB.Item.Exists(options.font, "name" ) Then self.font.name  = options.font.name
    If TB.Item.Exists(options.font, "size" ) Then self.font.size  = options.font.size
    If TB.Item.Exists(options.font, "style") Then self.font.style = options.font.style
    If TB.Item.Exists(options.font, "color") Then self.font.color = options.font.color
    If TB.Item.Exists(options.font, "align") Then self.font.align = options.font.align
    Rebuild = True

  EndIf

  ;::: EFFECTS ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "effects")
    If TB.Item.Exists(options.effects, "edge")
      If TB.Item.Exists(options.effects.edge, "type"  ) Then self.effects.edge.type  = options.effects.edge.type
      If TB.Item.Exists(options.effects.edge, "size"  ) Then self.effects.edge.size  = options.effects.edge.size
      If TB.Item.Exists(options.effects.edge, "color1") Then self.effects.edge.color1 = options.effects.edge.color1
      If TB.Item.Exists(options.effects.edge, "color2") Then self.effects.edge.color2 = options.effects.edge.color2
    
    EndIf

    If TB.Item.Exists(options.effects, "shadow")
      If TB.Item.Exists(options.effects.shadow, "type"    ) Then self.effects.shadow.type     = options.effects.shadow.type
      If TB.Item.Exists(options.effects.shadow, "distance") Then self.effects.shadow.distance = options.effects.shadow.distance
      If TB.Item.Exists(options.effects.shadow, "color"   ) Then self.effects.shadow.color    = options.effects.shadow.color
    
    EndIf
    Rebuild = True

  EndIf

  ;::: MARGINS ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "margins")
    If TB.Item.Exists(options.margins, "top"   ) Then self.margins.top    = options.margins.top
    If TB.Item.Exists(options.margins, "bottom") Then self.margins.bottom = options.margins.bottom
    If TB.Item.Exists(options.margins, "left"  ) Then self.margins.left   = options.margins.left
    If TB.Item.Exists(options.margins, "right" ) Then self.margins.right  = options.margins.right
    Rebuild = True
  
  EndIf

  SelectDisplay(self.window.private.HWId, True)

  ;::: AREA :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  If TB.Item.Exists(options, "area")
    self.area = options.area
  
  Else
    ;??? Questo blocco qua sotto serve veramente??????????????????????????????
    Local position = { x = self.area.position.x, y = self.area.position.y }
    Local size     = { w = self.area.size.w, h = self.area.size.h }
    If TB.Item.Exists(options, "position")
      If TB.Item.Exists(options.position, "x") Then position.x = options.position.x
      If TB.Item.Exists(options.position, "y") Then position.y = options.position.y
  
    EndIf
    
    If TB.Item.Exists(options, "size")
      If TB.Item.Exists(options.size, "w") Then size.w = options.size.w
      If TB.Item.Exists(options.size, "h") Then size.h = options.size.h
    
    EndIf
    self.area:set({ position = position, size = size })
    ;?????????????????????????????????????????????????????????????????????????
    
  EndIf
   
  Return(True)

EndFunction


Function HGui.CText:render(area, cliparea) ; *TriDoc* *
/*-------------------------------------
HGui.CText:render(area, cliparea)

Renders the CText object in the linked window and using the linked area.
You can override the area using a custom <area>, furthermore you can apply a
clip area to delimit the rendering area.

INPUT
  area : A table with the following fields:
    position : Area position table
      x : Horizontal coordinate
      y : Vertical coordinate
    size : Area size table
      w : Width
      h : Height
  cliparea : Table with the following fields:
    x : Horizontal coordinate
    y : Vertical coordinate
    w : Width
    h : Height

NOTES (TODO)
  This function needs improvements to render only the visible lines,
  actually it renders all the text lines from the first to the last.
---------------------------------------*/
  If GetType(self.caption) <> #TABLE Then self.caption = { self.caption }
  Local TextLines = ListItems(self.caption)

  ; Setup the font
  SetFont(self.font.name, self.font.size, { Engine = #FONTENGINE_INBUILT, Cache = True })
  SetFontStyle(#NORMAL)
  SetFontStyle(self.font.style)
  SetFontColor(self.font.color)

  Local area_backup = {}
  If Not(IsNil(area))
    area_backup        = { x = self.area.position.x, y = self.area.position.y, w = self.area.size.w, h = self.area.size.h }
    self.area.position = { x = area.position.x, y = area.position.y }
    self.area.size     = { w = area.size.w, h = area.size.h }
  EndIf

  ; Calculate the region coordinates
  xs = self.area.position.x + self.margins.left
  ys = self.area.position.y + self.margins.top
  xe = self.area.size.w - self.margins.left - self.margins.right
  ye = self.area.size.h - self.margins.top - self.margins.bottom

  If Not(IsNil(cliparea))
    xs = cliparea.x + self.margins.left
    ys = cliparea.y + self.margins.top
    xe = cliparea.w - self.margins.left - self.margins.right
    ye = cliparea.h - self.margins.top - self.margins.bottom
  EndIf

  Local clipid = GFX.SafeClipRegion(Nil, #BOX, xs, ys, xe, ye)

  Local tdata = {}
  If self.angle = 0
    GFX.OutputDevice.Select(#DISPLAY, self.window.private.HWId, True)
    SetClipRegion(clipid)
    
  Else
    Local m = Max(self.area.size.w, self.area.size.h)
    tdata.tbid = CreateBrush(Nil, m, m, #WHITE, { AlphaChannel = True, Clear = True })
    tdata.x = self.area.position.x
    tdata.y = self.area.position.y
    tdata.w = self.area.size.w
    tdata.h = self.area.size.h
    self.area.position.x = 0
    self.area.position.y = 0
    self.area.size.w = m
    self.area.size.h = m
    GFX.OutputDevice.Select(#BRUSH, tdata.tbid, #SELMODE_COMBO, 2)
  EndIf

  ; Calcolo posizione verticale
  ; NEW: tengo conto della prima linea di rendering   
  Local YPosition   = 0
  Local Line_Height = TextHeight("|") + self.interline
  Local Text_Height = Line_Height * (TextLines-self.First_Line+1)
  self.VisibleRows  = Int((ye - ys)/Line_Height)-1      ; <-- Fixed 15/01/2022
  If self.VisibleRows <= 0 Then self.VisibleRows = 1    ; <-- Fixed 15/01/2022
  
  If (self.font.align & #HGUI_ALIGN_VCENTER) = #HGUI_ALIGN_VCENTER
    YPosition = self.area.position.y + self.margins.top + ((self.area.size.h - Text_Height)/2) - (self.margins.top + self.margins.bottom)/2

  ElseIf (self.font.align & #HGUI_ALIGN_TOP) = #HGUI_ALIGN_TOP
    YPosition = self.area.position.y + self.margins.top

  ElseIf (self.font.align & #HGUI_ALIGN_BOTTOM) = #HGUI_ALIGN_BOTTOM
    YPosition = self.area.position.y - Text_Height + self.area.size.h - self.margins.bottom

  Else
    YPosition = self.area.position.y + self.margins.top + ((self.area.size.h - Text_Height)/2) - (self.margins.top + self.margins.bottom)/2

  EndIf

  ; NEW: Calcolo posizione vertical di stop rendering
  YEndPos   = self.area.position.y + self.area.size.h - self.margins.bottom
   
  ; FASE 1 : determino le tag e ripulisco le righe memorizzando i comandi a parte
  Local tags, rows = {}, {}

  For Local cline = self.First_Line-1 To TextLines - 1
    ; Se la riga inizia con {: probabilmente contienene una o pi√π tags, quindi
    ; verifico
    rows[cline] = HL.Convert.ForTextOut(self.caption[cline])
          
    tags[cline] =
      { biggerFont  = False,
        smallerFont = False,
        setFontSize = { False, 0 },
        alignLeft   = False,
        alignRight  = False,
        alignCenter = False,
        bgColor     = { False, 0, 0 },
        bbColor     = { False, 0, 0 }
        }

    ; Parse embedded commands
    While LeftStr(rows[cline], 2) = "{:"
      ; Identifica e memorizza la tag
      If LeftStr(rows[cline], 6) = "{:font"
        ; FONT COMMANDS
        If     LeftStr(rows[cline], 10) = "{:font++:}"
          ; Bigger Font
          tags[cline].biggerFont = True
          rows[cline] = UnrightStr(rows[cline], 10)

        ElseIf LeftStr(rows[cline], 10) = "{:font--:}"
          ; Smaller Font
          tags[cline].smallerFont = True
          rows[cline] = UnrightStr(rows[cline], 10)

        ElseIf LeftStr(rows[cline], 7) = "{:font="
          ; Set Font Size
          Local size = ToNumber(MidStr(rows[cline], 7, 3))
          tags[cline].setFontSize[0] = True
          tags[cline].setFontSize[1] = size
          rows[cline] = UnrightStr(rows[cline], 12)

        EndIf

      ElseIf LeftStr(rows[cline], 8) = "{:align-"
        ; ALIGNMENT COMMANDS
        If     LeftStr(rows[cline], 11) = "{:align-l:}"
          ; Align left
          tags[cline].alignLeft = True
          rows[cline] = UnrightStr(rows[cline], 11)

        ElseIf LeftStr(rows[cline], 11) = "{:align-r:}"
          ; Align Right
          tags[cline].alignRight = True
          rows[cline] = UnrightStr(rows[cline], 11)
        
        ElseIf LeftStr(rows[cline], 11) = "{:align-c:}"
          ; Align Center
          tags[cline].alignCenter = True
          rows[cline] = UnrightStr(rows[cline], 11)
        
        EndIf

      ElseIf LeftStr(rows[cline], 10) = "{:bgcolor="
        ; BG COLOR
        Local a = ToNumber("$" .. MidStr(rows[cline], 10, 2))
        Local r = ToNumber("$" .. MidStr(rows[cline], 12, 2))
        Local g = ToNumber("$" .. MidStr(rows[cline], 14, 2))
        Local b = ToNumber("$" .. MidStr(rows[cline], 16, 2))
        Local z = ToNumber(MidStr(rows[cline], 18, 1)) * 10
        tags[cline].bgColor[0] = True
        tags[cline].bgColor[1] = ARGB(a, RGB(r, g, b))
        tags[cline].bgColor[2] = z
        rows[cline] = UnrightStr(rows[cline], 21)

      ElseIf LeftStr(rows[cline], 10) = "{:bbcolor="
        ; BB COLOR
        Local a = ToNumber("$" .. MidStr(rows[cline], 10, 2))
        Local r = ToNumber("$" .. MidStr(rows[cline], 12, 2))
        Local g = ToNumber("$" .. MidStr(rows[cline], 14, 2))
        Local b = ToNumber("$" .. MidStr(rows[cline], 16, 2))
        Local z = ToNumber(MidStr(rows[cline], 18, 1)) * 10
        tags[cline].bbColor[0] = True
        tags[cline].bbColor[1] = ARGB(a, RGB(r, g, b))
        tags[cline].bbColor[2] = z
        rows[cline] = UnrightStr(rows[cline], 21)
        
      EndIf
      
    Wend
     
  Next
   
  Local visibleWidth = self.area.size.w - (self.margins.left+1) - (self.margins.right+1)
  For Local cline = self.First_Line-1 To TextLines - 1
    ;Local cline = self.First_Line-1
    ;Local loop = IIf(cline <= TextLines-1, True, False)
    ;While loop And clines < TextLines-1
    ;DebugPrint("SCANNING LINE " .. cline)
    ;DBG.DumpTable(self.caption)
    Local XPosition   = 0
    Local Line_Width  = GFX.Text.GetWidth(rows[cline]); GFX.Text.GetWidth(self.caption[cline])
    Local safeText    = rows[cline] ; HL.Convert.ForTextOut(self.caption[cline])
      
    ;*** NEW: When the text is over the vertical limit stop rendering   
    If YPosition > YEndPos
      Break()
      
    EndIf

    ; Apply parsed commands
    If tags[cline].biggerFont
      ; BIGGER FONT
      SetFont(self.font.name, self.font.size+4, { Engine = #FONTENGINE_INBUILT, Cache = True })
      SetFontStyle(self.font.style)
      Line_Width = GFX.Text.GetWidth(safeText)

    ElseIf tags[cline].smallerFont
      ; SMALLER FONT
      SetFont(self.font.name, self.font.size-4, { Engine = #FONTENGINE_INBUILT, Cache = True })
      SetFontStyle(self.font.style)
      Line_Width = GFX.Text.GetWidth(safeText)

    ElseIf tags[cline].setFontSize[0]
      ; SET FONT SIZE
      SetFont(self.font.name, tags[cline].setFontSize[1], { Engine = #FONTENGINE_INBUILT, Cache = True })
      SetFontStyle(self.font.style)
      Line_Width = GFX.Text.GetWidth(safeText)
    
    Else
      ; DEFAULT SIZE
      SetFont(self.font.name, self.font.size, { Engine = #FONTENGINE_INBUILT, Cache = True })
      SetFontStyle(self.font.style)
      Line_Width = GFX.Text.GetWidth(safeText)
    
    EndIf
    
    ;------------------------- NEW WORDWRAP
    Local multiLines, mHAligns, mLines = False, {}, {}
    If self.wordWrap
      ;DebugPrint("WordWrapping : " .. safeText)
      mLines = GFX.Text.WordWrap(safeText, VisibleWidth)
      multiLines = True
        
      If TextLines = 1
        ; Siamo in presenza di una sola riga, se il wordwrap fornisce righe
        ; multiple devo rettificare l'allineamento verticale
        l = ListItems(mLines)
        If l > 1
          YPosition = YPosition - (l-1)*Line_Height/2
          If YPosition < 0 Then YPosition = 0
        EndIf

      EndIf
    
    EndIf
    ;-------------------------
    Local mul = 1
    If multilines Then mul = ListItems(mLines)
    ;-------------------------
    If tags[cline].bgColor[0]
      ; BG COLOR (full line)
      Box(self.area.position.x, 
          YPosition, 
          self.area.size.w, 
          Line_Height*mul + self.Interline*(mul-1), 
          tags[cline].bgColor[1], 
          { RoundLevel = tags[cline].bgColor[2] })
    EndIf
    
    ; Apply parsed commands
    If Not(multilines)
    
      If tags[cline].alignLeft
        ; ALLINEA A SINISTRA
        XPosition = self.area.position.x + self.margins.left
      
      ElseIf tags[cline].alignRight
        ; ALLINEA A DESTRA
        XPosition = self.area.position.x - Line_Width + self.area.size.w - self.margins.right
      
      ElseIf tags[cline].alignCenter
        ; ALLINEA AL CENTRO
        XPosition = self.area.position.x + self.margins.left + (self.area.size.w - Line_Width - self.margins.right - self.margins.left)/2
      
      Else
        ;*** Allineamenti di default ***
        If (self.font.align & #HGUI_ALIGN_HCENTER) = #HGUI_ALIGN_HCENTER
           XPosition = self.area.position.x + self.margins.left + (self.area.size.w - Line_Width - self.margins.right - self.margins.left)/2

        ElseIf (self.font.align & #HGUI_ALIGN_LEFT) = #HGUI_ALIGN_LEFT
           XPosition = self.area.position.x + self.margins.left

        ElseIf (self.font.align & #HGUI_ALIGN_RIGHT) = #HGUI_ALIGN_RIGHT
           XPosition = self.area.position.x - Line_Width + self.area.size.w - self.margins.right

        Else
           XPosition = self.area.position.x + self.margins.left + ((self.area.size.w - Line_Width)/2) - (self.margins.left + self.margins.right)/2

        EndIf
      
      EndIf
      
      If tags[cline].bbColor[0]
        ; BG COLOR (Only text)
        Box(XPosition, 
            YPosition, 
            Line_Width, 
            Line_Height*mul + self.Interline*(mul-1), 
            tags[cline].bbColor[1], 
            { RoundLevel = tags[cline].bbColor[2] })
      EndIf
      
    Else

      For Local mi = 0 To ListItems(mLines)-1
        Local Line_Width  = GFX.Text.GetWidth(mLines[mi])
        If tags[cline].alignLeft
          ; ALLINEA A SINISTRA
          mHAligns[mi] = self.area.position.x + self.margins.left

        ElseIf tags[cline].alignRight
          ; ALLINEA A DESTRA
          mHAligns[mi] = self.area.position.x - Line_Width + self.area.size.w - self.margins.right

        ElseIf tags[cline].alignCenter
          ; ALLINEA AL CENTRO
          mHAligns[mi] = self.area.position.x + self.margins.left + (self.area.size.w - Line_Width - self.margins.right - self.margins.left)/2

        Else
          ;*** Allineamenti di default ***
          If (self.font.align & #HGUI_ALIGN_HCENTER) = #HGUI_ALIGN_HCENTER
            mHAligns[mi] = self.area.position.x + self.margins.left + (self.area.size.w - Line_Width - self.margins.right - self.margins.left)/2

        ElseIf (self.font.align & #HGUI_ALIGN_LEFT) = #HGUI_ALIGN_LEFT
           mHAligns[mi] = self.area.position.x + self.margins.left

        ElseIf (self.font.align & #HGUI_ALIGN_RIGHT) = #HGUI_ALIGN_RIGHT
           mHAligns[mi] = self.area.position.x - Line_Width + self.area.size.w - self.margins.right

        Else
           mHAligns[mi] = self.area.position.x + self.margins.left + ((self.area.size.w - Line_Width)/2) - (self.margins.left + self.margins.right)/2

        EndIf
        
      EndIf
      
    Next
    
    If Not(multilines)
      If tags[cline].bbColor[0]
        ; BG COLOR (Only text)
        Box(XPosition, 
            YPosition, 
            Line_Width, 
            Line_Height*mul + self.Interline*(mul-1), 
            tags[cline].bbColor[1], 
            { RoundLevel = tags[cline].bbColor[2] })
      EndIf

    Else
      If TB.Item.IsNil(mHAligns, 0) Then mHAligns[0] = 0
      Local x = mHAligns[0]
      Local mx = 0
      For Local i = 0 To ListItems(mLines)-1
        Local wx = GFX.Text.GetWidth(mLines[i])
        If wx > mx
          mx = wx
          x = mHAligns[i]
        EndIf
      Next
      
      If tags[cline].bbColor[0]
        ; BG COLOR (Only text)
        Box(x, 
            YPosition, 
            mx, 
            Line_Height*mul + self.Interline*(mul-1), 
            tags[cline].bbColor[1], 
            { RoundLevel = tags[cline].bbColor[2] })
      EndIf

    EndIf

  EndIf

  ; Processa effetto edge
  If self.effects.edge.Type <> #NONE
    If self.effects.edge.Type = #HGUI_TEXTEDGE_FLAT Then SetFontStyle(#EDGE, self.effects.edge.color1, self.effects.edge.size)
  EndIf

  ; Processa effetto shadow
  If self.effects.shadow.type <> #NONE
    SetFontStyle(#SHADOW, self.effects.shadow.color, self.effects.shadow.distance, self.effects.shadow.type)
  EndIf

  params = { Encoding = HGui.TextEncoding }   
   
  ; 3D effect
    If (self.effects.edge.type <> #NONE) And (self.effects.edge.type <> #HGUI_TEXTEDGE_FLAT)
      Local color1 = self.effects.edge.color1
      Local color2 = self.effects.edge.color2
      If self.effects.edge.type = #HGUI_TEXTEDGE_RECESSED Then color1, color2 = color2, color1

      If Not(multilines)
        For Local l = 1 To self.effects.edge.size
          SetFontColor(color2)
          TextOut(XPosition+l, YPosition-l + self.vert_adjust, safeText, params)

          SetFontColor(color1)
          TextOut(XPosition-l, YPosition + self.vert_adjust, safeText, params)
          TextOut(XPosition-l, YPosition-l + self.vert_adjust, safeText, params)
          TextOut(XPosition, YPosition-l + self.vert_adjust, safeText, params)
          TextOut(XPosition-l, YPosition+l + self.vert_adjust, safeText, params)

          SetFontColor(color2)
          TextOut(XPosition+l, YPosition + self.vert_adjust, safeText, params)
          TextOut(XPosition+l, YPosition+l + self.vert_adjust, safeText, params)
          TextOut(XPosition, YPosition+l + self.vert_adjust, safeText, params)
        Next
      
      Else
        Local yp = YPosition
        For Local ml = 0 To ListItems(mLines)-1
          Local s = mLines[ml]
          Local x = mHAligns[ml]
          For Local l = 1 To self.effects.edge.size
            SetFontColor(color2)
            TextOut(x+l, yp-l + self.vert_adjust, s, params)

            SetFontColor(color1)
            TextOut(x-l, yp + self.vert_adjust, s, params)
            TextOut(x-l, yp-l + self.vert_adjust, s, params)
            TextOut(x, yp-l + self.vert_adjust, s, params)
            TextOut(x-l, yp+l + self.vert_adjust, s, params)

            SetFontColor(color2)
            TextOut(x+l, yp + self.vert_adjust, s, params)
            TextOut(x+l, yp+l + self.vert_adjust, s, params)
            TextOut(x, yp+l + self.vert_adjust, s, params)

          Next
          
          yp = yp + Line_Height + self.interline
          
        Next
        
      EndIf
      
    EndIf

    SetFontColor(self.font.color)
      
    If Not(multilines)
      TextOut(XPosition, YPosition + self.vert_adjust, safeText, params)
      YPosition = YPosition + Line_Height + self.interline
    
    Else
      ;DebugPrompt("Rendering multiline...")
      For ml = 0 To ListItems(mLines)-1
        TextOut(mHAligns[ml], YPosition + self.vert_adjust, mLines[ml], params)
        YPosition = YPosition + Line_Height + self.interline
    
      Next
      
    EndIf

    ;cline = cline + 1
    ;Wend
  Next

  If self.angle = 0
    SetClipRegion(#NONE)
  
  Else
    GFX.OutputDevice.EndSelect()
    GFX.OutputDevice.Select(#DISPLAY, self.window.private.HWId)
    ;SelectDisplay(self.window.private.HWId, True)
    SetClipRegion(clipid)
    DisplayBrush(tdata.tbid, tdata.x + tdata.w/2, tdata.y + tdata.h/2, { AnchorX = 0.5, AnchorY = 0.5, Rotate = self.angle, SmoothScale = True })
    ;DisplayBrush(tdata.tbid, 100, 100)
    FreeBrush(tdata.tbid)
    self.area.position.x = tdata.x
    self.area.position.y = tdata.y
    self.area.size.w = tdata.w
    self.area.size.h = tdata.h
    SetClipRegion(#NONE)
    GFX.OutputDevice.EndSelect()
  
  EndIf

  GFX.OutputDevice.EndSelect()

  FreeClipRegion(clipid)

  If Not(IsNil(area))
    self.area.position = { x = area_backup.x, y = area_backup.y }
    self.area.size = { w = area_backup.w, h = area_backup.h}
  EndIf

  Return(True)

EndFunction

Function HGui.CText:free() ; *TriDoc* *
/*-------------------------------------
CTextObject:free()

Free a CText object.

OUTPUT
  result : TRUE if the objectwas released without errors.
---------------------------------------*/
  DBG.Console.Out(".CText:free()", DBG.OpenFunc, HGui.CTextChannel)

  self.Area:free()
  HGui.CTexts[self].Area = Nil

  HGui.CTexts[self] = Nil
  self = Nil

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.CTextChannel)
  Return(True)

EndFunction

Function HGui.cTextFindByName(name) ; *TriDoc*
/*---------------------------------------------------------
cText, index = HGui.cTextFindByName(name)

Search a cText object by its name.
-----------------------------------------------------------
INPUT
  name : Name of the cText object we are looking for

OUTPUT
  cText : cText object found or False
  index : cText object index in HGui.CTexts table.
---------------------------------------------------------*/
  Local i, v
  
  For i, v In Pairs(HGui.CTexts)
    If v.name = name
      Return(v, i)

    EndIf
  Next
  
  Return(False)

EndFunction



/* ****************************************************************************
   END CLASS
   ****************************************************************************/



;--- TIP -----------------------------------------------------------------------

Function HGui.Tip.Open(msg) ; *TriDoc*
/*-------------------------------------------------------------------
result = HGui.Tip.Open(msg)

Open a floating tip message.
---------------------------------------------------------------------
INPUT
  msg : Table used to describe the tips to show.
    userdata : Table with the tip description
    win      : Calling window
    tip      : A table of strings with the message to show
    position : A table with the tip's coordinates
      x : Horizontal position
      y : Vertical position

OUTPUT
  result : True if the tip was opened without errors, otherwise False.

NOTES
  This function is used internally to show floating tips.
------------------------------------------------------------------*/
   ; msg must have the format:
   ; msg = { userdata = { win = calling window, tip = { line1, line2, ... }, position = { x = ..., y = ... } }
  DBG.Console.Out("Tip.Open()", DBG.OpenFunc, HGui.DebugChannel)
  HGui.Tip.TimeoutID = Nil

  ; Convert the message string into a table if needed...
  If GetType(msg.userdata.tip) = #STRING
    msg.userdata.tip = { msg.userdata.tip }
  EndIf
   
  Local scrw, scrh = GFX.GetHostSize()
   
  ; Calculate window sizes
  Local fontdef = HGui.theme.tip.ntext.font
  SetFont(fontdef.name, fontdef.size, { Engine = #FONTENGINE_INBUILT, Cache = True })
  SetFontStyle(fontdef.style)
  Local fh = TextHeight("|")
  Local w, h = 0, TB.Count(msg.UserData.Tip) * ( fh + HGui.theme.tip.ntext.interline )

  For Local i = 0 To TB.Count(msg.UserData.Tip) - 1
    Local tw, rt = GFX.Text.GetWidth(msg.UserData.Tip[i])
    w = Max(w, tw)
  Next

  ; Activate callin window
  ExitOnError(False)
  SelectDisplay(msg.userdata.win.private.HWId, True)
  Local _error = GetLastError()
  ExitOnError(True)
  If _error <> 0
    DBG.Console.Out("ERROR SECTING DISPLAY : " .. GetErrorName(_error), DBG.Warning, HGui.DebugChannel)
    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
    Return(False)
  EndIf
   
  Local xpos, ypos = msg.userdata.position.x + MouseX() + 2, msg.userdata.position.y + MouseY() - h/2 - 2 

  ex = xpos + w
  If ex > scrw
    xpos = xpos - (ex - scrw) - 16
  EndIf

  If ypos < 0 Then ypos = 0

  ; Create the Tip window
  HGui.Tip.Window = HGui.Window:new({ bgcolor = HGui.Theme.Tip.BGColor,
                                      flags = { hidefromtaskbar = True, borderless = True, moveable = False },
                                      position = { x = xpos, y = ypos },
                                      size = { w = w + 8, h = h + 4 } })
  HGui.Tip.Window.IsTip = True
   
  ; Create Label gadget to contain the tip
  HGui.SetAutoRendering(False)
  HGui.theme.tip.ntext.name = "*TIP_LABEL*NCText*"
  Local TipLabel = HGui.Gadget:new(#HGUI_LABEL_GADGET, { caption = msg.UserData.Tip,
                                                         name = "*TIP_LABEL*",
                                                         look = { nskin = HGui.theme.tip.nskin,
                                                                  ntext = HGui.theme.tip.ntext },
                                                          window = HGui.Tip.Window })

  HGui.Tip.Window.RootGadget:layoutSet({ gadgets = { TipLabel },
                                         weights = { 1 },
                                         gap = 0,
                                         borders = { top = 1, bottom = 1, left = 1, right = 1 } }, True )

  HGui.SetAutoRendering(True)
  HGui.Tip.Window:render()

  InstallEventHandler({ OnMouseMove = HGui.Tip.Close })

  HGui.Tip.IsOpen = True
   
  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
   
  Return(True)

EndFunction

Function HGui.Tip.Close() ; *TriDoc*
/*-------------------------------------------------------------------
HGui.Tip.Close()

Function to close any opened floting tips.
---------------------------------------------------------------------
NOTES
  Used internally to close floating tips when the mouse is moved.
------------------------------------------------------------------*/

  DBG.Console.Out(".Tip.Close()", DBG.OpenFunc, HGui.DebugChannel)

  If TB.Item.Exists(HGui.Tip, "timeoutid")
    ClearTimeout(HGui.Tip.TimeoutID)
    HGui.Tip.TimeoutID = Nil
  EndIf

  If TB.Item.IsNil(HGui.Tip, "window")
    DBG.Console.Out("No tip to close.", DBG.Warning, HGui.DebugChannel)
    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
    Return(False)
  EndIf

  SelectDisplay(HGui.Tip.Window.private.HWId, True)
  InstallEventHandler({ OnMouseMove = 0 })

  If Not(TB.Item.IsNil(HGui.Tip, "isopen"))
    If HGui.Tip.IsOpen
      HGui.Tip.IsOpen = False
      HGui.Tip.Window:Free()
      HGui.Tip.Window = Nil
    EndIf
  EndIf

  DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
  Return(True)

EndFunction

;--- SWITCHES ------------------------------------------------------------------

Function HGui.SetAutoRendering(value) ; *TriDoc*
/*-------------------------------------------------------------------
result = HGui.SetAutoRendering(value)

This function is used to switch the automatic rendering on or off.
It's usefull especially during the interface creation, when you are creating each single gadgets and their hiearachy to avoid useless redrawing that can bring only flickering and slowdown effects.
---------------------------------------------------------------------
INPUT
  value : True to enable rendering, False to disable it.

OUTPUT
  result : True if the rendering mode has been changed.
------------------------------------------------------------------*/

  DBG.Console.Out(".SetAutoRendering() -> " .. value, DBG.OpenFunc, HGui.DebugChannel)
  If HGui.AutoRendering = value
    ;DBG.Console.Out("Already " .. IIF(value, "ON", "OFF"), DBG.Warning, HGui.DebugChannel)
    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
    Return(False)
  Else
    HGui.AutoRendering = Value
    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
    Return(True)
  EndIf
   
EndFunction

Function HGui.SetEventHandling(value) ; *TriDoc*
/*-------------------------------------------------------------------
result = HGui.SetEventHandling(value)

This function is used to switch the event handling routines on or off.
---------------------------------------------------------------------
INPUT
  value : True to enable event handling, False to disable it.

OUTPUT
  result : True if the event handling has been changed.
------------------------------------------------------------------*/

  DBG.Console.Out(".SetEventHandling() -> " .. value, DBG.OpenFunc, HGui.DebugChannel)

  If HGui.EventHandling = value
    ; DBG.Console.Out("Already " .. IIf(value, "ON", "OFF"), DBG.Warning, HGui.DebugChannel)
    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
    Return(False)
  Else
    HGui.EventHandling = Value
    DBG.Console.Out(Nil, DBG.CloseFunc, HGui.DebugChannel)
    Return(True)
  EndIf

EndFunction

Function HGui.validateGadgetStatus(status) ; *TriDoc*
/*-------------------------------------------------------------------
HGui.validateGadgetStatus(status)

Internal function used to check if a gadget status is valid
------------------------------------------------------------------*/
  ; Returns TRUE if status is valid otherwise returns FALSE
  
  If status = #HGUI_NORMAL_STATE Or
     status = #HGUI_HILIGHTED_STATE Or
     status = #HGUI_PUSHED_STATE Or
     status = #HGUI_DISABLED_STATE Or
     status = #HGUI_NPUSHED_STATE Or
     status = #HGUI_HPUSHED_STATE Or
     status = #HGUI_DPUSHED_STATE
    Return(True)
    
  Else
    Return(False)
    
  EndIf
  
EndFunction




/* 
==================================================================
                           SPLASH SCREEN
==================================================================
*/

Function HGui.ShowSplashScreen(imageFile, size, setDisplaySize) ; *TriDoc*
/*-------------------------------------------------------------
HGui.ShowSplashScreen(imageFile, size, setDisplaySize)

Open a window on display 1, to show the loading progress of the application.
You have to use it before any new HGui window.
-------------------------------------------------
INPUT
  imageFile      : Image file to show in the splash screen
  size           : Can be a string or a table as following:
    - STRING : set to 'image' to use the original image's size
    - TABLE : a table with the 'w' and 'h' fields used to specify the splash image width & the height
  setDisplaySize : If set to true the display size will get the image size

NOTES
  This function is used to show a nice splash screen during the startup of you applications, the image will fade in and you can also print a text and show a progress bar while loading your app using these fuctions:
  - HGui.MsgSplashScreen(txt)
  - HGui.AnimSplashScreen(txt)
  
  You can remove the splash screen with a fade out effect with:
  - HGui.HideSplashScreen(color)
    
  The animation is a moving bar on the bottom of the image with an optional text message.

  -- internal notes ---
  All informations about the splash screen are stored in the table
  'HGui.Splash', it has the following fields:
    .w          Splash screen width
    .h          Splash screen height
    .image      Splash screen image brush (removed as soon as it is displayed)
  The following fields are hardcoded:
    .animWidth  Animation width
    .animStep   Animation step
    .animColor  Animation color
    .animX      Animation negative width (for left entering fx)
-------------------------------------------------*/
  
  If IsNil(setDisplaySize) Then setDisplaySize = True
  
  HGui.splash = {}
  
  HGui.splash.w, HGui.splash.h = GetAttribute(#DISPLAY, 1, #ATTRWIDTH), GetAttribute(#DISPLAY, 1, #ATTRHEIGHT)
  SetDisplayAttributes(
    { Borderless   = True,
      Sizeable     = False,
      NoHide       = True,
      NoClose      = True,
      HideTitleBar = True,
      Color        = #WHITE
      })
  
  Local alpha = False
  Local r, i = IsPicture(imageFile)
  alpha = i.alpha
  
  HGui.splash.Image = LoadBrush(Nil, imageFile, { LoadAlpha = alpha })
  If Not(IsNil(size))
    If GetType(size) = #STRING
      If size = "image"
        HGui.Splash.w = GetAttribute(#BRUSH, HGui.splash.image, #ATTRWIDTH)
        HGui.Splash.h = GetAttribute(#BRUSH, HGui.splash.image, #ATTRHEIGHT)
        
      EndIf
      
    ElseIf GetType(size) = #TABLE
      HGui.splash.w = size.w
      HGui.splash.h = size.h
      
    EndIf
    
  EndIf
  
  ScaleBrush(HGui.splash.Image, HGui.splash.w, #KEEPASPRAT, True)
  HGui.Splash.w = GetAttribute(#BRUSH, HGui.splash.image, #ATTRWIDTH)
  HGui.Splash.h = GetAttribute(#BRUSH, HGui.splash.image, #ATTRHEIGHT)

  If setDisplaySize
    ChangeDisplaySize(HGui.splash.w, HGui.splash.h)
    
  EndIf
  
  DisplayBrushFX(HGui.splash.Image, #CENTER, #CENTER, 
    { Type  = #CROSSFADE,
      Speed = #SLOWSPEED
      })

  FreeBrush(HGui.splash.Image)

  ; Setup the splash screen data
  HGui.Splash.AnimWidth = HGui.Splash.w * 0.20
  HGui.Splash.AnimStep  = HGui.Splash.w * 0.01
  HGui.Splash.AnimColor = $AAAAAA
  HGui.Splash.AnimX     = -HGui.Splash.AnimWidth

EndFunction

Function HGui.MsgSplashScreen(txt) ; *TriDoc* *
/*-------------------------------------
HGui.MsgSplashScreen(txt)

Used only with an opened splash screen.
It displays a message on the bottom of the splash image, the text will be
centered on a white bar.

INPUT
  txt : The text you want to display

NOTES
  Font color, font size and text background are hardcoded
---------------------------------------*/

  SetFillStyle(#FILLCOLOR)
  
  Box(0, #BOTTOM, GetAttribute(#DISPLAY, 1, #ATTRWIDTH), 16, #WHITE)
  
  SetFont(#SANS, 16, { Engine = #FONTENGINE_INBUILT })
  SetFontColor(#BLACK)
  SetFontStyle(#ANTIALIAS)

  TextOut(#CENTER, #BOTTOM, txt)
  
EndFunction

Function HGui.AnimSplashScreen(txt) ; *TriDoc* *
/*-------------------------------------
HGui.AnimSplashScreen(txt)

Animate the splash screen updating the text if 'txt' has been provided.
The standard animation is a bar moving under the text, at the bottom of the
splash screen.

INPUT
  txt : Text to update (optional)
  
NOTE
  This function is pretty rude, not much customization is available even if
  it's pretty simple to change the code to your taste.
---------------------------------------*/
  
  VWait()
  
  ; Animate the bar
  Box(0, #BOTTOM, GetAttribute(#DISPLAY, 1, #ATTRWIDTH), 16, #WHITE)
  Box(HGui.Splash.AnimX, 
      #BOTTOM-2, 
      HGui.Splash.AnimWidth, 
      16-4, 
      HGui.Splash.AnimColor)
  
  HGui.Splash.AnimX = HGui.Splash.AnimX + HGui.Splash.AnimStep
  If HGui.Splash.AnimX > HGui.Splash.W
    HGui.Splash.AnimX = -HGui.Splash.AnimWidth
  EndIf

  ; Render the text if provided
  If Not(IsNil(txt))
    SetFont(#SANS, 16, { Engine = #FONTENGINE_INBUILT })
    SetFontColor(#BLACK)
    SetFontStyle(#ANTIALIAS+#BOLD)

    TextOut(#CENTER, #BOTTOM, txt)  
  EndIf
  
EndFunction

Function HGui.HideSplashScreen(color) ; *TriDoc*
/*-----------------------------------
HGui.HideSplashScreen(color)

Hide the splash screen using a crossfade effect and the given 'color',
the display is not closed because will be reused by HGui when the first
window will be opened.
-------------------------------------------------
INPUT
  color             Color to use for the crossfade effect
-------------------------------------------------*/
  Local brush = CreateBrush(Nil, GetAttribute(#DISPLAY, 1, #ATTRWIDTH), 
                                 GetAttribute(#DISPLAY, 1, #ATTRHEIGHT), 
                                 color)
  
  DisplayBrushFX(brush, #CENTER, #CENTER, 
    { Type = #CROSSFADE,
      Speed = #NORMALSPEED
      })
  
  FreeBrush(brush)
  
EndFunction


/* 
==================================================================
                           DEBUG
==================================================================
*/
HGui.Debug = {}

Function HGui.Debug.Enable(channels) ; *TriDoc*
  ; Enable/Disable console debug channels
  ;
  ; INPUT
  ; - channels
  ;  - main           True/False
  ;  - windows        True/False
  ; ---------------------------------------------
  
  Local enable_main    = False
  Local enable_windows = False
  
  If TB.Item.Exists(channels, "main")
    If channels.main Then enable_main = True
  EndIf
  
  If TB.Iem.Exist(channels, "windows")
    If channels.windows Then enable_windows = True
  EndIf
  
  If enable_main Or enable_windows
    DBG.Console.Enable(True, True)
    If enable_main Then DBG.Console.AddChannel(HGui.DebugChannel)
    If enable_windows Then DBG.Console.AddChannel(HGui.WChannel)
  EndIf
  
EndFunction

; -------------------------------------------------------------------
; TEST SUITE
; -------------------------------------------------------------------
HGui.Tests = {}

;====================================================================
; WINDOWS
;====================================================================
; Windows
Function HGui.Tests.Windows()
  ; Enable Debug Output
  
  ; Create windows
  
  ; Modify Windows
  
  ; Close Windows
  
  ; Free Windows
  
EndFunction

;====================================================================
; GADGETS
;====================================================================

;====================================================================
; GADGETS EVENTS
;====================================================================

;====================================================================
; GADGETS METHODS
;====================================================================
; COMMON
; ======
; :Disable()
; :Enable()
; :Render(partial, skip, quiet)
; :RestoreBG() NOT YET IMPLEMENTED
; :AdaptFontSize(minSize)                           BUTTONS, LABELS
; :cacheBuild()
; :cacheFree()
; :drag() NOT YET IMPLEMENTED
; :draw(tArea, txtBrush, state)
; :drawScrollbarHandle(status)
; :free(refresh)
; :freeChildren(refresh)
; :layoutSet(options, update)
; :layoutUpdate(force)
; :link(target, action, params)
; :new(type, params, parent)
; :set(options, redraw)
; :setTheme(theme, refreshWindow)
; :skinBordersUpdate(skin)
; :unlink(target)
; ---------------------------------------------
; BOX
; ===
; - none -
; VDIVIDER
; ========
; - none -
; HDIVIDER
; ========
; - none -
; LABEL
; =====
;   :Align(textAlignment, refresh)                  Set text alignment
;   :AppendLine(txt, autoscroll, refresh)           Append the text as last line
;   :Clear(refresh)                                 Clear the label's contents
;   :FontMargins(marginsTable, refresh)             Set text margins
;   :FontSize(size, refresh)                        Set the font size
;   :FontStyle(styles, refresh)                     Set the font style
;   :Get()                                          Returns the stored text
;   :ScrollBottom(maximize, refresh)                Scroll to the last line
;   :ScrollDown(rows, refresh)                      Scroll down rows lines
;   :ScrollTo(row, refresh)                         Scroll to the given row
;   :ScrollTop(refresh)                             Scroll to the first line
;   :ScrollUp(rows, refresh)                        Scroll up rows lines
; GROUP
; =====
; - none -
; BUTTON
; ======
; - none -
; SWITCH
; ======
;   :getValue()
;   :setValue(value)
;   :isDown()
;   :isUp()
;   :setCaptions(table)
; SCROLLBAR
; =========
; - none -
; PROGRESSBAR
; ===========
; - none -
; SLIDER
; ======
; - none -
; KNOB
; ====
; - none -
; TEXT
; ====
;   :getText()
;   :setText(text)
; LISTVIEW
; ========
;   :SelectAll(Refresh)
;   :UnselectAll(Refresh)
;   :DeselectAll(Refresh)
;   :RemoveAll(Refresh)
;   :RemoveSelected(Refresh)
;   :Get()
;   :Insert(record, index, select, refresh)
;   :SetItems(itemsList, refresh)
; TREEVIEW
; ========
;   :SelectAll(Refresh)
;   :UnselectAll(Refresh)
;   :RemoveSelected(Refresh)
;   :Get()
; DROPDOWN
; ========
; - none -
; IMAGE
; =====
; - none -
; VIRTUAL
; =======
; - none -
; CANVAS
; ======
;   :addLayer([layerArgs])
;   :removeLayer(layerID)
;   :getLayers()
;   :beginDraw(layerID, mode)
;   :endDraw()
;   :refresh()
;--------------------------------------------------------------------------


;@INCLUDE "HGUI_INC/test_suite.hws"

;------------------------------------------------------------------------------
;------------------------------------------------------------------------------



/*
PRIMA DI PROSEGUIRE CON GLI ALTRI GADGET
- IMPLEMENTARE IL FOCUS
-- Window   -> FocusList da aggiornare ogni volta che un gadget viene creato,
               tenendo anche conto del parametro <FocusPosition> ed ogni volta
               che il focus riceve il focus. Prendere come esempio <WinOrder>.
-- Gadget   -> Implementare la nuova tag <FocusPosition>.
-- Render   -> If <self> = <FocusList[0]> render focus feedback
-- Keyboard -> Implementare gestione navigazione con gestione Focus, e gestione
               Shortcuts.
*/




